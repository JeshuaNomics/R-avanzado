[{"path":"index.html","id":"welcome","chapter":"Welcome","heading":"Welcome","text":" website 2nd edition “Advanced R”, book Chapman & Hall’s R Series. book designed primarily R users want improve programming skills understanding language. also useful programmers coming R languages, help understand R works way .’re looking 1st edition, can find http://adv-r..co.nz/.","code":""},{"path":"index.html","id":"license","chapter":"Welcome","heading":"License","text":"work, whole, licensed Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.code contained book simultaneously available MIT license; means free use packages, long cite source.","code":""},{"path":"index.html","id":"other-books","chapter":"Welcome","heading":"Other books","text":"may also interested :“Advanced R Solutions” \nMalte Grosser Henning Bumann, provides worked solutions exercises\nbook.“Advanced R Solutions” \nMalte Grosser Henning Bumann, provides worked solutions exercises\nbook.“R Data Science” introduces R\ntool data science, focussing consistent\nset packages known tidyverse.“R Data Science” introduces R\ntool data science, focussing consistent\nset packages known tidyverse.“R Packages” teaches \nmake R’s fantastic package system.“R Packages” teaches \nmake R’s fantastic package system.","code":""},{"path":"preface.html","id":"preface","chapter":"Preface","heading":"Preface","text":"Welcome second edition Advanced R. three main goals edition:Improve coverage important concepts fully understood \npublication first edition.Improve coverage important concepts fully understood \npublication first edition.Reduce coverage topics time shown less useful, think\nreally exciting turn practical.Reduce coverage topics time shown less useful, think\nreally exciting turn practical.Generally make material easier understand better text, clearer\ncode, many diagrams.Generally make material easier understand better text, clearer\ncode, many diagrams.’re familiar first edition, preface describes major changes can focus reading new areas. ’re reading printed version book ’ll notice one big change quickly: Advanced R now colour! considerably improved syntax highlighting code chunks, made much easier create helpful diagrams. taken advantage included 100 new diagrams throughout book.Another big change version use new packages, particularly rlang, provides clean interface low-level data structures operations. first edition used base R functions almost exclusively, created pedagogical challenges many functions evolved independently multiple years, making hard see big underlying ideas hidden amongst incidental variations function names arguments. continue show base equivalents sidebars, footnotes, needed, individual sections, want see purest base R expression ideas book, recommend reading first edition, can find online http://adv-r..co.nz.foundations R changed five years since first edition, understanding certainly . Thus, overall structure “Foundations” remained roughly , many individual chapters considerably improved:Chapter 2, “Names values,” brand new chapter\nhelps understand difference objects names \nobjects. helps accurately predict R make copy \ndata structure, lays important groundwork understand functional\nprogramming.Chapter 2, “Names values,” brand new chapter\nhelps understand difference objects names \nobjects. helps accurately predict R make copy \ndata structure, lays important groundwork understand functional\nprogramming.Chapter 3, “Vectors” (previously called data structures),\nrewritten focus vector types like integers, factors, \ndata frames. contains details important S3 vectors (like dates\ndate-times), discusses data frame variation provided \ntibble package,1 generally reflects improved understanding\nvector data types.Chapter 3, “Vectors” (previously called data structures),\nrewritten focus vector types like integers, factors, \ndata frames. contains details important S3 vectors (like dates\ndate-times), discusses data frame variation provided \ntibble package,1 generally reflects improved understanding\nvector data types.Chapter 4, “Subsetting,” now distinguishes [ \n[[ intention: [ extracts many values [[ extracts \nsingle value (previously characterised whether “simplified”\n“preserved”). Section 4.3 draws “train” help \nunderstand [[ works lists, introduces new functions \nprovide consistent behaviour --bounds indices.Chapter 4, “Subsetting,” now distinguishes [ \n[[ intention: [ extracts many values [[ extracts \nsingle value (previously characterised whether “simplified”\n“preserved”). Section 4.3 draws “train” help \nunderstand [[ works lists, introduces new functions \nprovide consistent behaviour --bounds indices.Chapter 5, “Control flow,” new chapter: somehow\npreviously forgot important tools like statements \nloops!Chapter 5, “Control flow,” new chapter: somehow\npreviously forgot important tools like statements \nloops!Chapter 6, “Functions,” improved ordering,\nintroduces pipe (%>%) third way compose functions (Section\n6.3), considerably improved coverage \nfunction forms (Section 6.8).Chapter 6, “Functions,” improved ordering,\nintroduces pipe (%>%) third way compose functions (Section\n6.3), considerably improved coverage \nfunction forms (Section 6.8).Chapter 7, “Environments,” reorganised treatment \nspecial environments (Section 7.4), much\nimproved discussion call stack (Section 7.5).Chapter 7, “Environments,” reorganised treatment \nspecial environments (Section 7.4), much\nimproved discussion call stack (Section 7.5).Chapter 8, “Conditions,” contains material previously\n“Exceptions debugging,” much new content R’s condition\nsystem works. also shows create custom condition\nclasses (Section 8.5).Chapter 8, “Conditions,” contains material previously\n“Exceptions debugging,” much new content R’s condition\nsystem works. also shows create custom condition\nclasses (Section 8.5).chapters following Part , Foundations, re-organised around three important programming paradigms R: functional programming, object-oriented programming, metaprogramming.Functional programming now cleanly divided three main\ntechniques: “Functionals” (Chapter 9), “Function\nfactories” (Chapter 10), “Function operators”\n(Chapter 11). ’ve focussed ideas \npractical applications data science reduced amount pure theory.\nchapters now use functions provided purrr package,2\nallow focus underlying ideas less \nincidental details. led considerable simplification \nfunction operators chapter since major use work around absence\nellipses (...) base functionals.Functional programming now cleanly divided three main\ntechniques: “Functionals” (Chapter 9), “Function\nfactories” (Chapter 10), “Function operators”\n(Chapter 11). ’ve focussed ideas \npractical applications data science reduced amount pure theory.chapters now use functions provided purrr package,2\nallow focus underlying ideas less \nincidental details. led considerable simplification \nfunction operators chapter since major use work around absence\nellipses (...) base functionals.Object-oriented programming (OOP) now forms major section book \ncompletely new chapters base types (Chapter 12),\nS3 (Chapter 13), S4 (Chapter 15), R6 (Chapter 14),\ntradeoffs systems (Chapter 16).\nchapters focus different object systems work,\nuse effectively. unfortunate, necessary, \nmany technical details described elsewhere, effective use\nOOP needs whole book .Object-oriented programming (OOP) now forms major section book \ncompletely new chapters base types (Chapter 12),\nS3 (Chapter 13), S4 (Chapter 15), R6 (Chapter 14),\ntradeoffs systems (Chapter 16).chapters focus different object systems work,\nuse effectively. unfortunate, necessary, \nmany technical details described elsewhere, effective use\nOOP needs whole book .Metaprogramming (previously called “computing language”) describes \nsuite tools can use generate code code. Compared \nfirst edition material substantially expanded now focusses \n“tidy evaluation,” set ideas theory make metaprogramming\nsafe, well-principled, accessible many R programmers.\nChapter 17, “Big picture” coarsely lays \npieces fit together; Chapter 18, “Expressions,” describes\nunderlying data structures; Chapter 19,\n“Quasiquotation,” covers quoting unquoting; Chapter 20,\n“Evaluation,” explains evaluation code special environments; Chapter\n21, “Translations,” pulls themes together show\nmight translate one (programming) language another.Metaprogramming (previously called “computing language”) describes \nsuite tools can use generate code code. Compared \nfirst edition material substantially expanded now focusses \n“tidy evaluation,” set ideas theory make metaprogramming\nsafe, well-principled, accessible many R programmers.\nChapter 17, “Big picture” coarsely lays \npieces fit together; Chapter 18, “Expressions,” describes\nunderlying data structures; Chapter 19,\n“Quasiquotation,” covers quoting unquoting; Chapter 20,\n“Evaluation,” explains evaluation code special environments; Chapter\n21, “Translations,” pulls themes together show\nmight translate one (programming) language another.final section book pulls together chapters programming techniques: profiling, measuring improving performance, Rcpp. contents similar first edition, although organisation little different. made light updates throughout chapters particularly use newer packages (microbenchmark -> bench, lineprof -> profvis), majority text .second edition mostly expanded coverage existing material, five chapters removed:vocabulary chapter removed always bit odd\nduck, effective ways present vocabulary lists \nbook chapter.vocabulary chapter removed always bit odd\nduck, effective ways present vocabulary lists \nbook chapter.style chapter replaced online style guide,\nhttp://style.tidyverse.org/. style guide paired new\nstyler package3 can automatically apply many rules.style chapter replaced online style guide,\nhttp://style.tidyverse.org/. style guide paired new\nstyler package3 can automatically apply many rules.C chapter moved https://github.com/hadley/r-internals, , time, provide\nguide writing C code works R’s data structures.C chapter moved https://github.com/hadley/r-internals, , time, provide\nguide writing C code works R’s data structures.memory chapter removed. Much material integrated\nChapter 2 remainder felt excessively technical\nimportant understand.memory chapter removed. Much material integrated\nChapter 2 remainder felt excessively technical\nimportant understand.chapter R’s performance language removed. delivered\nactionable insights, became dated R changed.chapter R’s performance language removed. delivered\nactionable insights, became dated R changed.","code":""},{"path":"introduction.html","id":"introduction","chapter":"1 Introduction","heading":"1 Introduction","text":"now programming R 15 years, full-time last five years. given luxury time examine language works. book attempt pass ’ve learned can understand intricacies R quickly painlessly possible. Reading help avoid mistakes ’ve made dead ends ’ve gone , teach useful tools, techniques, idioms can help attack many types problems. process, hope show , despite sometimes frustrating quirks, R , heart, elegant beautiful language, well tailored data science.","code":""},{"path":"introduction.html","id":"why-r","chapter":"1 Introduction","heading":"1.1 Why R?","text":"new R, might wonder makes learning quirky language worthwhile. , best features :’s free, open source, available every major platform. result, \nanalysis R, anyone can easily replicate , regardless \nlive much money earn.’s free, open source, available every major platform. result, \nanalysis R, anyone can easily replicate , regardless \nlive much money earn.R diverse welcoming community, online (e.g. \n#rstats twitter community) person (like \nmany R meetups). Two particularly inspiring community groups \nrweekly newsletter makes easy keep date \nR, R-Ladies made wonderfully welcoming community\nwomen minority genders.R diverse welcoming community, online (e.g. \n#rstats twitter community) person (like \nmany R meetups). Two particularly inspiring community groups \nrweekly newsletter makes easy keep date \nR, R-Ladies made wonderfully welcoming community\nwomen minority genders.massive set packages statistical modelling, machine learning,\nvisualisation, importing manipulating data. Whatever model \ngraphic ’re trying , chances someone already tried\ncan learn efforts.massive set packages statistical modelling, machine learning,\nvisualisation, importing manipulating data. Whatever model \ngraphic ’re trying , chances someone already tried\ncan learn efforts.Powerful tools communicating results. RMarkdown makes\neasy turn results HTML files, PDFs, Word documents,\nPowerPoint presentations, dashboards . Shiny allows \nmake beautiful interactive apps without knowledge HTML javascript.Powerful tools communicating results. RMarkdown makes\neasy turn results HTML files, PDFs, Word documents,\nPowerPoint presentations, dashboards . Shiny allows \nmake beautiful interactive apps without knowledge HTML javascript.RStudio, IDE, provides integrated\ndevelopment environment, tailored needs data science, interactive\ndata analysis, statistical programming.RStudio, IDE, provides integrated\ndevelopment environment, tailored needs data science, interactive\ndata analysis, statistical programming.Cutting edge tools. Researchers statistics machine learning often\npublish R package accompany articles. means immediate\naccess latest statistical techniques implementations.Cutting edge tools. Researchers statistics machine learning often\npublish R package accompany articles. means immediate\naccess latest statistical techniques implementations.Deep-seated language support data analysis. includes features\nlike missing values, data frames, vectorisation.Deep-seated language support data analysis. includes features\nlike missing values, data frames, vectorisation.strong foundation functional programming. ideas functional\nprogramming well suited challenges data science, \nR language functional heart, provides many primitives needed\neffective functional programming.strong foundation functional programming. ideas functional\nprogramming well suited challenges data science, \nR language functional heart, provides many primitives needed\neffective functional programming.RStudio, company, makes money \nselling professional products teams R users, turns around \ninvests much money back open source community (50%\nsoftware engineers RStudio work open source projects). work \nRStudio fundamentally believe mission.RStudio, company, makes money \nselling professional products teams R users, turns around \ninvests much money back open source community (50%\nsoftware engineers RStudio work open source projects). work \nRStudio fundamentally believe mission.Powerful metaprogramming facilities. R’s metaprogramming capabilities allow\nwrite magically succinct concise functions provide excellent\nenvironment designing domain-specific languages like ggplot2, dplyr,\ndata.table, .Powerful metaprogramming facilities. R’s metaprogramming capabilities allow\nwrite magically succinct concise functions provide excellent\nenvironment designing domain-specific languages like ggplot2, dplyr,\ndata.table, .ease R can connect high-performance programming languages\nlike C, Fortran, C++.ease R can connect high-performance programming languages\nlike C, Fortran, C++.course, R perfect. R’s biggest challenge (opportunity!) R users programmers. means :Much R code ’ll see wild written haste solve\npressing problem. result, code elegant, fast, easy \nunderstand. users revise code address shortcomings.Much R code ’ll see wild written haste solve\npressing problem. result, code elegant, fast, easy \nunderstand. users revise code address shortcomings.Compared programming languages, R community focussed \nresults processes. Knowledge software engineering best practices \npatchy. example, enough R programmers use source code control \nautomated testing.Compared programming languages, R community focussed \nresults processes. Knowledge software engineering best practices \npatchy. example, enough R programmers use source code control \nautomated testing.Metaprogramming double-edged sword. many R functions use\ntricks reduce amount typing cost making code \nhard understand can fail unexpected ways.Metaprogramming double-edged sword. many R functions use\ntricks reduce amount typing cost making code \nhard understand can fail unexpected ways.Inconsistency rife across contributed packages, even within base R.\nconfronted 25 years evolution every time use R,\ncan make learning R tough many special cases \nremember.Inconsistency rife across contributed packages, even within base R.\nconfronted 25 years evolution every time use R,\ncan make learning R tough many special cases \nremember.R particularly fast programming language, poorly written R code\ncan terribly slow. R also profligate user memory.R particularly fast programming language, poorly written R code\ncan terribly slow. R also profligate user memory.Personally, think challenges create great opportunity experienced programmers profound positive impact R R community. R users care writing high quality code, particularly reproducible research, don’t yet skills . hope book help R users become R programmers, also encourage programmers languages contribute R.","code":""},{"path":"introduction.html","id":"who-should-read","chapter":"1 Introduction","heading":"1.2 Who should read this book","text":"book aimed two complementary audiences:Intermediate R programmers want dive deeper R, understand \nlanguage works, learn new strategies solving diverse problems.Intermediate R programmers want dive deeper R, understand \nlanguage works, learn new strategies solving diverse problems.Programmers languages learning R want understand\nR works way .Programmers languages learning R want understand\nR works way .get book, ’ll need written decent amount code R another programming language. familiar basics data analysis (.e. data import, manipulation, visualisation), written number functions, familiar installation use CRAN packages.book walks narrow line reference book (primarily used lookup), linearly readable. involves tradeoffs, ’s difficult linearise material still keeping related materials together, concepts much easier explain ’re already familiar specific technical vocabulary. ’ve tried use footnotes cross-references make sure can still make sense even just dip toes chapter.","code":""},{"path":"introduction.html","id":"what-you-will-get","chapter":"1 Introduction","heading":"1.3 What you will get out of this book","text":"book delivers knowledge think advanced R programmer possess: deep understanding fundamentals coupled broad vocabulary means can tactically learn topic needed.reading book, :familiar foundations R. understand complex data types\nbest ways perform operations . deep\nunderstanding functions work, ’ll know environments , \nmake use condition system.familiar foundations R. understand complex data types\nbest ways perform operations . deep\nunderstanding functions work, ’ll know environments , \nmake use condition system.Understand functional programming means, useful tool \ndata science. ’ll able quickly learn use existing tools, \nknowledge create functional tools needed.Understand functional programming means, useful tool \ndata science. ’ll able quickly learn use existing tools, \nknowledge create functional tools needed.Know R’s rich variety object-oriented systems. ’ll \nfamiliar S3, ’ll know S4 R6 look \ninformation needed.Know R’s rich variety object-oriented systems. ’ll \nfamiliar S3, ’ll know S4 R6 look \ninformation needed.Appreciate double-edged sword metaprogramming. ’ll able \ncreate functions use tidy evaluation, saving typing creating elegant\ncode express important operations. ’ll also understand dangers\navoid .Appreciate double-edged sword metaprogramming. ’ll able \ncreate functions use tidy evaluation, saving typing creating elegant\ncode express important operations. ’ll also understand dangers\navoid .good intuition operations R slow use lot \nmemory. ’ll know use profiling pinpoint performance\nbottlenecks, ’ll know enough C++ convert slow R functions \nfast C++ equivalents.good intuition operations R slow use lot \nmemory. ’ll know use profiling pinpoint performance\nbottlenecks, ’ll know enough C++ convert slow R functions \nfast C++ equivalents.","code":""},{"path":"introduction.html","id":"what-you-will-not-learn","chapter":"1 Introduction","heading":"1.4 What you will not learn","text":"book R programming language, R data analysis tool. looking improve data science skills, instead recommend learn tidyverse, collection consistent packages developed colleagues. book ’ll learn techniques used develop tidyverse packages; want instead learn use , recommend R Data Science.want share R code others, need make R package. allows bundle code along documentation unit tests, easily distribute via CRAN. opinion, easiest way develop packages devtools, roxygen2, testthat, usethis. can learn using packages make package R packages.","code":""},{"path":"introduction.html","id":"meta-techniques","chapter":"1 Introduction","heading":"1.5 Meta-techniques","text":"two meta-techniques tremendously helpful improving skills R programmer: reading source code adopting scientific mindset.Reading source code important help write better code. great place start developing skill look source code functions packages use often. ’ll find things worth emulating code ’ll develop sense taste makes good R code. also see things don’t like, either virtues obvious offends sensibilities. code nonetheless valuable, helps make concrete opinions good bad code.scientific mindset extremely helpful learning R. don’t understand something works, develop hypothesis, design experiments, run , record results. exercise extremely useful since can’t figure something need get help, can easily show others tried. Also, learn right answer, ’ll mentally prepared update world view.","code":""},{"path":"introduction.html","id":"recommended-reading","chapter":"1 Introduction","heading":"1.6 Recommended reading","text":"R community mostly consists data scientists, computer scientists, relatively books go deep technical underpinnings R. personal journey understand R, ’ve found particularly helpful use resources programming languages. R aspects functional object-oriented (OO) programming languages. Learning concepts expressed R help leverage existing knowledge programming languages, help identify areas can improve.understand R’s object systems work way , found Structure Interpretation Computer Programs45 (SICP) particularly helpful. ’s concise deep book, reading , felt first time actually design object-oriented system. book first introduction encapsulated paradigm object-oriented programming found R, helped understand strengths weaknesses system. SICP also teaches functional mindset create functions simple individually, become powerful composed together.understand trade-offs R made compared programming languages, found Concepts, Techniques Models Computer Programming6 extremely helpful. helped understand R’s copy--modify semantics make substantially easier reason code, current implementation particularly efficient, solvable problem.want learn better programmer, ’s place better turn Pragmatic Programmer.7 book language agnostic, provides great advice better programmer.","code":""},{"path":"introduction.html","id":"getting-help","chapter":"1 Introduction","heading":"1.7 Getting help","text":"\nCurrently, three main venues get help ’re stuck can’t figure ’s causing problem: RStudio Community, StackOverflow R-help mailing list. can get fantastic help venue, cultures expectations. ’s usually good idea spend little time lurking, learning community expectations, put first post.good general advice:Make sure latest version R package (packages)\nproblems . may problem result \nrecently fixed bug.Make sure latest version R package (packages)\nproblems . may problem result \nrecently fixed bug.Spend time creating reproducible example, reprex.\nhelp others help , often leads solution without\nasking others, course making problem reproducible \noften figure root cause. highly recommend learning using\nreprex package.Spend time creating reproducible example, reprex.\nhelp others help , often leads solution without\nasking others, course making problem reproducible \noften figure root cause. highly recommend learning using\nreprex package.looking specific help solving exercises book, solutions Malte Grosser Henning Bumann available https://advanced-r-solutions.rbind.io.","code":""},{"path":"introduction.html","id":"intro-ack","chapter":"1 Introduction","heading":"1.8 Acknowledgments","text":"like thank many contributors R-devel R-help , recently, Stack Overflow RStudio Community. many name individually, ’d particularly like thank Luke Tierney, John Chambers, JJ Allaire, Brian Ripley generously giving time correcting countless misunderstandings.book written open, chapters advertised twitter complete. truly community effort: many people read drafts, fixed typos, suggested improvements, contributed content. Without contributors, book wouldn’t nearly good , ’m deeply grateful help. Special thanks go Jeff Hammerbacher, Peter Li, Duncan Murdoch, Greg Wilson, read book cover--cover provided many fixes suggestions.big thank 386 contributors (alphabetical order username): Aaron Wolen (@aaronwolen), @absolutelyNoWarranty, Adam Hunt (@adamphunt), @agrabovsky, Alexander Grueneberg (@agrueneberg), Anthony Damico (@ajdamico), James Manton (@ajdm), Aaron Schumacher (@ajschumacher), Alan Dipert (@alandipert), Alex Brown (@alexbbrown), @alexperrone, Alex Whitworth (@alexWhitworth), Alexandros Kokkalis (@alko989), @amarchin, Amelia McNamara (@AmeliaMN), Bryce Mecum (@amoeba), Andrew Laucius (@andrewla), Andrew Bray (@andrewpbray), Andrie de Vries (@andrie), Angela Li (@angela-li), @aranlunzer, Ari Lamstein (@arilamstein), @asnr, Andy Teucher (@ateucher), Albert Vilella (@avilella), baptiste (@baptiste), Brian G. Barkley (@BarkleyBG), Mara Averick (@batpigandme), Byron (@bcjaeger), Brandon Greenwell (@bgreenwell), Brandon Hurr (@bhive01), Jason Knight (@binarybana), Brett Klamer (@bklamer), Jesse Anderson (@blindjesse), Brian Mayer (@blmayer), Benjamin L. Moore (@blmoore), Brian Diggs (@BrianDiggs), Brian S. Yandell (@byandell), @carey1024, Chip Hogg (@chiphogg), Chris Muir (@ChrisMuir), Christopher Gandrud (@christophergandrud), Clay Ford (@clayford), Colin Fay (@ColinFay), @cortinah, Cameron Plouffe (@cplouffe), Carson Sievert (@cpsievert), Craig Citro (@craigcitro), Craig Grabowski (@craiggrabowski), Christopher Roach (@croach), Peter Meilstrup (@crowding), Crt Ahlin (@crtahlin), Carlos Scheidegger (@cscheid), Colin Gillespie (@csgillespie), Christopher Brown (@ctbrown), Davor Cubranic (@cubranic), Darren Cusanovich (@cusanovich), Christian G. Warden (@cwarden), Charlotte Wickham (@cwickham), Dean Attali (@daattali), Dan Sullivan (@dan87134), Daniel Barnett (@daniel-barnett), Daniel (@danielruc91), Kenny Darrell (@darrkj), Tracy Nance (@datapixie), Dave Childers (@davechilders), David Vukovic (@david-vukovic), David Rubinger (@davidrubinger), David Chudzicki (@dchudz), Deependra Dhakal (@DeependraD), Daisuke ICHIKAWA (@dichika), david kahle (@dkahle), David LeBauer (@dlebauer), David Schweizer (@dlschweizer), David Montaner (@dmontaner), @dmurdoch, Zhuoer Dong (@dongzhuoer), Doug Mitarotonda (@dougmitarotonda), DragoÈ™ Moldovan-GrÃ¼nfeld (@dragosmg), Jonathan Hill (@Dripdrop12), @drtjc, Julian (@duju211), @duncanwadsworth, @eaurele, Dirk Eddelbuettel (@eddelbuettel), @EdFineOKL, Eduard SzÃ¶cs (@EDiLD), Edwin Thoen (@EdwinTh), Ethan Heinzen (@eheinzen), @eijoac, Joel Schwartz (@eipi10), Eric Ronald Legrand (@elegrand), Elio Campitelli (@eliocamp), Ellis Valentiner (@ellisvalentiner), Emil Hvitfeldt (@EmilHvitfeldt), Emil Rehnberg (@EmilRehnberg), Daniel Lee (@erget), Eric C. Anderson (@eriqande), Enrico Spinielli (@espinielli), @etb, David Hajage (@eusebe), Fabian Scheipl (@fabian-s), @flammy0530, FranÃ§ois Michonneau (@fmichonneau), Francois Pepin (@fpepin), Frank Farach (@frankfarach), @freezby, Frans van DunnÃ© (@FvD), @fyears, @gagnagaman, Garrett Grolemund (@garrettgman), Gavin Simpson (@gavinsimpson), Brooke Anderson (@geanders), @gezakiss7, @gggtest, GÃ¶kÃ§en Eraslan (@gokceneraslan), Josh Goldberg (@GoldbergData), Georg Russ (@gr650), @grasshoppermouse, Gregor Thomas (@gregorp), Garrett See (@gsee), Ari Friedman (@gsk3), Gunnlaugur Thor Briem (@gthb), Greg Wilson (@gvwilson), Hamed (@hamedbh), Jeff Hammerbacher (@hammer), Harley Day (@harleyday), @hassaad85, @helmingstay, Henning (@henningsway), Henrik Bengtsson (@HenrikBengtsson), Ching Boon (@hoscb), @hplieninger, HÃ¶rmet Yiltiz (@hyiltiz), Iain Dillingham (@iaindillingham), @IanKopacka, Ian Lyttle (@ijlyttle), Ilan Man (@ilanman), Imanuel Costigan (@imanuelcostigan), Thomas BÃ¼rli (@initdch), Os Keyes (@Ironholds), @irudnyts, (@isomorphisms), Irene Steves (@isteves), Jan Gleixner (@jan-glx), Jannes Muenchow (@jannes-m), Jason Asher (@jasonasher), Jason Davies (@jasondavies), Chris (@jastingo), jcborras (@jcborras), Joe Cheng (@jcheng5), John Blischak (@jdblischak), @jeharmse, Lukas Burk (@jemus42), Jennifer (Jenny) Bryan (@jennybc), Justin Jent (@jentjr), Jeston (@JestonBlu), Josh Cook (@jhrcook), Jim Hester (@jimhester), @JimInNashville, @jimmyliu2017, Jim Vine (@jimvine), Jinlong Yang (@jinlong25), J.J. Allaire (@jjallaire), @JMHay, Jochen Van de Velde (@jochenvdv), Johann Hibschman (@johannh), John Baumgartner (@johnbaums), John Horton (@johnjosephhorton), @johnthomas12, Jon Calder (@jonmcalder), Jon Harmon (@jonthegeek), Julia Gustavsen (@jooolia), JorneBiccler (@JorneBiccler), Jeffrey Arnold (@jrnold), Joyce Robbins (@jtr13), Juan Manuel Truppia (@juancentro), @juangomezduaso, Kevin Markham (@justmarkham), john verzani (@jverzani), Michael Kane (@kaneplusplus), Bart Kastermans (@kasterma), Kevin D’Auria (@kdauria), Karandeep Singh (@kdpsingh), Ken Williams (@kenahoo), Kendon Bell (@kendonB), Kent Johnson (@kent37), Kevin Ushey (@kevinushey), ç”µçº¿æ† (@kfeng123), Karl Forner (@kforner), Kirill Sevastyanenko (@kirillseva), Brian Knaus (@knausb), Kirill MÃ¼ller (@krlmlr), Kriti Sen Sharma (@ksens), Kai Tang (å”æºï¼‰ (@ktang), Kevin Wright (@kwstat), suo.lawrence.liu@gmail.com (@Lawrence-Liu), @ldfmrails, Kevin Kainan Li (@legendre6891), Rachel Severson (@leighseverson), Laurent Gatto (@lgatto), C. Jason Liang (@liangcj), Steve Lianoglou (@lianos), Yongfu Liao (@liao961120), Likan (@likanzhan), @lindbrook, Lingbing Feng (@Lingbing), Marcel Ramos (@LiNk-NY), Zhongpeng Lin (@linzhp), Lionel Henry (@lionel-), LluÃ­s (@llrs), myq (@lrcg), Luke W Johnston (@lwjohnst86), Kevin Lynagh (@lynaghk), @MajoroMask, Malcolm Barrett (@malcolmbarrett), @mannyishere, @mascaretti, Matt (@mattbaggott), Matthew Grogan (@mattgrogan), @matthewhillary, Matthieu Gomez (@matthieugomez), Matt Malin (@mattmalin), Mauro Lepore (@maurolepore), Max Ghenis (@MaxGhenis), Maximilian Held (@maxheld83), Michal Bojanowski (@mbojan), Mark Rosenstein (@mbrmbr), Michael Sumner (@mdsumner), Jun Mei (@meijun), merkliopas (@merkliopas), mfrasco (@mfrasco), Michael Bach (@michaelbach), Michael Bishop (@MichaelMBishop), Michael Buckley (@michaelmikebuckley), Michael Quinn (@michaelquinn32), @miguelmorin, Michael (@mikekaminsky), Mine Cetinkaya-Rundel (@mine-cetinkaya-rundel), @mjsduncan, Mamoun Benghezal (@MoBeng), Matt Pettis (@mpettis), Martin Morgan (@mtmorgan), Guy Dawson (@Mullefa), Nacho Caballero (@nachocab), Natalya Rapstine (@natalya-patrikeeva), Nick Carchedi (@ncarchedi), Pascal Burkhard (@Nenuial), Noah Greifer (@ngreifer), Nicholas Vasile (@nickv9), Nikos Ignatiadis (@nignatiadis), Nina Munkholt Jakobsen (@nmjakobsen), Xavier Laviron (@norival), Nick Pullen (@nstjhp), Oge Nnadi (@ogennadi), Oliver Paisley (@oliverpaisley), Pariksheet Nanda (@omsai), Ã˜ystein SÃ¸rensen (@osorensen), Paul (@otepoti), Otho Mantegazza (@othomantegazza), Dewey Dunnington (@paleolimbot), Paola Corrales (@paocorrales), Parker Abercrombie (@parkerabercrombie), Patrick Hausmann (@patperu), Patrick Miller (@patr1ckm), Patrick Werkmeister (@Patrick01), @paulponcet, @pdb61, Tom Crockett (@pelotom), @pengyu, Jeremiah (@perryjer1), Peter Hickey (@PeteHaitch), Phil Chalmers (@philchalmers), Jose Antonio MagaÃ±Mesa (@picarus), Pierre Casadebaig (@picasa), Antonio Piccolboni (@piccolbo), Pierre Roudier (@pierreroudier), Poor Yorick (@pooryorick), Marie-Helene Burle (@prosoitos), Peter Schulam (@pschulam), John (@quantbo), Quyu Kong (@qykong), Ramiro Magno (@ramiromagno), Ramnath Vaidyanathan (@ramnathv), Kun Ren (@renkun-ken), Richard Reeve (@richardreeve), Richard Cotton (@richierocks), Robert M Flight (@rmflight), R. Mark Sharp (@rmsharp), Robert Krzyzanowski (@robertzk), @robiRagan, Romain FranÃ§ois (@romainfrancois), Ross Holmberg (@rossholmberg), Ricardo Pietrobon (@rpietro), @rrunner, Ryan Walker (@rtwalker), @rubenfcasal, Rob Weyant (@rweyant), Rumen Zarev (@rzarev), Nan Wang (@sailingwave), Samuel Perreault (@samperochkin), @sbgraves237, Scott Kostyshak (@scottkosty), Scott Leishman (@scttl), Sean Hughes (@seaaan), Sean Anderson (@seananderson), Sean Carmody (@seancarmody), Sebastian (@sebastian-c), Matthew Sedaghatfar (@sedaghatfar), @see24, Sven E. Templer (@setempler), @sflippl, @shabbybanks, Steven Pav (@shabbychef), Shannon Rush (@shannonrush), S’busiso Mkhondwane (@sibusiso16), Sigfried Gold (@Sigfried), Simon O’Hanlon (@simonohanlon101), Simon Potter (@sjp), Leo Razoumov (@slonik-az), Richard M. Smith (@Smudgerville), Steve (@SplashDance), Scott Ritchie (@sritchie73), Tim Cole (@statist7), @ste-fan, @stephens999, Steve Walker (@stevencarlislewalker), Stefan Widgren (@stewid), Homer Strong (@strongh), Suman Khanal (@sumanstats), Dirk (@surmann), Sebastien Vigneau (@svigneau), Steven Nydick (@swnydick), Taekyun Kim (@taekyunk), Tal Galili (@talgalili), @Tazinho, Tyler Bradley (@tbradley1013), Tom B (@tbuckl), @tdenes, @thomasherbig, Thomas (@thomaskern), Thomas Lin Pedersen (@thomasp85), Thomas Zumbrunn (@thomaszumbrunn), Tim Waterhouse (@timwaterhouse), TJ Mahr (@tjmahr), Thomas Nagler (@tnagler), Anton Antonov (@tonytonov), Ben Torvaney (@Torvaney), Jeff Allen (@trestletech), Tyler Rinker (@trinker), Chitu Okoli (@Tripartio), Kirill Tsukanov (@tskir), Terence Teo (@tteo), Tim Triche, Jr. (@ttriche), @tyhenkaline, Tyler Ritchie (@tylerritchie), Tyler Littlefield (@tyluRp), Varun Agrawal (@varun729), Vijay Barve (@vijaybarve), Victor (@vkryukov), Vaidotas Zemlys-BaleviÄius (@vzemlys), Winston Chang (@wch), Linda Chin (@wchi144), Welliton Souza (@Welliton309), Gregg Whitworth (@whitwort), Beasley (@wibeasley), William R Bauer (@WilCrofter), William Doane (@WilDoane), Sean Wilkinson (@wilkinson), Christof Winter (@winterschlaefer), Jake Thompson (@wjakethompson), Bill Carver (@wmc3), Wolfgang Huber (@wolfganghuber), Krishna Sankar (@xsankar), Yihui Xie (@yihui), yang (@yiluheihei), Yoni Ben-Meshulam (@yoni), @yuchouchen, Yuqi Liao (@yuqiliao), Hiroaki Yutani (@yutannihilation), Zachary Foster (@zachary-foster), @zachcp, @zackham, Sergio Oller (@zeehio), Edward Cho (@zerokarmaleft), Albert Zhao (@zxzb).","code":"#> Warning: package 'dplyr' was built under R version 4.1.1"},{"path":"introduction.html","id":"conventions","chapter":"1 Introduction","heading":"1.9 Conventions","text":"Throughout book use f() refer functions, g refer variables function parameters, h/ paths.Larger code blocks intermingle input output. Output commented (#>) electronic version book, e.g., https://adv-r.hadley.nz/, can easily copy paste examples R.Many examples use random numbers. made reproducible set.seed(1014), executed automatically start chapter.","code":""},{"path":"introduction.html","id":"colophon","chapter":"1 Introduction","heading":"1.10 Colophon","text":"book written bookdown inside RStudio. website hosted netlify, automatically updated every commit travis-ci. complete source available GitHub. Code printed book set inconsolata. Emoji images printed book come open-licensed Twitter Emoji.version book built R version 4.1.0 (2021-05-18) following packages.","code":""},{"path":"foundations-intro.html","id":"foundations-intro","chapter":"Introduction","heading":"Introduction","text":"start journey mastering R, following six chapters help learn foundational components R. expect ’ve already seen many pieces , probably studied deeply. help check existing knowledge, chapter starts quiz; get questions right, feel free skip next chapter!Chapter 2 teaches important distinction\nprobably haven’t thought deeply : difference \nobject name. Improving mental model help make\nbetter predictions R copies data hence basic\noperations cheap expensive.Chapter 2 teaches important distinction\nprobably haven’t thought deeply : difference \nobject name. Improving mental model help make\nbetter predictions R copies data hence basic\noperations cheap expensive.Chapter 3 dives details vectors, helping \nlearn different types vector fit\ntogether. ’ll also learn attributes, allow store\narbitrary metadata, form basis two R’s object-oriented\nprogramming toolkits.Chapter 3 dives details vectors, helping \nlearn different types vector fit\ntogether. ’ll also learn attributes, allow store\narbitrary metadata, form basis two R’s object-oriented\nprogramming toolkits.Chapter 4 describes use subsetting write\nclear, concise, efficient R code. Understanding fundamental\ncomponents allow solve new problems combining building\nblocks novel ways.Chapter 4 describes use subsetting write\nclear, concise, efficient R code. Understanding fundamental\ncomponents allow solve new problems combining building\nblocks novel ways.Chapter 5 presents tools control flow allow \nexecute code certain conditions, repeatedly execute code\nchanging inputs. include important constructs, well \nrelated tools like switch() .Chapter 5 presents tools control flow allow \nexecute code certain conditions, repeatedly execute code\nchanging inputs. include important constructs, well \nrelated tools like switch() .Chapter 6 deals functions, important building\nblocks R code. ’ll learn exactly work, including \nscoping rules, govern R looks values names. ’ll also\nlearn details behind lazy evaluation, can\ncontrol happens exit function.Chapter 6 deals functions, important building\nblocks R code. ’ll learn exactly work, including \nscoping rules, govern R looks values names. ’ll also\nlearn details behind lazy evaluation, can\ncontrol happens exit function.Chapter 7 describes data structure crucial \nunderstanding R works, quite unimportant data analysis: \nenvironment. Environments data structure binds\nnames values, power important tools like package namespaces.\nUnlike programming languages, environments R “first class”\nmeans can manipulate just like objects.Chapter 7 describes data structure crucial \nunderstanding R works, quite unimportant data analysis: \nenvironment. Environments data structure binds\nnames values, power important tools like package namespaces.\nUnlike programming languages, environments R “first class”\nmeans can manipulate just like objects.Chapter 8 concludes foundations R \nexploration “conditions,” umbrella term used describe errors,\nwarnings, messages. ’ve certainly encountered , \nchapter learn signal appropriately \nfunctions, handle signalled elsewhere.Chapter 8 concludes foundations R \nexploration “conditions,” umbrella term used describe errors,\nwarnings, messages. ’ve certainly encountered , \nchapter learn signal appropriately \nfunctions, handle signalled elsewhere.","code":""},{"path":"names-values.html","id":"names-values","chapter":"2 Names and values","heading":"2 Names and values","text":"","code":""},{"path":"names-values.html","id":"introduction-1","chapter":"2 Names and values","heading":"2.1 Introduction","text":"R, important understand distinction object name. help :accurately predict performance memory usage code.Write faster code avoiding accidental copies, major source slow code.Better understand R’s functional programming tools.goal chapter help understand distinction names values, R copy object.","code":""},{"path":"names-values.html","id":"quiz","chapter":"2 Names and values","heading":"Quiz","text":"Answer following questions see can safely skip chapter. can find answers end chapter Section 2.7.Given following data frame, create new column called “3”\ncontains sum 1 2? may use $, [[.\nmakes 1, 2, 3 challenging variable names?\n\ndf <- data.frame(runif(3), runif(3))\nnames(df) <- c(1, 2)Given following data frame, create new column called “3”\ncontains sum 1 2? may use $, [[.\nmakes 1, 2, 3 challenging variable names?following code, much memory y occupy?\n\nx <- runif(1e6)\ny <- list(x, x, x)following code, much memory y occupy?line get copied following example?\n\n<- c(1, 5, 3, 2)\nb <- \nb[[1]] <- 10On line get copied following example?","code":"\ndf <- data.frame(runif(3), runif(3))\nnames(df) <- c(1, 2)\nx <- runif(1e6)\ny <- list(x, x, x)\na <- c(1, 5, 3, 2)\nb <- a\nb[[1]] <- 10"},{"path":"names-values.html","id":"outline","chapter":"2 Names and values","heading":"Outline","text":"Section 2.2 introduces distinction \nnames values, discusses <- creates binding, reference,\nname value.Section 2.2 introduces distinction \nnames values, discusses <- creates binding, reference,\nname value.Section 2.3 describes R makes copy: whenever \nmodify vector, ’re almost certainly creating new, modified vector.\n’ll learn use tracemem() figure copy actually\noccurs. ’ll explore implications apply function calls,\nlists, data frames, character vectors.Section 2.3 describes R makes copy: whenever \nmodify vector, ’re almost certainly creating new, modified vector.\n’ll learn use tracemem() figure copy actually\noccurs. ’ll explore implications apply function calls,\nlists, data frames, character vectors.Section 2.4 explores implications previous two\nsections much memory object occupies. Since intuition may \nprofoundly wrong since utils::object.size() unfortunately\ninaccurate, ’ll learn use lobstr::obj_size().Section 2.4 explores implications previous two\nsections much memory object occupies. Since intuition may \nprofoundly wrong since utils::object.size() unfortunately\ninaccurate, ’ll learn use lobstr::obj_size().Section 2.5 describes two important exceptions \ncopy--modify: environments values single name, objects \nactually modified place.Section 2.5 describes two important exceptions \ncopy--modify: environments values single name, objects \nactually modified place.Section 2.6 concludes chapter discussion garbage\ncollector, frees memory used objects longer referenced \nname.Section 2.6 concludes chapter discussion garbage\ncollector, frees memory used objects longer referenced \nname.","code":""},{"path":"names-values.html","id":"prerequisites","chapter":"2 Names and values","heading":"Prerequisites","text":"’ll use lobstr package dig internal representation R objects.","code":"\nlibrary(lobstr)\n#> Warning: package 'lobstr' was built under R version 4.1.2"},{"path":"names-values.html","id":"sources","chapter":"2 Names and values","heading":"Sources","text":"details R’s memory management documented single place. Much information chapter gleaned close reading documentation (particularly ?Memory ?gc), memory profiling section Writing R extensions,8 SEXPs section R internals.9 rest figured reading C source code, performing small experiments, asking questions R-devel. mistakes entirely mine.","code":""},{"path":"names-values.html","id":"binding-basics","chapter":"2 Names and values","heading":"2.2 Binding basics","text":"\n\nConsider code:’s easy read : “create object named ‘x,’ containing values 1, 2, 3.” Unfortunately, ’s simplification lead inaccurate predictions R actually behind scenes. ’s accurate say code two things:’s creating object, vector values, c(1, 2, 3).’s binding object name, x.words, object, value, doesn’t name; ’s actually name value.clarify distinction, ’ll draw diagrams like :name, x, drawn rounded rectangle. arrow points (binds references) value, vector c(1, 2, 3). arrow points opposite direction assignment arrow: <- creates binding name left-hand side object right-hand side.Thus, can think name reference value. example, run code, don’t get another copy value c(1, 2, 3), get another binding existing object:might noticed value c(1, 2, 3) label: 0x74b. vector doesn’t name, ’ll occasionally need refer object independent bindings. make possible, ’ll label values unique identifier. identifiers special form looks like object’s memory “address,” .e. location memory object stored. actual memory addresses changes every time code run, use identifiers instead.can access object’s identifier lobstr::obj_addr(). allows see x y point identifier:identifiers long, change every time restart R.can take time get head around distinction names values, understanding really helpful functional programming functions can different names different contexts.","code":"\nx <- c(1, 2, 3)\ny <- x\nobj_addr(x)\n#> [1] \"0x27cc7040\"\nobj_addr(y)\n#> [1] \"0x27cc7040\""},{"path":"names-values.html","id":"non-syntactic","chapter":"2 Names and values","heading":"2.2.1 Non-syntactic names","text":"\n\nR strict rules constitutes valid name. syntactic name must consist letters10, digits, . _ can’t begin _ digit. Additionally, can’t use reserved words like TRUE, NULL, , function (see complete list ?Reserved). name doesn’t follow rules non-syntactic name; try use , ’ll get error:’s possible override rules use name, .e., sequence characters, surrounding backticks:’s unlikely ’d deliberately create crazy names, need understand crazy names work ’ll come across , commonly load data created outside R.can also create non-syntactic bindings using single double quotes (e.g. \"_abc\" <- 1) instead backticks, shouldn’t, ’ll use different syntax retrieve values. ability use strings left hand side assignment arrow historical artefact, used R supported backticks.","code":"_abc <- 1\n#> Error: unexpected input in \"_\"\n\nif <- 10\n#> Error: unexpected assignment in \"if <-\"\n`_abc` <- 1\n`_abc`\n#> [1] 1\n\n`if` <- 10\n`if`\n#> [1] 10"},{"path":"names-values.html","id":"exercises","chapter":"2 Names and values","heading":"2.2.2 Exercises","text":"Explain relationship , b, c d following\ncode:\n\n<- 1:10\nb <- \nc <- b\nd <- 1:10Explain relationship , b, c d following\ncode:following code accesses mean function multiple ways. \npoint underlying function object? Verify \nlobstr::obj_addr().\n\nmean\nbase::mean\nget(\"mean\")\nevalq(mean)\nmatch.fun(\"mean\")following code accesses mean function multiple ways. \npoint underlying function object? Verify \nlobstr::obj_addr().default, base R data import functions, like read.csv(), \nautomatically convert non-syntactic names syntactic ones. might\nproblematic? option allows suppress behaviour?default, base R data import functions, like read.csv(), \nautomatically convert non-syntactic names syntactic ones. might\nproblematic? option allows suppress behaviour?rules make.names() use convert non-syntactic names \nsyntactic ones?rules make.names() use convert non-syntactic names \nsyntactic ones?slightly simplified rules govern syntactic names. .123e1\nsyntactic name? Read ?make.names full details.slightly simplified rules govern syntactic names. .123e1\nsyntactic name? Read ?make.names full details.","code":"\na <- 1:10\nb <- a\nc <- b\nd <- 1:10\nmean\nbase::mean\nget(\"mean\")\nevalq(mean)\nmatch.fun(\"mean\")"},{"path":"names-values.html","id":"copy-on-modify","chapter":"2 Names and values","heading":"2.3 Copy-on-modify","text":"Consider following code. binds x y underlying value, modifies y11.Modifying y clearly didn’t modify x. happened shared binding? value associated y changed, original object . Instead, R created new object, 0xcd2, copy 0x74b one value changed, rebound y object.behaviour called copy--modify. Understanding radically improve intuition performance R code. related way describe behaviour say R objects unchangeable, immutable. However, ’ll generally avoid term couple important exceptions copy--modify ’ll learn Section 2.5.exploring copy--modify behaviour interactively, aware ’ll get different results inside RStudio. ’s environment pane must make reference object order display information . distorts interactive exploration doesn’t affect code inside functions, doesn’t affect performance data analysis. experimentation, recommend either running R directly terminal, using RMarkdown (like book).","code":"\nx <- c(1, 2, 3)\ny <- x\n\ny[[3]] <- 4\nx\n#> [1] 1 2 3"},{"path":"names-values.html","id":"tracemem","chapter":"2 Names and values","heading":"2.3.1 tracemem()","text":"can see object gets copied help base::tracemem(). call function object, ’ll get object’s current address:, whenever object copied, tracemem() print message telling object copied, new address, sequence calls led copy:modify y , won’t get copied. ’s new object now single name bound , R applies modify--place optimisation. ’ll come back Section 2.5.untracemem() opposite tracemem(); turns tracing .","code":"\nx <- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n#> <0x7f80c0e0ffc8> \ny <- x\ny[[3]] <- 4L\n#> tracemem[0x7f80c0e0ffc8 -> 0x7f80c4427f40]: \ny[[3]] <- 5L\n\nuntracemem(x)"},{"path":"names-values.html","id":"function-calls","chapter":"2 Names and values","heading":"2.3.2 Function calls","text":"rules copying also apply function calls. Take code:f() running, inside function points value x outside function:’ll learn conventions used diagram Section 7.4.4. brief: function f() depicted yellow object right. formal argument, , becomes binding (indicated dotted black line) execution environment (gray box) function run.f() completes, x z point object. 0x74b never gets copied never gets modified. f() modify x, R create new copy, z bind object.","code":"\nf <- function(a) {\n  a\n}\n\nx <- c(1, 2, 3)\ncat(tracemem(x), \"\\n\")\n#> <000000002A35E288>\n\nz <- f(x)\n# there's no copy here!\n\nuntracemem(x)"},{"path":"names-values.html","id":"list-references","chapter":"2 Names and values","heading":"2.3.3 Lists","text":"’s just names (.e. variables) point values; elements lists . Consider list, superficially similar numeric vector :list complex instead storing values , stores references :particularly important modify list:Like vectors, lists use copy--modify behaviour; original list left unchanged, R creates modified copy. , however, shallow copy: list object bindings copied, values pointed bindings . opposite shallow copy deep copy contents every reference copied. Prior R 3.1.0, copies always deep copies.see values shared across lists, use lobstr::ref(). ref() prints memory address object, along local ID can easily cross-reference shared components.","code":"\nl1 <- list(1, 2, 3)\nl2 <- l1\nl2[[3]] <- 4\nref(l1, l2)\n#> o [1:0x2a68b020] <list> \n#> +-[2:0x27b0c998] <dbl> \n#> +-[3:0x27b0c960] <dbl> \n#> \\-[4:0x27b0c928] <dbl> \n#>  \n#> o [5:0x27cc6e10] <list> \n#> +-[2:0x27b0c998] \n#> +-[3:0x27b0c960] \n#> \\-[6:0x12c0fb40] <dbl>"},{"path":"names-values.html","id":"df-modify","chapter":"2 Names and values","heading":"2.3.4 Data frames","text":"Data frames lists vectors, copy--modify important consequences modify data frame. Take data frame example:modify column, column needs modified; others still point original references:However, modify row, every column modified, means every column must copied:","code":"\nd1 <- data.frame(x = c(1, 5, 6), y = c(2, 4, 3))\nd2 <- d1\nd2[, 2] <- d2[, 2] * 2\nd3 <- d1\nd3[1, ] <- d3[1, ] * 3"},{"path":"names-values.html","id":"character-vectors","chapter":"2 Names and values","heading":"2.3.5 Character vectors","text":"final place R uses references character vectors12. usually draw character vectors like :polite fiction. R actually uses global string pool element character vector pointer unique string pool:can request ref() show references setting character argument TRUE:profound impact amount memory character vector uses otherwise generally unimportant, elsewhere book ’ll draw character vectors strings lived inside vector.","code":"\nx <- c(\"a\", \"a\", \"abc\", \"d\")\nref(x, character = TRUE)\n#> o [1:0x2aa889d0] <chr> \n#> +-[2:0x12a09cf0] <string: \"a\"> \n#> +-[2:0x12a09cf0] \n#> +-[3:0x26138870] <string: \"abc\"> \n#> \\-[4:0x12bff4a8] <string: \"d\">"},{"path":"names-values.html","id":"exercises-1","chapter":"2 Names and values","heading":"2.3.6 Exercises","text":"tracemem(1:10) useful?tracemem(1:10) useful?Explain tracemem() shows two copies run code.\nHint: carefully look difference code code\nshown earlier section.\n\nx <- c(1L, 2L, 3L)\ntracemem(x)\n\nx[[3]] <- 4Explain tracemem() shows two copies run code.\nHint: carefully look difference code code\nshown earlier section.Sketch relationship following objects:\n\n<- 1:10\nb <- list(, )\nc <- list(b, , 1:10)Sketch relationship following objects:happens run code?\n\nx <- list(1:10)\nx[[2]] <- x\nDraw picture.happens run code?Draw picture.","code":"\nx <- c(1L, 2L, 3L)\ntracemem(x)\n\nx[[3]] <- 4\na <- 1:10\nb <- list(a, a)\nc <- list(b, a, 1:10)\nx <- list(1:10)\nx[[2]] <- x"},{"path":"names-values.html","id":"object-size","chapter":"2 Names and values","heading":"2.4 Object size","text":"can find much memory object takes lobstr::obj_size()13:Since elements lists references values, size list might much smaller expect:y 80 bytes14 bigger x. ’s size empty list three elements:Similarly, R uses global string pool character vectors take less memory might expect: repeating string 100 times make take 100 times much memory.References also make challenging think size individual objects. obj_size(x) + obj_size(y) equal obj_size(x, y) shared values. , combined size x y size y:Finally, R 3.5.0 later versions feature might lead surprises: ALTREP, short alternative representation. allows R represent certain types vectors compactly. place likely see : instead storing every single number sequence, R just stores first last number. means every sequence, matter large, size:","code":"\nobj_size(letters)\n#> 1,712 B\nobj_size(ggplot2::diamonds)\n#> 3,456,344 B\nx <- runif(1e6)\nobj_size(x)\n#> 8,000,048 B\n\ny <- list(x, x, x)\nobj_size(y)\n#> 8,000,128 B\nobj_size(list(NULL, NULL, NULL))\n#> 80 B\nbanana <- \"bananas bananas bananas\"\nobj_size(banana)\n#> 136 B\nobj_size(rep(banana, 100))\n#> 928 B\nobj_size(x, y)\n#> 8,000,128 B\nobj_size(1:3)\n#> 680 B\nobj_size(1:1e3)\n#> 680 B\nobj_size(1:1e6)\n#> 680 B\nobj_size(1:1e9)\n#> 680 B"},{"path":"names-values.html","id":"exercises-2","chapter":"2 Names and values","heading":"2.4.1 Exercises","text":"following example, object.size(y) obj_size(y)\nradically different? Consult documentation object.size().\n\ny <- rep(list(runif(1e4)), 100)\n\nobject.size(y)\n#> 8005648 bytes\nobj_size(y)\n#> 80,896 BIn following example, object.size(y) obj_size(y)\nradically different? Consult documentation object.size().Take following list. size somewhat misleading?\n\nfuns <- list(mean, sd, var)\nobj_size(funs)\n#> 17,608 BTake following list. size somewhat misleading?Predict output following code:\n\n<- runif(1e6)\nobj_size()\n\nb <- list(, )\nobj_size(b)\nobj_size(, b)\n\nb[[1]][[1]] <- 10\nobj_size(b)\nobj_size(, b)\n\nb[[2]][[1]] <- 10\nobj_size(b)\nobj_size(, b)Predict output following code:","code":"\ny <- rep(list(runif(1e4)), 100)\n\nobject.size(y)\n#> 8005648 bytes\nobj_size(y)\n#> 80,896 B\nfuns <- list(mean, sd, var)\nobj_size(funs)\n#> 17,608 B\na <- runif(1e6)\nobj_size(a)\n\nb <- list(a, a)\nobj_size(b)\nobj_size(a, b)\n\nb[[1]][[1]] <- 10\nobj_size(b)\nobj_size(a, b)\n\nb[[2]][[1]] <- 10\nobj_size(b)\nobj_size(a, b)"},{"path":"names-values.html","id":"modify-in-place","chapter":"2 Names and values","heading":"2.5 Modify-in-place","text":"’ve seen , modifying R object usually creates copy. two exceptions:Objects single binding get special performance optimisation.Objects single binding get special performance optimisation.Environments, special type object, always modified place.Environments, special type object, always modified place.","code":""},{"path":"names-values.html","id":"single-binding","chapter":"2 Names and values","heading":"2.5.1 Objects with a single binding","text":"object single name bound , R modify place:(Note object IDs : v continues bind object, 0x207.)Two complications make predicting exactly R applies optimisation challenging:comes bindings, R can currently15 count 0, 1,\nmany. means object two bindings, one goes away,\nreference count go back 1: one less many \nstill many. turn, means R make copies sometimes\ndoesn’t need .comes bindings, R can currently15 count 0, 1,\nmany. means object two bindings, one goes away,\nreference count go back 1: one less many \nstill many. turn, means R make copies sometimes\ndoesn’t need .Whenever call vast majority functions, makes reference \nobject. exception specially written “primitive” C functions.\ncan written R-core occur mostly base package.Whenever call vast majority functions, makes reference \nobject. exception specially written “primitive” C functions.\ncan written R-core occur mostly base package.Together, two complications make hard predict whether copy occur. Instead, ’s better determine empirically tracemem().\n\nLet’s explore subtleties case study using loops. loops reputation slow R, often slowness caused every iteration loop creating copy. Consider following code. subtracts median column large data frame:loop surprisingly slow iteration loop copies data frame. can see using tracemem():fact, iteration copies data frame , twice, three times! Two copies made [[.data.frame, copy16 made [[.data.frame regular function increments reference count x.can reduce number copies using list instead data frame. Modifying list uses internal C code, references incremented single copy made:’s hard determine copy made, hard prevent . find resorting exotic tricks avoid copies, may time rewrite function C++, described Chapter 25.","code":"\nv <- c(1, 2, 3)\nv[[3]] <- 4\nx <- data.frame(matrix(runif(5 * 1e4), ncol = 5))\nmedians <- vapply(x, median, numeric(1))\n\nfor (i in seq_along(medians)) {\n  x[[i]] <- x[[i]] - medians[[i]]\n}\ncat(tracemem(x), \"\\n\")\n#> <0x7f80c429e020> \n\nfor (i in 1:5) {\n  x[[i]] <- x[[i]] - medians[[i]]\n}\n#> tracemem[0x7f80c429e020 -> 0x7f80c0c144d8]: \n#> tracemem[0x7f80c0c144d8 -> 0x7f80c0c14540]: [[<-.data.frame [[<- \n#> tracemem[0x7f80c0c14540 -> 0x7f80c0c145a8]: [[<-.data.frame [[<- \n#> tracemem[0x7f80c0c145a8 -> 0x7f80c0c14610]: \n#> tracemem[0x7f80c0c14610 -> 0x7f80c0c14678]: [[<-.data.frame [[<- \n#> tracemem[0x7f80c0c14678 -> 0x7f80c0c146e0]: [[<-.data.frame [[<- \n#> tracemem[0x7f80c0c146e0 -> 0x7f80c0c14748]: \n#> tracemem[0x7f80c0c14748 -> 0x7f80c0c147b0]: [[<-.data.frame [[<- \n#> tracemem[0x7f80c0c147b0 -> 0x7f80c0c14818]: [[<-.data.frame [[<- \n#> tracemem[0x7f80c0c14818 -> 0x7f80c0c14880]: \n#> tracemem[0x7f80c0c14880 -> 0x7f80c0c148e8]: [[<-.data.frame [[<- \n#> tracemem[0x7f80c0c148e8 -> 0x7f80c0c14950]: [[<-.data.frame [[<- \n#> tracemem[0x7f80c0c14950 -> 0x7f80c0c149b8]: \n#> tracemem[0x7f80c0c149b8 -> 0x7f80c0c14a20]: [[<-.data.frame [[<- \n#> tracemem[0x7f80c0c14a20 -> 0x7f80c0c14a88]: [[<-.data.frame [[<- \n\nuntracemem(x)\ny <- as.list(x)\ncat(tracemem(y), \"\\n\")\n#> <0x7f80c5c3de20>\n  \nfor (i in 1:5) {\n  y[[i]] <- y[[i]] - medians[[i]]\n}\n#> tracemem[0x7f80c5c3de20 -> 0x7f80c48de210]: "},{"path":"names-values.html","id":"env-modify","chapter":"2 Names and values","heading":"2.5.2 Environments","text":"\n’ll learn environments Chapter 7, ’s important mention behaviour different objects: environments always modified place. property sometimes described reference semantics modify environment existing bindings environment continue reference.Take environment, bind e1 e2:change binding, environment modified place:basic idea can used create functions “remember” previous state. See Section 10.2.4 details. property also used implement R6 object-oriented programming system, topic Chapter 14.One consequence environments can contain :unique property environments!","code":"\ne1 <- rlang::env(a = 1, b = 2, c = 3)\ne2 <- e1\ne1$c <- 4\ne2$c\n#> [1] 4\ne <- rlang::env()\ne$self <- e\n\nref(e)\n#> o [1:0x8c1a510] <env> \n#> \\-self = [1:0x8c1a510]"},{"path":"names-values.html","id":"exercises-3","chapter":"2 Names and values","heading":"2.5.3 Exercises","text":"Explain following code doesn’t create circular list.\n\nx <- list()\nx[[1]] <- xExplain following code doesn’t create circular list.Wrap two methods subtracting medians two functions, \nuse ‘bench’ package17 carefully compare speeds. \nperformance change number columns increase?Wrap two methods subtracting medians two functions, \nuse ‘bench’ package17 carefully compare speeds. \nperformance change number columns increase?happens attempt use tracemem() environment?happens attempt use tracemem() environment?","code":"\nx <- list()\nx[[1]] <- x"},{"path":"names-values.html","id":"gc","chapter":"2 Names and values","heading":"2.6 Unbinding and the garbage collector","text":"\n\nConsider code:created two objects, time code finishes, neither object bound name. objects get deleted? ’s job garbage collector, GC short. GC frees memory deleting R objects longer used, requesting memory operating system needed.R uses tracing GC. means traces every object ’s reachable global18 environment, objects , turn, reachable objects (.e. references lists environments searched recursively). garbage collector use modify--place reference count described . two ideas closely related, internal data structures optimised different use cases.garbage collector (GC) runs automatically whenever R needs memory create new object. Looking outside, ’s basically impossible predict GC run. fact, shouldn’t even try. want find GC runs, call gcinfo(TRUE) GC print message console every time runs.\ncan force garbage collection calling gc(). despite might read elsewhere, ’s never need call gc() . reasons might want call gc() ask R return memory operating system programs can use , side-effect tells much memory currently used:lobstr::mem_used() wrapper around gc() prints total number bytes used:number won’t agree amount memory reported operating system. three reasons:includes objects created R R interpreter.includes objects created R R interpreter.R operating system lazy: won’t reclaim memory\n’s actually needed. R might holding memory \nOS hasn’t yet asked back.R operating system lazy: won’t reclaim memory\n’s actually needed. R might holding memory \nOS hasn’t yet asked back.R counts memory occupied objects may empty gaps due \ndeleted objects. problem known memory fragmentation.R counts memory occupied objects may empty gaps due \ndeleted objects. problem known memory fragmentation.","code":"\nx <- 1:3\nx <- 2:4\nrm(x)\ngc() \n#>           used (Mb) gc trigger  (Mb) max used  (Mb)\n#> Ncells  920293 49.2    1850265  98.9  1689605  90.3\n#> Vcells 5042147 38.5   15586548 119.0 13817784 105.5\nmem_used()\n#> 91,847,024 B"},{"path":"names-values.html","id":"names-values-answers","chapter":"2 Names and values","heading":"2.7 Quiz answers","text":"must quote non-syntactic names backticks: `: example,\nvariables 1, 2, 3.\n\ndf <- data.frame(runif(3), runif(3))\nnames(df) <- c(1, 2)\n\ndf$`3` <- df$`1` + df$`2`must quote non-syntactic names backticks: `: example,\nvariables 1, 2, 3.occupies 8 MB.\n\nx <- runif(1e6)\ny <- list(x, x, x)\nobj_size(y)\n#> 8,000,128 BIt occupies 8 MB.copied b modified, b[[1]] <- 10.copied b modified, b[[1]] <- 10.","code":"\ndf <- data.frame(runif(3), runif(3))\nnames(df) <- c(1, 2)\n\ndf$`3` <- df$`1` + df$`2`\nx <- runif(1e6)\ny <- list(x, x, x)\nobj_size(y)\n#> 8,000,128 B"},{"path":"vectors-chap.html","id":"vectors-chap","chapter":"3 Vectors","heading":"3 Vectors","text":"","code":""},{"path":"vectors-chap.html","id":"introduction-2","chapter":"3 Vectors","heading":"3.1 Introduction","text":"\nchapter discusses important family data types base R: vectors19. ’ve probably already used many () different types vectors, may thought deeply ’re interrelated. chapter, won’t cover individual vectors types much detail, show types fit together whole. need details, can find R’s documentation.Vectors come two flavours: atomic vectors lists20. differ terms elements’ types: atomic vectors, elements must type; lists, elements can different types. vector, NULL closely related vectors often serves role generic zero length vector. diagram, ’ll expanding throughout chapter, illustrates basic relationships:Every vector can also attributes, can think named list arbitrary metadata. Two attributes particularly important. dimension attribute turns vectors matrices arrays class attribute powers S3 object system. ’ll learn use S3 Chapter 13, ’ll learn important S3 vectors: factors, date times, data frames, tibbles. 2D structures like matrices data frames necessarily come mind think vectors, ’ll also learn R considers vectors.","code":""},{"path":"vectors-chap.html","id":"quiz-1","chapter":"3 Vectors","heading":"Quiz","text":"Take short quiz determine need read chapter. answers quickly come mind, can comfortably skip chapter. can check answers Section 3.8.four common types atomic vectors? two\nrare types?four common types atomic vectors? two\nrare types?attributes? get set ?attributes? get set ?list different atomic vector? matrix different\ndata frame?list different atomic vector? matrix different\ndata frame?Can list matrix? Can data frame column\nmatrix?Can list matrix? Can data frame column\nmatrix?tibbles behave differently data frames?tibbles behave differently data frames?","code":""},{"path":"vectors-chap.html","id":"outline-1","chapter":"3 Vectors","heading":"Outline","text":"Section 3.2 introduces atomic vectors:\nlogical, integer, double, character. R’s simplest data\nstructures.Section 3.2 introduces atomic vectors:\nlogical, integer, double, character. R’s simplest data\nstructures.Section 3.3 takes small detour discuss attributes,\nR’s flexible metadata specification. important attributes \nnames, dimensions, class.Section 3.3 takes small detour discuss attributes,\nR’s flexible metadata specification. important attributes \nnames, dimensions, class.Section 3.4 discusses important vector types \nbuilt combining atomic vectors special attributes. include\nfactors, dates, date-times, durations.Section 3.4 discusses important vector types \nbuilt combining atomic vectors special attributes. include\nfactors, dates, date-times, durations.Section 3.5 dives lists. Lists similar atomic\nvectors, one key difference: element list can \ndata type, including another list. makes suitable representing\nhierarchical data.Section 3.5 dives lists. Lists similar atomic\nvectors, one key difference: element list can \ndata type, including another list. makes suitable representing\nhierarchical data.Section 3.6 teaches data frames tibbles, \nused represent rectangular data. combine behaviour\nlists matrices make structure ideally suited needs\nstatistical data.Section 3.6 teaches data frames tibbles, \nused represent rectangular data. combine behaviour\nlists matrices make structure ideally suited needs\nstatistical data.","code":""},{"path":"vectors-chap.html","id":"atomic-vectors","chapter":"3 Vectors","heading":"3.2 Atomic vectors","text":"\n\n\n\n\n\nfour primary types atomic vectors: logical, integer, double, character (contains strings). Collectively integer double vectors known numeric vectors21. two rare types: complex raw. won’t discuss complex numbers rarely needed statistics, raw vectors special type ’s needed handling binary data.","code":""},{"path":"vectors-chap.html","id":"scalars","chapter":"3 Vectors","heading":"3.2.1 Scalars","text":"\n\n\n\n\nfour primary types special syntax create individual value, AKA scalar22:Logicals can written full (TRUE FALSE), abbreviated\n(T F).Logicals can written full (TRUE FALSE), abbreviated\n(T F).Doubles can specified decimal (0.1234), scientific (1.23e4), \nhexadecimal (0xcafe) form. three special values unique \ndoubles: Inf, -Inf, NaN (number). special values\ndefined floating point standard.Doubles can specified decimal (0.1234), scientific (1.23e4), \nhexadecimal (0xcafe) form. three special values unique \ndoubles: Inf, -Inf, NaN (number). special values\ndefined floating point standard.Integers written similarly doubles must followed \nL23 (1234L, 1e4L, 0xcafeL), can contain\nfractional values.Integers written similarly doubles must followed \nL23 (1234L, 1e4L, 0xcafeL), can contain\nfractional values.Strings surrounded \" (\"hi\") ' ('bye'). Special characters\nescaped \\; see ?Quotes full details.Strings surrounded \" (\"hi\") ' ('bye'). Special characters\nescaped \\; see ?Quotes full details.","code":""},{"path":"vectors-chap.html","id":"atomic-constructing","chapter":"3 Vectors","heading":"3.2.2 Making longer vectors with c()","text":"create longer vectors shorter ones, use c(), short combine:inputs atomic vectors, c() always creates another atomic vector; .e. flattens:diagrams, ’ll depict vectors connected rectangles, code drawn follows:can determine type vector typeof()24 length length().","code":"\nlgl_var <- c(TRUE, FALSE)\nint_var <- c(1L, 6L, 10L)\ndbl_var <- c(1, 2.5, 4.5)\nchr_var <- c(\"these are\", \"some strings\")\nc(c(1, 2), c(3, 4))\n#> [1] 1 2 3 4\ntypeof(lgl_var)\n#> [1] \"logical\"\ntypeof(int_var)\n#> [1] \"integer\"\ntypeof(dbl_var)\n#> [1] \"double\"\ntypeof(chr_var)\n#> [1] \"character\""},{"path":"vectors-chap.html","id":"missing-values","chapter":"3 Vectors","heading":"3.2.3 Missing values","text":"R represents missing, unknown values, special sentinel value: NA (short applicable). Missing values tend infectious: computations involving missing value return another missing value.exceptions rule. occur identity holds possible inputs:Propagation missingness leads common mistake determining values vector missing:result correct (little surprising) ’s reason believe one missing value value another. Instead, use .na() test presence missingness:NB: Technically four missing values, one atomic types: NA (logical), NA_integer_ (integer), NA_real_ (double), NA_character_ (character). distinction usually unimportant NA automatically coerced correct type needed.","code":"\nNA > 5\n#> [1] NA\n10 * NA\n#> [1] NA\n!NA\n#> [1] NA\nNA ^ 0\n#> [1] 1\nNA | TRUE\n#> [1] TRUE\nNA & FALSE\n#> [1] FALSE\nx <- c(NA, 5, NA, 10)\nx == NA\n#> [1] NA NA NA NA\nis.na(x)\n#> [1]  TRUE FALSE  TRUE FALSE"},{"path":"vectors-chap.html","id":"testing-and-coercion","chapter":"3 Vectors","heading":"3.2.4 Testing and coercion","text":"\n\n\nGenerally, can test vector given type .*() function, functions need used care. .logical(), .integer(), .double(), .character() might expect: test vector character, double, integer, logical. Avoid .vector(), .atomic(), .numeric(): don’t test vector, atomic vector, numeric vector; ’ll need carefully read documentation figure actually .atomic vectors, type property entire vector: elements must type. attempt combine different types coerced fixed order: character → double → integer → logical. example, combining character integer yields character:Coercion often happens automatically. mathematical functions (+, log, abs, etc.) coerce numeric. coercion particularly useful logical vectors TRUE becomes 1 FALSE becomes 0.Generally, can deliberately coerce using .*() function, like .logical(), .integer(), .double(), .character(). Failed coercion strings generates warning missing value:","code":"\nstr(c(\"a\", 1))\n#>  chr [1:2] \"a\" \"1\"\nx <- c(FALSE, FALSE, TRUE)\nas.numeric(x)\n#> [1] 0 0 1\n\n# Total number of TRUEs\nsum(x)\n#> [1] 1\n\n# Proportion that are TRUE\nmean(x)\n#> [1] 0.333\nas.integer(c(\"1\", \"1.5\", \"a\"))\n#> Warning: NAs introducidos por coerción\n#> [1]  1  1 NA"},{"path":"vectors-chap.html","id":"exercises-4","chapter":"3 Vectors","heading":"3.2.5 Exercises","text":"create raw complex scalars? (See ?raw \n?complex.)create raw complex scalars? (See ?raw \n?complex.)Test knowledge vector coercion rules predicting output \nfollowing uses c():\n\nc(1, FALSE)\nc(\"\", 1)\nc(TRUE, 1L)Test knowledge vector coercion rules predicting output \nfollowing uses c():1 == \"1\" true? -1 < FALSE true? \"one\" < 2 false?1 == \"1\" true? -1 < FALSE true? \"one\" < 2 false?default missing value, NA, logical vector? ’s special\nlogical vectors? (Hint: think c(FALSE, NA_character_).)default missing value, NA, logical vector? ’s special\nlogical vectors? (Hint: think c(FALSE, NA_character_).)Precisely .atomic(), .numeric(), .vector() test ?Precisely .atomic(), .numeric(), .vector() test ?","code":"\nc(1, FALSE)\nc(\"a\", 1)\nc(TRUE, 1L)"},{"path":"vectors-chap.html","id":"attributes","chapter":"3 Vectors","heading":"3.3 Attributes","text":"might noticed set atomic vectors include number important data structures like matrices, arrays, factors, date-times. types built top atomic vectors adding attributes. section, ’ll learn basics attributes, dim attribute makes matrices arrays. next section ’ll learn class attribute used create S3 vectors, including factors, dates, date-times.","code":""},{"path":"vectors-chap.html","id":"getting-and-setting","chapter":"3 Vectors","heading":"3.3.1 Getting and setting","text":"\ncan think attributes name-value pairs25 attach metadata object. Individual attributes can retrieved modified attr(), retrieved en masse attributes(), set en masse structure().Attributes generally thought ephemeral. example, attributes lost operations:two attributes routinely preserved:names, character vector giving element name.dim, short dimensions, integer vector, used turn vectors\nmatrices arrays.preserve attributes, ’ll need create S3 class, topic Chapter 13.","code":"\na <- 1:3\nattr(a, \"x\") <- \"abcdef\"\nattr(a, \"x\")\n#> [1] \"abcdef\"\n\nattr(a, \"y\") <- 4:6\nstr(attributes(a))\n#> List of 2\n#>  $ x: chr \"abcdef\"\n#>  $ y: int [1:3] 4 5 6\n\n# Or equivalently\na <- structure(\n  1:3, \n  x = \"abcdef\",\n  y = 4:6\n)\nstr(attributes(a))\n#> List of 2\n#>  $ x: chr \"abcdef\"\n#>  $ y: int [1:3] 4 5 6\nattributes(a[1])\n#> NULL\nattributes(sum(a))\n#> NULL"},{"path":"vectors-chap.html","id":"attr-names","chapter":"3 Vectors","heading":"3.3.2 Names","text":"\n\ncan name vector three ways:Avoid using attr(x, \"names\") requires typing less readable names(x). can remove names vector using x <- unname(x) names(x) <- NULL.technically correct, drawing named vector x, draw like :However, names special important, unless ’m trying specifically draw attention attributes data structure, ’ll use label vector directly:useful character subsetting (e.g. Section 4.5.1) names unique, non-missing, enforced R. Depending names set, missing names may either \"\" NA_character_. names missing, names() return NULL.","code":"\n# When creating it: \nx <- c(a = 1, b = 2, c = 3)\n\n# By assigning a character vector to names()\nx <- 1:3\nnames(x) <- c(\"a\", \"b\", \"c\")\n\n# Inline, with setNames():\nx <- setNames(1:3, c(\"a\", \"b\", \"c\"))"},{"path":"vectors-chap.html","id":"attr-dims","chapter":"3 Vectors","heading":"3.3.3 Dimensions","text":"\n\nAdding dim attribute vector allows behave like 2-dimensional matrix multi-dimensional array. Matrices arrays primarily mathematical statistical tools, programming tools, ’ll used infrequently covered briefly book. important feature multidimensional subsetting, covered Section 4.2.3.can create matrices arrays matrix() array(), using assignment form dim():Many functions working vectors generalisations matrices arrays:vector without dim attribute set often thought 1-dimensional, actually NULL dimensions. also can matrices single row single column, arrays single dimension. may print similarly, behave differently. differences aren’t important, ’s useful know exist case get strange output function (tapply() frequent offender). always, use str() reveal differences.","code":"\n# Two scalar arguments specify row and column sizes\nx <- matrix(1:6, nrow = 2, ncol = 3)\nx\n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\n\n# One vector argument to describe all dimensions\ny <- array(1:12, c(2, 3, 2))\ny\n#> , , 1\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\n#> \n#> , , 2\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    7    9   11\n#> [2,]    8   10   12\n\n# You can also modify an object in place by setting dim()\nz <- 1:6\ndim(z) <- c(3, 2)\nz\n#>      [,1] [,2]\n#> [1,]    1    4\n#> [2,]    2    5\n#> [3,]    3    6\nstr(1:3)                   # 1d vector\n#>  int [1:3] 1 2 3\nstr(matrix(1:3, ncol = 1)) # column vector\n#>  int [1:3, 1] 1 2 3\nstr(matrix(1:3, nrow = 1)) # row vector\n#>  int [1, 1:3] 1 2 3\nstr(array(1:3, 3))         # \"array\" vector\n#>  int [1:3(1d)] 1 2 3"},{"path":"vectors-chap.html","id":"exercises-5","chapter":"3 Vectors","heading":"3.3.4 Exercises","text":"setNames() implemented? unname() implemented?\nRead source code.setNames() implemented? unname() implemented?\nRead source code.dim() return applied 1-dimensional vector?\nmight use NROW() NCOL()?dim() return applied 1-dimensional vector?\nmight use NROW() NCOL()?describe following three objects? makes \ndifferent 1:5?\n\nx1 <- array(1:5, c(1, 1, 5))\nx2 <- array(1:5, c(1, 5, 1))\nx3 <- array(1:5, c(5, 1, 1))describe following three objects? makes \ndifferent 1:5?early draft used code illustrate structure():\n\nstructure(1:5, comment = \"attribute\")\n#> [1] 1 2 3 4 5\nprint object don’t see comment attribute.\n? attribute missing, something else special \n? (Hint: try using help.)early draft used code illustrate structure():print object don’t see comment attribute.\n? attribute missing, something else special \n? (Hint: try using help.)","code":"\nx1 <- array(1:5, c(1, 1, 5))\nx2 <- array(1:5, c(1, 5, 1))\nx3 <- array(1:5, c(5, 1, 1))\nstructure(1:5, comment = \"my attribute\")\n#> [1] 1 2 3 4 5"},{"path":"vectors-chap.html","id":"s3-atomic-vectors","chapter":"3 Vectors","heading":"3.4 S3 atomic vectors","text":"\nOne important vector attributes class, underlies S3 object system. class attribute turns object S3 object, means behave differently regular vector passed generic function. Every S3 object built top base type, often stores additional information attributes. ’ll learn details S3 object system, create S3 classes, Chapter 13.section, ’ll discuss four important S3 vectors used base R:Categorical data, values come fixed set levels recorded \nfactor vectors.Categorical data, values come fixed set levels recorded \nfactor vectors.Dates (day resolution), recorded Date vectors.Dates (day resolution), recorded Date vectors.Date-times (second sub-second resolution), stored \nPOSIXct vectors.Date-times (second sub-second resolution), stored \nPOSIXct vectors.Durations, stored difftime vectors.Durations, stored difftime vectors.","code":""},{"path":"vectors-chap.html","id":"factors","chapter":"3 Vectors","heading":"3.4.1 Factors","text":"factor vector can contain predefined values. used store categorical data. Factors built top integer vector two attributes: class, “factor,” makes behave differently regular integer vectors, levels, defines set allowed values.Factors useful know set possible values ’re present given dataset. contrast character vector, tabulate factor ’ll get counts categories, even unobserved ones:Ordered factors minor variation factors. general, behave like regular factors, order levels meaningful (low, medium, high) (property automatically leveraged modelling visualisation functions).base R26 tend encounter factors frequently many base R functions (like read.csv() data.frame()) automatically convert character vectors factors. suboptimal ’s way functions know set possible levels correct order: levels property theory experimental design, data. Instead, use argument stringsAsFactors = FALSE suppress behaviour, manually convert character vectors factors using knowledge “theoretical” data. learn historical context behaviour, recommend stringsAsFactors: unauthorized\nbiography Roger Peng, stringsAsFactors =\n<sigh> Thomas Lumley.factors look like (often behave like) character vectors, built top integers. careful treating like strings. string methods (like gsub() grepl()) automatically coerce factors strings, others (like nchar()) throw error, still others (like c()) use underlying integer values. reason, ’s usually best explicitly convert factors character vectors need string-like behaviour.","code":"\nx <- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n#> [1] a b b a\n#> Levels: a b\n\ntypeof(x)\n#> [1] \"integer\"\nattributes(x)\n#> $levels\n#> [1] \"a\" \"b\"\n#> \n#> $class\n#> [1] \"factor\"\nsex_char <- c(\"m\", \"m\", \"m\")\nsex_factor <- factor(sex_char, levels = c(\"m\", \"f\"))\n\ntable(sex_char)\n#> sex_char\n#> m \n#> 3\ntable(sex_factor)\n#> sex_factor\n#> m f \n#> 3 0\ngrade <- ordered(c(\"b\", \"b\", \"a\", \"c\"), levels = c(\"c\", \"b\", \"a\"))\ngrade\n#> [1] b b a c\n#> Levels: c < b < a"},{"path":"vectors-chap.html","id":"dates","chapter":"3 Vectors","heading":"3.4.2 Dates","text":"Date vectors built top double vectors. class “Date” attributes:value double (can seen stripping class), represents number days since 1970-01-0127:","code":"\ntoday <- Sys.Date()\n\ntypeof(today)\n#> [1] \"double\"\nattributes(today)\n#> $class\n#> [1] \"Date\"\ndate <- as.Date(\"1970-02-01\")\nunclass(date)\n#> [1] 31"},{"path":"vectors-chap.html","id":"date-times","chapter":"3 Vectors","heading":"3.4.3 Date-times","text":"\nBase R28 provides two ways storing date-time information, POSIXct, POSIXlt. admittedly odd names: “POSIX” short Portable Operating System Interface, family cross-platform standards. “ct” stands calendar time (time_t type C), “lt” local time (struct tm type C). ’ll focus POSIXct, ’s simplest, built top atomic vector, appropriate use data frames. POSIXct vectors built top double vectors, value represents number seconds since 1970-01-01.tzone attribute controls date-time formatted; control instant time represented vector. Note time printed midnight.","code":"\nnow_ct <- as.POSIXct(\"2018-08-01 22:00\", tz = \"UTC\")\nnow_ct\n#> [1] \"2018-08-01 22:00:00 UTC\"\n\ntypeof(now_ct)\n#> [1] \"double\"\nattributes(now_ct)\n#> $class\n#> [1] \"POSIXct\" \"POSIXt\" \n#> \n#> $tzone\n#> [1] \"UTC\"\nstructure(now_ct, tzone = \"Asia/Tokyo\")\n#> [1] \"2018-08-02 07:00:00 JST\"\nstructure(now_ct, tzone = \"America/New_York\")\n#> [1] \"2018-08-01 18:00:00 EDT\"\nstructure(now_ct, tzone = \"Australia/Lord_Howe\")\n#> [1] \"2018-08-02 08:30:00 +1030\"\nstructure(now_ct, tzone = \"Europe/Paris\")\n#> [1] \"2018-08-02 CEST\""},{"path":"vectors-chap.html","id":"durations","chapter":"3 Vectors","heading":"3.4.4 Durations","text":"\nDurations, represent amount time pairs dates date-times, stored difftimes. Difftimes built top doubles, units attribute determines integer interpreted:","code":"\none_week_1 <- as.difftime(1, units = \"weeks\")\none_week_1\n#> Time difference of 1 weeks\n\ntypeof(one_week_1)\n#> [1] \"double\"\nattributes(one_week_1)\n#> $class\n#> [1] \"difftime\"\n#> \n#> $units\n#> [1] \"weeks\"\n\none_week_2 <- as.difftime(7, units = \"days\")\none_week_2\n#> Time difference of 7 days\n\ntypeof(one_week_2)\n#> [1] \"double\"\nattributes(one_week_2)\n#> $class\n#> [1] \"difftime\"\n#> \n#> $units\n#> [1] \"days\""},{"path":"vectors-chap.html","id":"exercises-6","chapter":"3 Vectors","heading":"3.4.5 Exercises","text":"sort object table() return? type? \nattributes ? dimensionality change \ntabulate variables?sort object table() return? type? \nattributes ? dimensionality change \ntabulate variables?happens factor modify levels?\n\nf1 <- factor(letters)\nlevels(f1) <- rev(levels(f1))happens factor modify levels?code ? f2 f3 differ f1?\n\nf2 <- rev(factor(letters))\n\nf3 <- factor(letters, levels = rev(letters))code ? f2 f3 differ f1?","code":"\nf1 <- factor(letters)\nlevels(f1) <- rev(levels(f1))\nf2 <- rev(factor(letters))\n\nf3 <- factor(letters, levels = rev(letters))"},{"path":"vectors-chap.html","id":"lists","chapter":"3 Vectors","heading":"3.5 Lists","text":"\n\nLists step complexity atomic vectors: element can type, just vectors. Technically speaking, element list actually type , saw Section 2.3.3, element really reference another object, can type.","code":""},{"path":"vectors-chap.html","id":"list-creating","chapter":"3 Vectors","heading":"3.5.1 Creating","text":"construct lists list():elements list references, creating list involve copying components list. reason, total size list might smaller might expect.Lists can contain complex objects ’s possible pick single visual style works every list. Generally ’ll draw lists like vectors, using colour remind hierarchy.Lists sometimes called recursive vectors list can contain lists. makes fundamentally different atomic vectors.c() combine several lists one. given combination atomic vectors lists, c() coerce vectors lists combining . Compare results list() c():","code":"\nl1 <- list(\n  1:3, \n  \"a\", \n  c(TRUE, FALSE, TRUE), \n  c(2.3, 5.9)\n)\n\ntypeof(l1)\n#> [1] \"list\"\n\nstr(l1)\n#> List of 4\n#>  $ : int [1:3] 1 2 3\n#>  $ : chr \"a\"\n#>  $ : logi [1:3] TRUE FALSE TRUE\n#>  $ : num [1:2] 2.3 5.9\nlobstr::obj_size(mtcars)\n#> 7,208 B\n\nl2 <- list(mtcars, mtcars, mtcars, mtcars)\nlobstr::obj_size(l2)\n#> 7,288 B\nl3 <- list(list(list(1)))\nstr(l3)\n#> List of 1\n#>  $ :List of 1\n#>   ..$ :List of 1\n#>   .. ..$ : num 1\nl4 <- list(list(1, 2), c(3, 4))\nl5 <- c(list(1, 2), c(3, 4))\nstr(l4)\n#> List of 2\n#>  $ :List of 2\n#>   ..$ : num 1\n#>   ..$ : num 2\n#>  $ : num [1:2] 3 4\nstr(l5)\n#> List of 4\n#>  $ : num 1\n#>  $ : num 2\n#>  $ : num 3\n#>  $ : num 4"},{"path":"vectors-chap.html","id":"list-types","chapter":"3 Vectors","heading":"3.5.2 Testing and coercion","text":"typeof() list list. can test list .list(), coerce list .list().can turn list atomic vector unlist(). rules resulting type complex, well documented, always equivalent ’d get c().","code":"\nlist(1:3)\n#> [[1]]\n#> [1] 1 2 3\nas.list(1:3)\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> [1] 2\n#> \n#> [[3]]\n#> [1] 3"},{"path":"vectors-chap.html","id":"list-array","chapter":"3 Vectors","heading":"3.5.3 Matrices and arrays","text":"\natomic vectors, dimension attribute commonly used create matrices. lists, dimension attribute can used create list-matrices list-arrays:data structures relatively esoteric can useful want arrange objects grid-like structure. example, ’re running models spatio-temporal grid, might intuitive store models 3D array matches grid structure.","code":"\nl <- list(1:3, \"a\", TRUE, 1.0)\ndim(l) <- c(2, 2)\nl\n#>      [,1]      [,2]\n#> [1,] integer,3 TRUE\n#> [2,] \"a\"       1\n\nl[[1, 1]]\n#> [1] 1 2 3"},{"path":"vectors-chap.html","id":"exercises-7","chapter":"3 Vectors","heading":"3.5.4 Exercises","text":"List ways list differs atomic vector.List ways list differs atomic vector.need use unlist() convert list \natomic vector? doesn’t .vector() work?need use unlist() convert list \natomic vector? doesn’t .vector() work?Compare contrast c() unlist() combining \ndate date-time single vector.Compare contrast c() unlist() combining \ndate date-time single vector.","code":""},{"path":"vectors-chap.html","id":"tibble","chapter":"3 Vectors","heading":"3.6 Data frames and tibbles","text":"\n\ntwo important S3 vectors built top lists data frames tibbles.data analysis R, ’re going using data frames. data frame named list vectors attributes (column) names, row.names29, class, “data.frame”:contrast regular list, data frame additional constraint: length vectors must . gives data frames rectangular structure explains share properties matrices lists:data frame rownames()30 colnames(). names()\ndata frame column names.data frame rownames()30 colnames(). names()\ndata frame column names.data frame nrow() rows ncol() columns. length() \ndata frame gives number columns.data frame nrow() rows ncol() columns. length() \ndata frame gives number columns.Data frames one biggest important ideas R, one things make R different programming languages. However, 20 years since creation, ways people use R changed, design decisions made sense time data frames created now cause frustration.frustration lead creation tibble,31 modern reimagining data frame. Tibbles designed (much possible) drop-replacements data frames fix frustrations. concise, fun, way summarise main differences tibbles lazy surly: less complain . ’ll see means work section.Tibbles provided tibble package share structure data frames. difference class vector longer, includes tbl_df. allows tibbles behave differently key ways ’ll discuss .","code":"\ndf1 <- data.frame(x = 1:3, y = letters[1:3])\ntypeof(df1)\n#> [1] \"list\"\n\nattributes(df1)\n#> $names\n#> [1] \"x\" \"y\"\n#> \n#> $class\n#> [1] \"data.frame\"\n#> \n#> $row.names\n#> [1] 1 2 3\nlibrary(tibble)\n#> Warning: package 'tibble' was built under R version 4.1.2\n\ndf2 <- tibble(x = 1:3, y = letters[1:3])\ntypeof(df2)\n#> [1] \"list\"\n\nattributes(df2)\n#> $class\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n#> \n#> $row.names\n#> [1] 1 2 3\n#> \n#> $names\n#> [1] \"x\" \"y\""},{"path":"vectors-chap.html","id":"df-create","chapter":"3 Vectors","heading":"3.6.1 Creating","text":"create data frame supplying name-vector pairs data.frame():Beware default conversion strings factors. Use stringsAsFactors = FALSE suppress keep character vectors character vectors:Creating tibble similar creating data frame. difference two tibbles never coerce input (one feature makes lazy):Additionally, data frames automatically transform non-syntactic names (unless check.names = FALSE), tibbles (although print non-syntactic names surrounded `).every element data frame (tibble) must length, data.frame() tibble() recycle shorter inputs. However, data frames automatically recycle columns integer multiple longest column, tibbles recycle vectors length one.one final difference: tibble() allows refer variables created construction:(Inputs evaluated left--right.)drawing data frames tibbles, rather focussing implementation details, .e. attributes:’ll draw way named list, arrange emphasise columnar structure.","code":"\ndf <- data.frame(\n  x = 1:3, \n  y = c(\"a\", \"b\", \"c\")\n)\nstr(df)\n#> 'data.frame':    3 obs. of  2 variables:\n#>  $ x: int  1 2 3\n#>  $ y: chr  \"a\" \"b\" \"c\"\ndf1 <- data.frame(\n  x = 1:3,\n  y = c(\"a\", \"b\", \"c\"),\n  stringsAsFactors = FALSE\n)\nstr(df1)\n#> 'data.frame':    3 obs. of  2 variables:\n#>  $ x: int  1 2 3\n#>  $ y: chr  \"a\" \"b\" \"c\"\ndf2 <- tibble(\n  x = 1:3, \n  y = c(\"a\", \"b\", \"c\")\n)\nstr(df2)\n#> tibble [3 x 2] (S3: tbl_df/tbl/data.frame)\n#>  $ x: int [1:3] 1 2 3\n#>  $ y: chr [1:3] \"a\" \"b\" \"c\"\nnames(data.frame(`1` = 1))\n#> [1] \"X1\"\n\nnames(tibble(`1` = 1))\n#> [1] \"1\"\ndata.frame(x = 1:4, y = 1:2)\n#>   x y\n#> 1 1 1\n#> 2 2 2\n#> 3 3 1\n#> 4 4 2\ndata.frame(x = 1:4, y = 1:3)\n#> Error in data.frame(x = 1:4, y = 1:3): arguments imply differing number of rows: 4, 3\n\ntibble(x = 1:4, y = 1)\n#> # A tibble: 4 x 2\n#>       x     y\n#>   <int> <dbl>\n#> 1     1     1\n#> 2     2     1\n#> 3     3     1\n#> 4     4     1\ntibble(x = 1:4, y = 1:2)\n#> Error: Tibble columns must have compatible sizes.\n#> * Size 4: Existing data.\n#> * Size 2: Column `y`.\n#> i Only values of size one are recycled.\ntibble(\n  x = 1:3,\n  y = x * 2\n)\n#> # A tibble: 3 x 2\n#>       x     y\n#>   <int> <dbl>\n#> 1     1     2\n#> 2     2     4\n#> 3     3     6"},{"path":"vectors-chap.html","id":"rownames","chapter":"3 Vectors","heading":"3.6.2 Row names","text":"Data frames allow label row name, character vector containing unique values:can get set row names rownames(), can use subset rows:Row names arise naturally think data frames 2D structures like matrices: columns (variables) names rows (observations) . matrices numeric, place store character labels important. analogy matrices misleading matrices possess important property data frames : transposable. matrices rows columns interchangeable, transposing matrix gives another matrix (transposing gives original matrix). data frames, however, rows columns interchangeable: transpose data frame data frame.three reasons row names undesirable:Metadata data, storing different way rest \ndata fundamentally bad idea. also means need learn\nnew set tools work row names; can’t use already\nknow manipulating columns.Metadata data, storing different way rest \ndata fundamentally bad idea. also means need learn\nnew set tools work row names; can’t use already\nknow manipulating columns.Row names poor abstraction labelling rows work\nrow can identified single string. fails many cases,\nexample want identify row non-character vector\n(e.g. time point), multiple vectors (e.g. position, encoded \nlatitude longitude).Row names poor abstraction labelling rows work\nrow can identified single string. fails many cases,\nexample want identify row non-character vector\n(e.g. time point), multiple vectors (e.g. position, encoded \nlatitude longitude).Row names must unique, duplication rows (e.g. \nbootstrapping) create new row names. want match rows \ntransformation, ’ll need perform complicated\nstring surgery.\n\ndf3[c(1, 1, 1), ]\n#>       age  hair\n#> Bob    35 blond\n#> Bob.1  35 blond\n#> Bob.2  35 blondRow names must unique, duplication rows (e.g. \nbootstrapping) create new row names. want match rows \ntransformation, ’ll need perform complicated\nstring surgery.reasons, tibbles support row names. Instead tibble package provides tools easily convert row names regular column either rownames_to_column(), rownames argument as_tibble():","code":"\ndf3 <- data.frame(\n  age = c(35, 27, 18),\n  hair = c(\"blond\", \"brown\", \"black\"),\n  row.names = c(\"Bob\", \"Susan\", \"Sam\")\n)\ndf3\n#>       age  hair\n#> Bob    35 blond\n#> Susan  27 brown\n#> Sam    18 black\nrownames(df3)\n#> [1] \"Bob\"   \"Susan\" \"Sam\"\n\ndf3[\"Bob\", ]\n#>     age  hair\n#> Bob  35 blond\ndf3[c(1, 1, 1), ]\n#>       age  hair\n#> Bob    35 blond\n#> Bob.1  35 blond\n#> Bob.2  35 blond\nas_tibble(df3, rownames = \"name\")\n#> # A tibble: 3 x 3\n#>   name    age hair \n#>   <chr> <dbl> <chr>\n#> 1 Bob      35 blond\n#> 2 Susan    27 brown\n#> 3 Sam      18 black"},{"path":"vectors-chap.html","id":"printing","chapter":"3 Vectors","heading":"3.6.3 Printing","text":"One obvious differences tibbles data frames print. assume ’re already familiar data frames printed, ’ll highlight biggest differences using example dataset included dplyr package:Tibbles show first 10 rows columns fit \nscreen. Additional columns shown bottom.Tibbles show first 10 rows columns fit \nscreen. Additional columns shown bottom.column labelled type, abbreviated three four letters.column labelled type, abbreviated three four letters.Wide columns truncated avoid single long string occupy \nentire row. (still work progress: ’s tricky tradeoff \nshowing many columns possible showing columns entirety.)Wide columns truncated avoid single long string occupy \nentire row. (still work progress: ’s tricky tradeoff \nshowing many columns possible showing columns entirety.)used console environments support , colour used judiciously\nhighlight important information, de-emphasise supplemental details.used console environments support , colour used judiciously\nhighlight important information, de-emphasise supplemental details.","code":"\ndplyr::starwars\n#> # A tibble: 87 x 14\n#>    name    height  mass hair_color  skin_color eye_color birth_year sex   gender\n#>    <chr>    <int> <dbl> <chr>       <chr>      <chr>          <dbl> <chr> <chr> \n#>  1 Luke S~    172    77 blond       fair       blue            19   male  mascu~\n#>  2 C-3PO      167    75 <NA>        gold       yellow         112   none  mascu~\n#>  3 R2-D2       96    32 <NA>        white, bl~ red             33   none  mascu~\n#>  4 Darth ~    202   136 none        white      yellow          41.9 male  mascu~\n#>  5 Leia O~    150    49 brown       light      brown           19   fema~ femin~\n#>  6 Owen L~    178   120 brown, grey light      blue            52   male  mascu~\n#>  7 Beru W~    165    75 brown       light      blue            47   fema~ femin~\n#>  8 R5-D4       97    32 <NA>        white, red red             NA   none  mascu~\n#>  9 Biggs ~    183    84 black       light      brown           24   male  mascu~\n#> 10 Obi-Wa~    182    77 auburn, wh~ fair       blue-gray       57   male  mascu~\n#> # ... with 77 more rows, and 5 more variables: homeworld <chr>, species <chr>,\n#> #   films <list>, vehicles <list>, starships <list>"},{"path":"vectors-chap.html","id":"safe-subsetting","chapter":"3 Vectors","heading":"3.6.4 Subsetting","text":"learn Chapter 4, can subset data frame tibble like 1D structure (behaves like list), 2D structure (behaves like matrix).opinion, data frames two undesirable subsetting behaviours:subset columns df[, vars], get vector vars\nselects one variable, otherwise ’ll get data frame. frequent\nsource bugs using [ function, unless always remember \nuse df[, vars, drop = FALSE].subset columns df[, vars], get vector vars\nselects one variable, otherwise ’ll get data frame. frequent\nsource bugs using [ function, unless always remember \nuse df[, vars, drop = FALSE].attempt extract single column df$x \ncolumn x, data frame instead select variable starts \nx. variable starts x, df$x return NULL. makes\neasy select wrong variable select variable doesn’t\nexist.attempt extract single column df$x \ncolumn x, data frame instead select variable starts \nx. variable starts x, df$x return NULL. makes\neasy select wrong variable select variable doesn’t\nexist.Tibbles tweak behaviours [ always returns tibble, $ doesn’t partial matching warns can’t find variable (makes tibbles surly).tibble’s insistence returning data frame [ can cause problems legacy code, often uses df[, \"col\"] extract single column. want single column, recommend using df[[\"col\"]]. clearly communicates intent, works data frames tibbles.","code":"\ndf1 <- data.frame(xyz = \"a\")\ndf2 <- tibble(xyz = \"a\")\n\nstr(df1$x)\n#>  chr \"a\"\nstr(df2$x)\n#> Warning: Unknown or uninitialised column: `x`.\n#>  NULL"},{"path":"vectors-chap.html","id":"df-test-coerce","chapter":"3 Vectors","heading":"3.6.5 Testing and coercing","text":"check object data frame tibble, use .data.frame():Typically, matter tibble data frame, need certain, use is_tibble():can coerce object data frame .data.frame() tibble as_tibble().","code":"\nis.data.frame(df1)\n#> [1] TRUE\nis.data.frame(df2)\n#> [1] TRUE\nis_tibble(df1)\n#> [1] FALSE\nis_tibble(df2)\n#> [1] TRUE"},{"path":"vectors-chap.html","id":"list-columns","chapter":"3 Vectors","heading":"3.6.6 List columns","text":"\nSince data frame list vectors, possible data frame column list. useful list can contain object: means can put object data frame. allows keep related objects together row, matter complex individual objects . can see application “Many Models” chapter R Data Science, http://r4ds..co.nz/many-models.html.List-columns allowed data frames little extra work either adding list-column creation wrapping list ()32.List columns easier use tibbles can directly included inside tibble() printed tidily:","code":"\ndf <- data.frame(x = 1:3)\ndf$y <- list(1:2, 1:3, 1:4)\n\ndata.frame(\n  x = 1:3, \n  y = I(list(1:2, 1:3, 1:4))\n)\n#>   x          y\n#> 1 1       1, 2\n#> 2 2    1, 2, 3\n#> 3 3 1, 2, 3, 4\ntibble(\n  x = 1:3, \n  y = list(1:2, 1:3, 1:4)\n)\n#> # A tibble: 3 x 2\n#>       x y        \n#>   <int> <list>   \n#> 1     1 <int [2]>\n#> 2     2 <int [3]>\n#> 3     3 <int [4]>"},{"path":"vectors-chap.html","id":"matrix-and-data-frame-columns","chapter":"3 Vectors","heading":"3.6.7 Matrix and data frame columns","text":"long number rows matches data frame, ’s also possible matrix array column data frame. (requires slight extension definition data frame: ’s length() column must equal, NROW().) list-columns, must either add creation, wrap ().Matrix data frame columns require little caution. Many functions work data frames assume columns vectors. Also, printed display can confusing.","code":"\ndfm <- data.frame(\n  x = 1:3 * 10\n)\ndfm$y <- matrix(1:9, nrow = 3)\ndfm$z <- data.frame(a = 3:1, b = letters[1:3], stringsAsFactors = FALSE)\n\nstr(dfm)\n#> 'data.frame':    3 obs. of  3 variables:\n#>  $ x: num  10 20 30\n#>  $ y: int [1:3, 1:3] 1 2 3 4 5 6 7 8 9\n#>  $ z:'data.frame':   3 obs. of  2 variables:\n#>   ..$ a: int  3 2 1\n#>   ..$ b: chr  \"a\" \"b\" \"c\"\ndfm[1, ]\n#>    x y.1 y.2 y.3 z.a z.b\n#> 1 10   1   4   7   3   a"},{"path":"vectors-chap.html","id":"exercises-8","chapter":"3 Vectors","heading":"3.6.8 Exercises","text":"Can data frame zero rows? zero columns?Can data frame zero rows? zero columns?happens attempt set rownames unique?happens attempt set rownames unique?df data frame, can say t(df), t(t(df))?\nPerform experiments, making sure try different column types.df data frame, can say t(df), t(t(df))?\nPerform experiments, making sure try different column types..matrix() applied data frame \ncolumns different types? differ data.matrix()?.matrix() applied data frame \ncolumns different types? differ data.matrix()?","code":""},{"path":"vectors-chap.html","id":"null","chapter":"3 Vectors","heading":"3.7 NULL","text":"finish chapter, want talk one final important data structure ’s closely related vectors: NULL. NULL special unique type, always length zero, can’t attributes:can test NULLs .null():two common uses NULL:represent empty vector (vector length zero) arbitrary type.\nexample, use c() don’t include arguments, get\nNULL, concatenating NULL vector leave unchanged:\n\nc()\n#> NULLTo represent empty vector (vector length zero) arbitrary type.\nexample, use c() don’t include arguments, get\nNULL, concatenating NULL vector leave unchanged:represent absent vector. example, NULL often used \ndefault function argument, argument optional default\nvalue requires computation (see Section 6.5.3 \n). Contrast NA used indicate \nelement vector absent.represent absent vector. example, NULL often used \ndefault function argument, argument optional default\nvalue requires computation (see Section 6.5.3 \n). Contrast NA used indicate \nelement vector absent.’re familiar SQL, ’ll know relational NULL might expect R’s. However, database NULL actually equivalent R’s NA.","code":"\ntypeof(NULL)\n#> [1] \"NULL\"\n\nlength(NULL)\n#> [1] 0\n\nx <- NULL\nattr(x, \"y\") <- 1\n#> Error in attr(x, \"y\") <- 1: se intenta especificar un atributo en un NULL\nis.null(NULL)\n#> [1] TRUE\nc()\n#> NULL"},{"path":"vectors-chap.html","id":"data-structure-answers","chapter":"3 Vectors","heading":"3.8 Quiz answers","text":"four common types atomic vector logical, integer, double\ncharacter. two rarer types complex raw.four common types atomic vector logical, integer, double\ncharacter. two rarer types complex raw.Attributes allow associate arbitrary additional metadata \nobject. can get set individual attributes attr(x, \"y\")\nattr(x, \"y\") <- value; can get set attributes \nattributes().Attributes allow associate arbitrary additional metadata \nobject. can get set individual attributes attr(x, \"y\")\nattr(x, \"y\") <- value; can get set attributes \nattributes().elements list can type (even list); elements \natomic vector type. Similarly, every element \nmatrix must type; data frame, different columns can \ndifferent types.elements list can type (even list); elements \natomic vector type. Similarly, every element \nmatrix must type; data frame, different columns can \ndifferent types.can make list-array assigning dimensions list. can\nmake matrix column data frame df$x <- matrix(), \nusing () creating new data frame data.frame(x = (matrix())).can make list-array assigning dimensions list. can\nmake matrix column data frame df$x <- matrix(), \nusing () creating new data frame data.frame(x = (matrix())).Tibbles enhanced print method, never coerce strings \nfactors, provide stricter subsetting methods.Tibbles enhanced print method, never coerce strings \nfactors, provide stricter subsetting methods.","code":""},{"path":"subsetting.html","id":"subsetting","chapter":"4 Subsetting","heading":"4 Subsetting","text":"","code":""},{"path":"subsetting.html","id":"introduction-3","chapter":"4 Subsetting","heading":"4.1 Introduction","text":"R’s subsetting operators fast powerful. Mastering allows succinctly perform complex operations way languages can match. Subsetting R easy learn hard master need internalise number interrelated concepts:six ways subset atomic vectors.six ways subset atomic vectors.three subsetting operators, [[, [, $.three subsetting operators, [[, [, $.Subsetting operators interact differently different vector\ntypes (e.g., atomic vectors, lists, factors, matrices, data frames).Subsetting operators interact differently different vector\ntypes (e.g., atomic vectors, lists, factors, matrices, data frames).Subsetting can combined assignment.Subsetting can combined assignment.Subsetting natural complement str(). str() shows pieces object (structure), subsetting allows pull pieces ’re interested . large, complex objects, highly recommend using interactive RStudio Viewer, can activate View(my_object).","code":""},{"path":"subsetting.html","id":"quiz-2","chapter":"4 Subsetting","heading":"Quiz","text":"Take short quiz determine need read chapter. answers quickly come mind, can comfortably skip chapter. Check answers Section 4.6.result subsetting vector positive integers,\nnegative integers, logical vector, character vector?result subsetting vector positive integers,\nnegative integers, logical vector, character vector?’s difference [, [[, $ applied list?’s difference [, [[, $ applied list?use drop = FALSE?use drop = FALSE?x matrix, x[] <- 0 ? different \nx <- 0?x matrix, x[] <- 0 ? different \nx <- 0?can use named vector relabel categorical variables?can use named vector relabel categorical variables?","code":""},{"path":"subsetting.html","id":"outline-2","chapter":"4 Subsetting","heading":"Outline","text":"Section 4.2 starts teaching [.\n’ll learn six ways subset atomic vectors. ’ll \nlearn six ways act used subset lists, matrices,\ndata frames.Section 4.2 starts teaching [.\n’ll learn six ways subset atomic vectors. ’ll \nlearn six ways act used subset lists, matrices,\ndata frames.Section 4.3 expands knowledge subsetting\noperators include [[ $ focuses important\nprinciples simplifying versus preserving.Section 4.3 expands knowledge subsetting\noperators include [[ $ focuses important\nprinciples simplifying versus preserving.Section 4.4 ’ll learn art \nsubassignment, combines subsetting assignment modify\nparts object.Section 4.4 ’ll learn art \nsubassignment, combines subsetting assignment modify\nparts object.Section 4.5 leads eight important, \nobvious, applications subsetting solve problems \noften encounter data analysis.Section 4.5 leads eight important, \nobvious, applications subsetting solve problems \noften encounter data analysis.","code":""},{"path":"subsetting.html","id":"subset-multiple","chapter":"4 Subsetting","heading":"4.2 Selecting multiple elements","text":"Use [ select number elements vector. illustrate, ’ll apply [ 1D atomic vectors, show generalises complex objects dimensions.","code":""},{"path":"subsetting.html","id":"atomic-vectors-1","chapter":"4 Subsetting","heading":"4.2.1 Atomic vectors","text":"\nLet’s explore different types subsetting simple vector, x.Note number decimal point represents original position vector.six things can use subset vector:Positive integers return elements specified positions:\n\nx[c(3, 1)]\n#> [1] 3.3 2.1\nx[order(x)]\n#> [1] 2.1 3.3 4.2 5.4\n\n# Duplicate indices duplicate values\nx[c(1, 1)]\n#> [1] 2.1 2.1\n\n# Real numbers silently truncated integers\nx[c(2.1, 2.9)]\n#> [1] 4.2 4.2Positive integers return elements specified positions:Negative integers exclude elements specified positions:\n\nx[-c(3, 1)]\n#> [1] 4.2 5.4\nNote can’t mix positive negative integers single subset:\n\nx[c(-1, 2)]\n#> Error x[c(-1, 2)]: solamente 0's pueden ser mezclados con subscritos negativosNegative integers exclude elements specified positions:Note can’t mix positive negative integers single subset:Logical vectors select elements corresponding logical\nvalue TRUE. probably useful type subsetting\ncan write expression uses logical vector:\n\nx[c(TRUE, TRUE, FALSE, FALSE)]\n#> [1] 2.1 4.2\nx[x > 3]\n#> [1] 4.2 3.3 5.4\n\nx[y], happens x y different lengths? behaviour\ncontrolled recycling rules shorter two \nrecycled length longer. convenient easy \nunderstand one x y length one, recommend avoiding\nrecycling lengths rules inconsistently applied\nthroughout base R.\n\nx[c(TRUE, FALSE)]\n#> [1] 2.1 3.3\n# Equivalent \nx[c(TRUE, FALSE, TRUE, FALSE)]\n#> [1] 2.1 3.3\nNote missing value index always yields missing value output:\n\nx[c(TRUE, TRUE, NA, FALSE)]\n#> [1] 2.1 4.2  NALogical vectors select elements corresponding logical\nvalue TRUE. probably useful type subsetting\ncan write expression uses logical vector:\nx[y], happens x y different lengths? behaviour\ncontrolled recycling rules shorter two \nrecycled length longer. convenient easy \nunderstand one x y length one, recommend avoiding\nrecycling lengths rules inconsistently applied\nthroughout base R.Note missing value index always yields missing value output:Nothing returns original vector. useful 1D vectors,\n, ’ll see shortly, useful matrices, data frames, arrays.\ncan also useful conjunction assignment.\n\nx[]\n#> [1] 2.1 4.2 3.3 5.4Nothing returns original vector. useful 1D vectors,\n, ’ll see shortly, useful matrices, data frames, arrays.\ncan also useful conjunction assignment.Zero returns zero-length vector. something \nusually purpose, can helpful generating test data.\n\nx[0]\n#> numeric(0)Zero returns zero-length vector. something \nusually purpose, can helpful generating test data.vector named, can also use character vectors return\nelements matching names.\n\n(y <- setNames(x, letters[1:4]))\n#>     b   c   d \n#> 2.1 4.2 3.3 5.4\ny[c(\"d\", \"c\", \"\")]\n#>   d   c   \n#> 5.4 3.3 2.1\n\n# Like integer indices, can repeat indices\ny[c(\"\", \"\", \"\")]\n#>       \n#> 2.1 2.1 2.1\n\n# subsetting [, names always matched exactly\nz <- c(abc = 1, def = 2)\nz[c(\"\", \"d\")]\n#> <NA> <NA> \n#>   NA   NAIf vector named, can also use character vectors return\nelements matching names.NB: Factors treated specially subsetting. means subsetting use underlying integer vector, character levels. typically unexpected, avoid subsetting factors:","code":"\nx <- c(2.1, 4.2, 3.3, 5.4)\nx[c(3, 1)]\n#> [1] 3.3 2.1\nx[order(x)]\n#> [1] 2.1 3.3 4.2 5.4\n\n# Duplicate indices will duplicate values\nx[c(1, 1)]\n#> [1] 2.1 2.1\n\n# Real numbers are silently truncated to integers\nx[c(2.1, 2.9)]\n#> [1] 4.2 4.2\nx[-c(3, 1)]\n#> [1] 4.2 5.4\nx[c(-1, 2)]\n#> Error in x[c(-1, 2)]: solamente 0's pueden ser mezclados con subscritos negativos\nx[c(TRUE, TRUE, FALSE, FALSE)]\n#> [1] 2.1 4.2\nx[x > 3]\n#> [1] 4.2 3.3 5.4\nx[c(TRUE, FALSE)]\n#> [1] 2.1 3.3\n# Equivalent to\nx[c(TRUE, FALSE, TRUE, FALSE)]\n#> [1] 2.1 3.3\nx[c(TRUE, TRUE, NA, FALSE)]\n#> [1] 2.1 4.2  NA\nx[]\n#> [1] 2.1 4.2 3.3 5.4\nx[0]\n#> numeric(0)\n(y <- setNames(x, letters[1:4]))\n#>   a   b   c   d \n#> 2.1 4.2 3.3 5.4\ny[c(\"d\", \"c\", \"a\")]\n#>   d   c   a \n#> 5.4 3.3 2.1\n\n# Like integer indices, you can repeat indices\ny[c(\"a\", \"a\", \"a\")]\n#>   a   a   a \n#> 2.1 2.1 2.1\n\n# When subsetting with [, names are always matched exactly\nz <- c(abc = 1, def = 2)\nz[c(\"a\", \"d\")]\n#> <NA> <NA> \n#>   NA   NA\ny[factor(\"b\")]\n#>   a \n#> 2.1"},{"path":"subsetting.html","id":"lists-1","chapter":"4 Subsetting","heading":"4.2.2 Lists","text":"\nSubsetting list works way subsetting atomic vector. Using [ always returns list; [[ $, described Section 4.3, let pull elements list.","code":""},{"path":"subsetting.html","id":"matrix-subsetting","chapter":"4 Subsetting","heading":"4.2.3 Matrices and arrays","text":"\ncan subset higher-dimensional structures three ways:multiple vectors.single vector.matrix.common way subsetting matrices (2D) arrays (>2D) simple generalisation 1D subsetting: supply 1D index dimension, separated comma. Blank subsetting now useful lets keep rows columns.default, [ simplifies results lowest possible dimensionality. example, following expressions return 1D vectors. ’ll learn avoid “dropping” dimensions Section 4.2.5:matrices arrays just vectors special attributes, can subset single vector, 1D vector. Note arrays R stored column-major order:can also subset higher-dimensional data structures integer matrix (, named, character matrix). row matrix specifies location one value, column corresponds dimension array. means can use 2 column matrix subset matrix, 3 column matrix subset 3D array, . result vector values:","code":"\na <- matrix(1:9, nrow = 3)\ncolnames(a) <- c(\"A\", \"B\", \"C\")\na[1:2, ]\n#>      A B C\n#> [1,] 1 4 7\n#> [2,] 2 5 8\na[c(TRUE, FALSE, TRUE), c(\"B\", \"A\")]\n#>      B A\n#> [1,] 4 1\n#> [2,] 6 3\na[0, -2]\n#>      A C\na[1, ]\n#> A B C \n#> 1 4 7\na[1, 1]\n#> A \n#> 1\nvals <- outer(1:5, 1:5, FUN = \"paste\", sep = \",\")\nvals\n#>      [,1]  [,2]  [,3]  [,4]  [,5] \n#> [1,] \"1,1\" \"1,2\" \"1,3\" \"1,4\" \"1,5\"\n#> [2,] \"2,1\" \"2,2\" \"2,3\" \"2,4\" \"2,5\"\n#> [3,] \"3,1\" \"3,2\" \"3,3\" \"3,4\" \"3,5\"\n#> [4,] \"4,1\" \"4,2\" \"4,3\" \"4,4\" \"4,5\"\n#> [5,] \"5,1\" \"5,2\" \"5,3\" \"5,4\" \"5,5\"\n\nvals[c(4, 15)]\n#> [1] \"4,1\" \"5,3\"\nselect <- matrix(ncol = 2, byrow = TRUE, c(\n  1, 1,\n  3, 1,\n  2, 4\n))\nvals[select]\n#> [1] \"1,1\" \"3,1\" \"2,4\""},{"path":"subsetting.html","id":"df-subsetting","chapter":"4 Subsetting","heading":"4.2.4 Data frames and tibbles","text":"\nData frames characteristics lists matrices:subsetting single index, behave like lists index\ncolumns, df[1:2] selects first two columns.subsetting single index, behave like lists index\ncolumns, df[1:2] selects first two columns.subsetting two indices, behave like matrices, \ndf[1:3, ] selects first three rows (columns)33.subsetting two indices, behave like matrices, \ndf[1:3, ] selects first three rows (columns)33.Subsetting tibble [ always returns tibble:","code":"\ndf <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\n\ndf[df$x == 2, ]\n#>   x y z\n#> 2 2 2 b\ndf[c(1, 3), ]\n#>   x y z\n#> 1 1 3 a\n#> 3 3 1 c\n\n# There are two ways to select columns from a data frame\n# Like a list\ndf[c(\"x\", \"z\")]\n#>   x z\n#> 1 1 a\n#> 2 2 b\n#> 3 3 c\n# Like a matrix\ndf[, c(\"x\", \"z\")]\n#>   x z\n#> 1 1 a\n#> 2 2 b\n#> 3 3 c\n\n# There's an important difference if you select a single \n# column: matrix subsetting simplifies by default, list \n# subsetting does not.\nstr(df[\"x\"])\n#> 'data.frame':    3 obs. of  1 variable:\n#>  $ x: int  1 2 3\nstr(df[, \"x\"])\n#>  int [1:3] 1 2 3\ndf <- tibble::tibble(x = 1:3, y = 3:1, z = letters[1:3])\n\nstr(df[\"x\"])\n#> tibble [3 x 1] (S3: tbl_df/tbl/data.frame)\n#>  $ x: int [1:3] 1 2 3\nstr(df[, \"x\"])\n#> tibble [3 x 1] (S3: tbl_df/tbl/data.frame)\n#>  $ x: int [1:3] 1 2 3"},{"path":"subsetting.html","id":"simplify-preserve","chapter":"4 Subsetting","heading":"4.2.5 Preserving dimensionality","text":"\ndefault, subsetting matrix data frame single number, single name, logical vector containing single TRUE, simplify returned output, .e. return object lower dimensionality. preserve original dimensionality, must use drop = FALSE.matrices arrays, dimensions length 1 dropped:\n\n<- matrix(1:4, nrow = 2)\nstr([1, ])\n#>  int [1:2] 1 3\n\nstr([1, , drop = FALSE])\n#>  int [1, 1:2] 1 3For matrices arrays, dimensions length 1 dropped:Data frames single column return just content column:\n\ndf <- data.frame(= 1:2, b = 1:2)\nstr(df[, \"\"])\n#>  int [1:2] 1 2\n\nstr(df[, \"\", drop = FALSE])\n#> 'data.frame':    2 obs.  1 variable:\n#>  $ : int  1 2Data frames single column return just content column:default drop = TRUE behaviour common source bugs functions: check code data frame matrix multiple columns, works. Six months later, (someone else) uses single column data frame fails mystifying error. writing functions, get habit always using drop = FALSE subsetting 2D object. reason, tibbles default drop = FALSE, [ always returns another tibble.Factor subsetting also drop argument, meaning rather different. controls whether levels (rather dimensions) preserved, defaults FALSE. find ’re using drop = TRUE lot ’s often sign using character vector instead factor.","code":"\na <- matrix(1:4, nrow = 2)\nstr(a[1, ])\n#>  int [1:2] 1 3\n\nstr(a[1, , drop = FALSE])\n#>  int [1, 1:2] 1 3\ndf <- data.frame(a = 1:2, b = 1:2)\nstr(df[, \"a\"])\n#>  int [1:2] 1 2\n\nstr(df[, \"a\", drop = FALSE])\n#> 'data.frame':    2 obs. of  1 variable:\n#>  $ a: int  1 2\nz <- factor(c(\"a\", \"b\"))\nz[1]\n#> [1] a\n#> Levels: a b\nz[1, drop = TRUE]\n#> [1] a\n#> Levels: a"},{"path":"subsetting.html","id":"exercises-9","chapter":"4 Subsetting","heading":"4.2.6 Exercises","text":"Fix following common data frame subsetting errors:\nmtcars[mtcars$cyl = 4, ]\nmtcars[-1:4, ]\nmtcars[mtcars$cyl <= 5]\nmtcars[mtcars$cyl == 4 | 6, ]Fix following common data frame subsetting errors:following code yield five missing values? (Hint: \ndifferent x[NA_real_]?)\n\nx <- 1:5\nx[NA]\n#> [1] NA NA NA NA NAWhy following code yield five missing values? (Hint: \ndifferent x[NA_real_]?)upper.tri() return? subsetting matrix \nwork? need additional subsetting rules describe behaviour?\n\nx <- outer(1:5, 1:5, FUN = \"*\")\nx[upper.tri(x)]upper.tri() return? subsetting matrix \nwork? need additional subsetting rules describe behaviour?mtcars[1:20] return error? differ \nsimilar mtcars[1:20, ]?mtcars[1:20] return error? differ \nsimilar mtcars[1:20, ]?Implement function extracts diagonal entries \nmatrix (behave like diag(x) x matrix).Implement function extracts diagonal entries \nmatrix (behave like diag(x) x matrix).df[.na(df)] <- 0 ? work?df[.na(df)] <- 0 ? work?","code":"mtcars[mtcars$cyl = 4, ]\nmtcars[-1:4, ]\nmtcars[mtcars$cyl <= 5]\nmtcars[mtcars$cyl == 4 | 6, ]\nx <- 1:5\nx[NA]\n#> [1] NA NA NA NA NA\nx <- outer(1:5, 1:5, FUN = \"*\")\nx[upper.tri(x)]"},{"path":"subsetting.html","id":"subset-single","chapter":"4 Subsetting","heading":"4.3 Selecting a single element","text":"\ntwo subsetting operators: [[ $. [[ used extracting single items, x$y useful shorthand x[[\"y\"]].","code":""},{"path":"subsetting.html","id":"section","chapter":"4 Subsetting","heading":"4.3.1 [[","text":"[[ important working lists subsetting list [ always returns smaller list. help make easier understand can use metaphor:list x train carrying objects, x[[5]] \nobject car 5; x[4:6] train cars 4-6.— @RLangTip, https://twitter.com/RLangTip/status/268375867468681216Let’s use metaphor make simple list:extracting single element, two options: can create smaller train, .e., fewer carriages, can extract contents particular carriage. difference [ [[:extracting multiple (even zero!) elements, make smaller train:[[ can return single item, must use either single positive integer single string. use vector [[, subset recursively, .e. x[[c(1, 2)]] equivalent x[[1]][[2]]. quirky feature know , recommend avoiding favour purrr::pluck(), ’ll learn Section 4.3.3.must use [[ working lists, ’d also recommend using atomic vectors whenever want extract single value. example, instead writing:’s better write:reinforces expectation getting setting individual values.","code":"\nx <- list(1:3, \"a\", 4:6)\nfor (i in 2:length(x)) {\n  out[i] <- fun(x[i], out[i - 1])\n}\nfor (i in 2:length(x)) {\n  out[[i]] <- fun(x[[i]], out[[i - 1]])\n}"},{"path":"subsetting.html","id":"section-1","chapter":"4 Subsetting","heading":"4.3.2 $","text":"$ shorthand operator: x$y roughly equivalent x[[\"y\"]]. ’s often used access variables data frame, mtcars$cyl diamonds$carat. One common mistake $ use name column stored variable:one important difference $ [[ $ (left--right) partial matching:\nhelp avoid behaviour highly recommend setting global option warnPartialMatchDollar TRUE:(data frames, can also avoid problem using tibbles, never partial matching.)","code":"\nvar <- \"cyl\"\n# Doesn't work - mtcars$var translated to mtcars[[\"var\"]]\nmtcars$var\n#> NULL\n\n# Instead use [[\nmtcars[[var]]\n#>  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4\nx <- list(abc = 1)\nx$a\n#> [1] 1\nx[[\"a\"]]\n#> NULL\noptions(warnPartialMatchDollar = TRUE)\nx$a\n#> Warning in x$a: encuentros parciales de 'a' to 'abc'\n#> [1] 1"},{"path":"subsetting.html","id":"subsetting-oob","chapter":"4 Subsetting","heading":"4.3.3 Missing and out-of-bounds indices","text":"\n\n\n’s useful understand happens [[ use “invalid” index. following table summarises happens subset logical vector, list, NULL zero-length object (like NULL logical()), --bounds values (OOB), missing value (e.g. NA_integer_) [[. cell shows result subsetting data structure named row type index described column. ’ve shown results logical vectors, atomic vectors behave similarly, returning elements type (NB: int = integer; chr = character).vector indexed named, names OOB, missing, NULL components <NA>.inconsistencies table led development purrr::pluck() purrr::chuck(). element missing, pluck() always returns NULL (value .default argument) chuck() always throws error. behaviour pluck() makes well suited indexing deeply nested data structures component want may exist (common working JSON data web APIs). pluck() also allows mix integer character indices, provides alternative default value item exist:","code":"\nx <- list(\n  a = list(1, 2, 3),\n  b = list(3, 4, 5)\n)\n\npurrr::pluck(x, \"a\", 1)\n#> [1] 1\n\npurrr::pluck(x, \"c\", 1)\n#> NULL\n\npurrr::pluck(x, \"c\", 1, .default = NA)\n#> [1] NA"},{"path":"subsetting.html","id":"and-slot","chapter":"4 Subsetting","heading":"4.3.4 @ and slot()","text":"two additional subsetting operators, needed S4 objects: @ (equivalent $), slot() (equivalent [[). @ restrictive $ return error slot exist. described detail Chapter 15.","code":""},{"path":"subsetting.html","id":"exercises-10","chapter":"4 Subsetting","heading":"4.3.5 Exercises","text":"Brainstorm many ways possible extract third value \ncyl variable mtcars dataset.Brainstorm many ways possible extract third value \ncyl variable mtcars dataset.Given linear model, e.g., mod <- lm(mpg ~ wt, data = mtcars), extract\nresidual degrees freedom. extract R squared model\nsummary (summary(mod))Given linear model, e.g., mod <- lm(mpg ~ wt, data = mtcars), extract\nresidual degrees freedom. extract R squared model\nsummary (summary(mod))","code":""},{"path":"subsetting.html","id":"subassignment","chapter":"4 Subsetting","heading":"4.4 Subsetting and assignment","text":"\n\nsubsetting operators can combined assignment modify selected values input vector: called subassignment. basic form x[] <- value:recommend make sure length(value) length(x[]), unique. , R recycle needed, rules complex (particularly contains missing duplicated values) may cause problems.lists, can use x[[]] <- NULL remove component. add literal NULL, use x[] <- list(NULL):Subsetting nothing can useful assignment preserves structure original object. Compare following two expressions. first, mtcars remains data frame changing contents mtcars, mtcars . second, mtcars becomes list changing object bound .","code":"\nx <- 1:5\nx[c(1, 2)] <- c(101, 102)\nx\n#> [1] 101 102   3   4   5\nx <- list(a = 1, b = 2)\nx[[\"b\"]] <- NULL\nstr(x)\n#> List of 1\n#>  $ a: num 1\n\ny <- list(a = 1, b = 2)\ny[\"b\"] <- list(NULL)\nstr(y)\n#> List of 2\n#>  $ a: num 1\n#>  $ b: NULL\nmtcars[] <- lapply(mtcars, as.integer)\nis.data.frame(mtcars)\n#> [1] TRUE\n\nmtcars <- lapply(mtcars, as.integer)\nis.data.frame(mtcars)\n#> [1] FALSE"},{"path":"subsetting.html","id":"applications","chapter":"4 Subsetting","heading":"4.5 Applications","text":"principles described wide variety useful applications. important described . many basic principles subsetting already incorporated functions like subset(), merge(), dplyr::arrange(), deeper understanding principles implemented valuable run situations functions need don’t exist.","code":""},{"path":"subsetting.html","id":"lookup-tables","chapter":"4 Subsetting","heading":"4.5.1 Lookup tables (character subsetting)","text":"Character matching powerful way create lookup tables. Say want convert abbreviations:Note don’t want names result, use unname() remove .","code":"\nx <- c(\"m\", \"f\", \"u\", \"f\", \"f\", \"m\", \"m\")\nlookup <- c(m = \"Male\", f = \"Female\", u = NA)\nlookup[x]\n#>        m        f        u        f        f        m        m \n#>   \"Male\" \"Female\"       NA \"Female\" \"Female\"   \"Male\"   \"Male\"\nunname(lookup[x])\n#> [1] \"Male\"   \"Female\" NA       \"Female\" \"Female\" \"Male\"   \"Male\""},{"path":"subsetting.html","id":"matching-merging","chapter":"4 Subsetting","heading":"4.5.2 Matching and merging by hand (integer subsetting)","text":"\ncan also complicated lookup tables multiple columns information. example, suppose vector integer grades, table describes properties:, let’s say want duplicate info table row value grades. elegant way combining match() integer subsetting (match(needles, haystack) returns position needle found haystack).’re matching multiple columns, ’ll need first collapse single column (e.g. interaction()). Typically, however, ’re better switching function designed specifically joining multiple tables like merge(), dplyr::left_join().","code":"\ngrades <- c(1, 2, 2, 3, 1)\n\ninfo <- data.frame(\n  grade = 3:1,\n  desc = c(\"Excellent\", \"Good\", \"Poor\"),\n  fail = c(F, F, T)\n)\nid <- match(grades, info$grade)\nid\n#> [1] 3 2 2 1 3\ninfo[id, ]\n#>     grade      desc  fail\n#> 3       1      Poor  TRUE\n#> 2       2      Good FALSE\n#> 2.1     2      Good FALSE\n#> 1       3 Excellent FALSE\n#> 3.1     1      Poor  TRUE"},{"path":"subsetting.html","id":"random-samples-and-bootstraps-integer-subsetting","chapter":"4 Subsetting","heading":"4.5.3 Random samples and bootstraps (integer subsetting)","text":"\ncan use integer indices randomly sample bootstrap vector data frame. Just use sample(n) generate random permutation 1:n, use results subset values:arguments sample() control number samples extract, also whether sampling done without replacement.","code":"\ndf <- data.frame(x = c(1, 2, 3, 1, 2), y = 5:1, z = letters[1:5])\n\n# Randomly reorder\ndf[sample(nrow(df)), ]\n#>   x y z\n#> 5 2 1 e\n#> 3 3 3 c\n#> 4 1 2 d\n#> 1 1 5 a\n#> 2 2 4 b\n\n# Select 3 random rows\ndf[sample(nrow(df), 3), ]\n#>   x y z\n#> 4 1 2 d\n#> 2 2 4 b\n#> 1 1 5 a\n\n# Select 6 bootstrap replicates\ndf[sample(nrow(df), 6, replace = TRUE), ]\n#>     x y z\n#> 5   2 1 e\n#> 5.1 2 1 e\n#> 5.2 2 1 e\n#> 2   2 4 b\n#> 3   3 3 c\n#> 3.1 3 3 c"},{"path":"subsetting.html","id":"ordering-integer-subsetting","chapter":"4 Subsetting","heading":"4.5.4 Ordering (integer subsetting)","text":"order() takes vector input returns integer vector describing order subsetted vector34:break ties, can supply additional variables order(). can also change order ascending descending using decreasing = TRUE. default, missing values put end vector; however, can remove na.last = NA put front na.last = FALSE.two dimensions, order() integer subsetting makes easy order either rows columns object:can sort vectors directly sort(), similarly dplyr::arrange(), sort data frame.","code":"\nx <- c(\"b\", \"c\", \"a\")\norder(x)\n#> [1] 3 1 2\nx[order(x)]\n#> [1] \"a\" \"b\" \"c\"\n# Randomly reorder df\ndf2 <- df[sample(nrow(df)), 3:1]\ndf2\n#>   z y x\n#> 5 e 1 2\n#> 1 a 5 1\n#> 4 d 2 1\n#> 2 b 4 2\n#> 3 c 3 3\n\ndf2[order(df2$x), ]\n#>   z y x\n#> 1 a 5 1\n#> 4 d 2 1\n#> 5 e 1 2\n#> 2 b 4 2\n#> 3 c 3 3\ndf2[, order(names(df2))]\n#>   x y z\n#> 5 2 1 e\n#> 1 1 5 a\n#> 4 1 2 d\n#> 2 2 4 b\n#> 3 3 3 c"},{"path":"subsetting.html","id":"expanding-aggregated-counts-integer-subsetting","chapter":"4 Subsetting","heading":"4.5.5 Expanding aggregated counts (integer subsetting)","text":"Sometimes get data frame identical rows collapsed one count column added. rep() integer subsetting make easy uncollapse, can take advantage rep()s vectorisation: rep(x, y) repeats x[] y[] times.","code":"\ndf <- data.frame(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1))\nrep(1:nrow(df), df$n)\n#> [1] 1 1 1 2 2 2 2 2 3\n\ndf[rep(1:nrow(df), df$n), ]\n#>     x  y n\n#> 1   2  9 3\n#> 1.1 2  9 3\n#> 1.2 2  9 3\n#> 2   4 11 5\n#> 2.1 4 11 5\n#> 2.2 4 11 5\n#> 2.3 4 11 5\n#> 2.4 4 11 5\n#> 3   1  6 1"},{"path":"subsetting.html","id":"removing-columns-from-data-frames-character","chapter":"4 Subsetting","heading":"4.5.6 Removing columns from data frames (character )","text":"two ways remove columns data frame. can set individual columns NULL:can subset return columns want:know columns don’t want, use set operations work columns keep:","code":"\ndf <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ndf$z <- NULL\ndf <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ndf[c(\"x\", \"y\")]\n#>   x y\n#> 1 1 3\n#> 2 2 2\n#> 3 3 1\ndf[setdiff(names(df), \"z\")]\n#>   x y\n#> 1 1 3\n#> 2 2 2\n#> 3 3 1"},{"path":"subsetting.html","id":"selecting-rows-based-on-a-condition-logical-subsetting","chapter":"4 Subsetting","heading":"4.5.7 Selecting rows based on a condition (logical subsetting)","text":"\nlogical subsetting allows easily combine conditions multiple columns, ’s probably commonly used technique extracting rows data frame.Remember use vector boolean operators & |, short-circuiting scalar operators && ||, useful inside statements. don’t forget De Morgan’s laws, can useful simplify negations:!(X & Y) !X | !Y!(X | Y) !X & !YFor example, !(X & !(Y | Z)) simplifies !X | !!(Y|Z), !X | Y | Z.","code":"\nmtcars[mtcars$gear == 5, ]\n#>                 mpg cyl  disp  hp drat   wt qsec vs am gear carb\n#> Porsche 914-2  26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2\n#> Lotus Europa   30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2\n#> Ford Pantera L 15.8   8 351.0 264 4.22 3.17 14.5  0  1    5    4\n#> Ferrari Dino   19.7   6 145.0 175 3.62 2.77 15.5  0  1    5    6\n#> Maserati Bora  15.0   8 301.0 335 3.54 3.57 14.6  0  1    5    8\n\nmtcars[mtcars$gear == 5 & mtcars$cyl == 4, ]\n#>                mpg cyl  disp  hp drat   wt qsec vs am gear carb\n#> Porsche 914-2 26.0   4 120.3  91 4.43 2.14 16.7  0  1    5    2\n#> Lotus Europa  30.4   4  95.1 113 3.77 1.51 16.9  1  1    5    2"},{"path":"subsetting.html","id":"boolean-algebra-versus-sets-logical-and-integer","chapter":"4 Subsetting","heading":"4.5.8 Boolean algebra versus sets (logical and integer )","text":"\n\n’s useful aware natural equivalence set operations (integer subsetting) Boolean algebra (logical subsetting). Using set operations effective :want find first (last) TRUE.want find first (last) TRUE.TRUEs many FALSEs; set representation\nmay faster require less storage.TRUEs many FALSEs; set representation\nmay faster require less storage.() allows convert Boolean representation integer representation. ’s reverse operation base R can easily create one:Let’s create two logical vectors integer equivalents, explore relationship Boolean set operations.first learning subsetting, common mistake use x[(y)] instead x[y]. () achieves nothing: switches logical integer subsetting result exactly . general cases, two important differences.logical vector contains NA, logical subsetting replaces \nvalues NA () simply drops values. ’s uncommon\nuse () side-effect, don’t recommend : nothing\nname “” implies removal missing values.logical vector contains NA, logical subsetting replaces \nvalues NA () simply drops values. ’s uncommon\nuse () side-effect, don’t recommend : nothing\nname “” implies removal missing values.x[-(y)] equivalent x[!y]: y FALSE,\n(y) integer(0) -integer(0) still integer(0), \n’ll get values, instead values.x[-(y)] equivalent x[!y]: y FALSE,\n(y) integer(0) -integer(0) still integer(0), \n’ll get values, instead values.general, avoid switching logical integer subsetting unless want, example, first last TRUE value.","code":"\nx <- sample(10) < 4\nwhich(x)\n#> [1] 2 3 4\n\nunwhich <- function(x, n) {\n  out <- rep_len(FALSE, n)\n  out[x] <- TRUE\n  out\n}\nunwhich(which(x), 10)\n#>  [1] FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n(x1 <- 1:10 %% 2 == 0)\n#>  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n(x2 <- which(x1))\n#> [1]  2  4  6  8 10\n(y1 <- 1:10 %% 5 == 0)\n#>  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE\n(y2 <- which(y1))\n#> [1]  5 10\n\n# X & Y <-> intersect(x, y)\nx1 & y1\n#>  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\nintersect(x2, y2)\n#> [1] 10\n\n# X | Y <-> union(x, y)\nx1 | y1\n#>  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\nunion(x2, y2)\n#> [1]  2  4  6  8 10  5\n\n# X & !Y <-> setdiff(x, y)\nx1 & !y1\n#>  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE\nsetdiff(x2, y2)\n#> [1] 2 4 6 8\n\n# xor(X, Y) <-> setdiff(union(x, y), intersect(x, y))\nxor(x1, y1)\n#>  [1] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\nsetdiff(union(x2, y2), intersect(x2, y2))\n#> [1] 2 4 6 8 5"},{"path":"subsetting.html","id":"exercises-11","chapter":"4 Subsetting","heading":"4.5.9 Exercises","text":"randomly permute columns data frame? (\nimportant technique random forests.) Can simultaneously permute\nrows columns one step?randomly permute columns data frame? (\nimportant technique random forests.) Can simultaneously permute\nrows columns one step?select random sample m rows data frame?\nsample contiguous (.e., initial row, \nfinal row, every row )?select random sample m rows data frame?\nsample contiguous (.e., initial row, \nfinal row, every row )?put columns data frame alphabetical order?put columns data frame alphabetical order?","code":""},{"path":"subsetting.html","id":"subsetting-answers","chapter":"4 Subsetting","heading":"4.6 Quiz answers","text":"Positive integers select elements specific positions, negative integers\ndrop elements; logical vectors keep elements positions corresponding \nTRUE; character vectors select elements matching names.Positive integers select elements specific positions, negative integers\ndrop elements; logical vectors keep elements positions corresponding \nTRUE; character vectors select elements matching names.[ selects sub-lists: always returns list. use \nsingle positive integer, returns list length one. [[ selects\nelement within list. $ convenient shorthand: x$y \nequivalent x[[\"y\"]].[ selects sub-lists: always returns list. use \nsingle positive integer, returns list length one. [[ selects\nelement within list. $ convenient shorthand: x$y \nequivalent x[[\"y\"]].Use drop = FALSE subsetting matrix, array, data frame\nwant preserve original dimensions. almost\nalways use subsetting inside function.Use drop = FALSE subsetting matrix, array, data frame\nwant preserve original dimensions. almost\nalways use subsetting inside function.x matrix, x[] <- 0 replace every element 0,\nkeeping number rows columns. contrast, x <- 0\ncompletely replaces matrix value 0.x matrix, x[] <- 0 replace every element 0,\nkeeping number rows columns. contrast, x <- 0\ncompletely replaces matrix value 0.named character vector can act simple lookup table:\nc(x = 1, y = 2, z = 3)[c(\"y\", \"z\", \"x\")]named character vector can act simple lookup table:\nc(x = 1, y = 2, z = 3)[c(\"y\", \"z\", \"x\")]","code":""},{"path":"control-flow.html","id":"control-flow","chapter":"5 Control flow","heading":"5 Control flow","text":"","code":""},{"path":"control-flow.html","id":"introduction-4","chapter":"5 Control flow","heading":"5.1 Introduction","text":"two primary tools control flow: choices loops. Choices, like statements switch() calls, allow run different code depending input. Loops, like , allow repeatedly run code, typically changing options. ’d expect ’re already familiar basics functions ’ll briefly cover technical details introduce useful, lesser known, features.condition system (messages, warnings, errors), ’ll learn Chapter 8, also provides non-local control flow.","code":""},{"path":"control-flow.html","id":"quiz-3","chapter":"5 Control flow","heading":"Quiz","text":"Want skip chapter? Go , can answer questions . Find answers end chapter Section 5.4.difference ifelse()?difference ifelse()?following code, value y x TRUE?\nx FALSE? x NA?\n\ny <- (x) 3In following code, value y x TRUE?\nx FALSE? x NA?switch(\"x\", x = , y = 2, z = 3) return?switch(\"x\", x = , y = 2, z = 3) return?","code":"\ny <- if (x) 3"},{"path":"control-flow.html","id":"outline-3","chapter":"5 Control flow","heading":"Outline","text":"Section 5.2 dives details , discusses\nclose relatives ifelse() switch().Section 5.2 dives details , discusses\nclose relatives ifelse() switch().Section 5.3 starts reminding basic structure\nloop R, discusses common pitfalls, talks\nrelated repeat statements.Section 5.3 starts reminding basic structure\nloop R, discusses common pitfalls, talks\nrelated repeat statements.","code":""},{"path":"control-flow.html","id":"choices","chapter":"5 Control flow","heading":"5.2 Choices","text":"basic form statement R follows:condition TRUE, true_action evaluated; condition FALSE, optional false_action evaluated.Typically actions compound statements contained within {:returns value can assign results:(recommend assigning results statement entire expression fits one line; otherwise tends hard read.)use single argument form without else statement, invisibly (Section 6.7.2) returns NULL condition FALSE. Since functions like c() paste() drop NULL inputs, allows compact expression certain idioms:","code":"\nif (condition) true_action\nif (condition) true_action else false_action\ngrade <- function(x) {\n  if (x > 90) {\n    \"A\"\n  } else if (x > 80) {\n    \"B\"\n  } else if (x > 50) {\n    \"C\"\n  } else {\n    \"F\"\n  }\n}\nx1 <- if (TRUE) 1 else 2\nx2 <- if (FALSE) 1 else 2\n\nc(x1, x2)\n#> [1] 1 2\ngreet <- function(name, birthday = FALSE) {\n  paste0(\n    \"Hi \", name,\n    if (birthday) \" and HAPPY BIRTHDAY\"\n  )\n}\ngreet(\"Maria\", FALSE)\n#> [1] \"Hi Maria\"\ngreet(\"Jaime\", TRUE)\n#> [1] \"Hi Jaime and HAPPY BIRTHDAY\""},{"path":"control-flow.html","id":"invalid-inputs","chapter":"5 Control flow","heading":"5.2.1 Invalid inputs","text":"condition evaluate single TRUE FALSE. inputs generate error:exception logical vector length greater 1, generates warning:R 3.5.0 greater, thanks Henrik Bengtsson, can turn error setting environment variable:think good practice reveals clear mistake might otherwise miss shown warning.","code":"\nif (\"x\") 1\n#> Error in if (\"x\") 1: argumento no interpetable como lógico\nif (logical()) 1\n#> Error in if (logical()) 1: argumento tiene longitud cero\nif (NA) 1\n#> Error in if (NA) 1: valor ausente donde TRUE/FALSE es necesario\nif (c(TRUE, FALSE)) 1\n#> Warning in if (c(TRUE, FALSE)) 1: la condición tiene longitud > 1 y sólo el\n#> primer elemento será usado\n#> [1] 1\nSys.setenv(\"_R_CHECK_LENGTH_1_CONDITION_\" = \"true\")\nif (c(TRUE, FALSE)) 1\n#> Error in if (c(TRUE, FALSE)) 1: the condition has length > 1"},{"path":"control-flow.html","id":"vectorised-if","chapter":"5 Control flow","heading":"5.2.2 Vectorised if","text":"Given works single TRUE FALSE, might wonder vector logical values. Handling vectors values job ifelse(): vectorised function test, yes, vectors (recycled length):Note missing values propagated output.recommend using ifelse() yes vectors type otherwise hard predict output type. See https://vctrs.r-lib.org/articles/stability.html#ifelse additional discussion.Another vectorised equivalent general dplyr::case_when(). uses special syntax allow number condition-vector pairs:","code":"\nx <- 1:10\nifelse(x %% 5 == 0, \"XXX\", as.character(x))\n#>  [1] \"1\"   \"2\"   \"3\"   \"4\"   \"XXX\" \"6\"   \"7\"   \"8\"   \"9\"   \"XXX\"\n\nifelse(x %% 2 == 0, \"even\", \"odd\")\n#>  [1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\ndplyr::case_when(\n  x %% 35 == 0 ~ \"fizz buzz\",\n  x %% 5 == 0 ~ \"fizz\",\n  x %% 7 == 0 ~ \"buzz\",\n  is.na(x) ~ \"???\",\n  TRUE ~ as.character(x)\n)\n#>  [1] \"1\"    \"2\"    \"3\"    \"4\"    \"fizz\" \"6\"    \"buzz\" \"8\"    \"9\"    \"fizz\""},{"path":"control-flow.html","id":"switch","chapter":"5 Control flow","heading":"5.2.3 switch() statement","text":"Closely related switch()-statement. ’s compact, special purpose equivalent lets replace code like:succinct:last component switch() always throw error, otherwise unmatched inputs invisibly return NULL:multiple inputs output, can leave right hand side = empty input “fall ” next value. mimics behaviour C’s switch statement:also possible use switch() numeric x, harder read, undesirable failure modes x whole number. recommend using switch() character inputs.","code":"\nx_option <- function(x) {\n  if (x == \"a\") {\n    \"option 1\"\n  } else if (x == \"b\") {\n    \"option 2\" \n  } else if (x == \"c\") {\n    \"option 3\"\n  } else {\n    stop(\"Invalid `x` value\")\n  }\n}\nx_option <- function(x) {\n  switch(x,\n    a = \"option 1\",\n    b = \"option 2\",\n    c = \"option 3\",\n    stop(\"Invalid `x` value\")\n  )\n}\n(switch(\"c\", a = 1, b = 2))\n#> NULL\nlegs <- function(x) {\n  switch(x,\n    cow = ,\n    horse = ,\n    dog = 4,\n    human = ,\n    chicken = 2,\n    plant = 0,\n    stop(\"Unknown input\")\n  )\n}\nlegs(\"cow\")\n#> [1] 4\nlegs(\"dog\")\n#> [1] 4"},{"path":"control-flow.html","id":"exercises-12","chapter":"5 Control flow","heading":"5.2.4 Exercises","text":"type vector following calls ifelse()\nreturn?\n\nifelse(TRUE, 1, \"\")\nifelse(FALSE, 1, \"\")\nifelse(NA, 1, \"\")\nRead documentation write rules words.type vector following calls ifelse()\nreturn?Read documentation write rules words.following code work?\n\nx <- 1:10\n(length(x)) \"empty\" else \"empty\"\n#> [1] \"empty\"\n\nx <- numeric()\n(length(x)) \"empty\" else \"empty\"\n#> [1] \"empty\"following code work?","code":"\nifelse(TRUE, 1, \"no\")\nifelse(FALSE, 1, \"no\")\nifelse(NA, 1, \"no\")\nx <- 1:10\nif (length(x)) \"not empty\" else \"empty\"\n#> [1] \"not empty\"\n\nx <- numeric()\nif (length(x)) \"not empty\" else \"empty\"\n#> [1] \"empty\""},{"path":"control-flow.html","id":"loops","chapter":"5 Control flow","heading":"5.3 Loops","text":"\n\nloops used iterate items vector. following basic form:item vector, perform_action called ; updating value item time.(iterating vector indices, ’s conventional use short variable names like , j, k.)N.B.: assigns item current environment, overwriting existing variable name:two ways terminate loop early:next exits current iteration.break exits entire loop.","code":"\nfor (item in vector) perform_action\nfor (i in 1:3) {\n  print(i)\n}\n#> [1] 1\n#> [1] 2\n#> [1] 3\ni <- 100\nfor (i in 1:3) {}\ni\n#> [1] 3\nfor (i in 1:10) {\n  if (i < 3) \n    next\n\n  print(i)\n  \n  if (i >= 5)\n    break\n}\n#> [1] 3\n#> [1] 4\n#> [1] 5"},{"path":"control-flow.html","id":"common-pitfalls","chapter":"5 Control flow","heading":"5.3.1 Common pitfalls","text":"three common pitfalls watch using . First, ’re generating data, make sure preallocate output container. Otherwise loop slow; see Sections 23.2.2 24.6 details. vector() function helpful .Next, beware iterating 1:length(x), fail unhelpful ways x length 0:occurs : works increasing decreasing sequences:Use seq_along(x) instead. always returns value length x:Finally, might encounter problems iterating S3 vectors, loops typically strip attributes:Work around calling [[ :","code":"\nmeans <- c(1, 50, 20)\nout <- vector(\"list\", length(means))\nfor (i in 1:length(means)) {\n  out[[i]] <- rnorm(10, means[[i]])\n}\nmeans <- c()\nout <- vector(\"list\", length(means))\nfor (i in 1:length(means)) {\n  out[[i]] <- rnorm(10, means[[i]])\n}\n#> Error in rnorm(10, means[[i]]): invalid arguments\n1:length(means)\n#> [1] 1 0\nseq_along(means)\n#> integer(0)\n\nout <- vector(\"list\", length(means))\nfor (i in seq_along(means)) {\n  out[[i]] <- rnorm(10, means[[i]])\n}\nxs <- as.Date(c(\"2020-01-01\", \"2010-01-01\"))\nfor (x in xs) {\n  print(x)\n}\n#> [1] 18262\n#> [1] 14610\nfor (i in seq_along(xs)) {\n  print(xs[[i]])\n}\n#> [1] \"2020-01-01\"\n#> [1] \"2010-01-01\""},{"path":"control-flow.html","id":"for-family","chapter":"5 Control flow","heading":"5.3.2 Related tools","text":"loops useful know advance set values want iterate . don’t know, two related tools flexible specifications:(condition) action: performs action condition TRUE.(condition) action: performs action condition TRUE.repeat(action): repeats action forever (.e. encounters break).repeat(action): repeats action forever (.e. encounters break).R equivalent {action} (condition) syntax found languages.can rewrite loop use instead, can rewrite loop use repeat, converses true. means flexible , repeat flexible . ’s good practice, however, use least-flexible solution problem, use wherever possible.Generally speaking shouldn’t need use loops data analysis tasks, map() apply() already provide less flexible solutions problems. ’ll learn Chapter 9.","code":""},{"path":"control-flow.html","id":"exercises-13","chapter":"5 Control flow","heading":"5.3.3 Exercises","text":"code succeed without errors warnings?\n\nx <- numeric()\n<- vector(\"list\", length(x))\n(1:length(x)) {\n  [] <- x[] ^ 2\n}\noutWhy code succeed without errors warnings?following code evaluated, can say \nvector iterated?\n\nxs <- c(1, 2, 3)\n(x xs) {\n  xs <- c(xs, x * 2)\n}\nxs\n#> [1] 1 2 3 2 4 6When following code evaluated, can say \nvector iterated?following code tell index updated?\n\n(1:3) {\n  <- * 2\n  print() \n}\n#> [1] 2\n#> [1] 4\n#> [1] 6What following code tell index updated?","code":"\nx <- numeric()\nout <- vector(\"list\", length(x))\nfor (i in 1:length(x)) {\n  out[i] <- x[i] ^ 2\n}\nout\nxs <- c(1, 2, 3)\nfor (x in xs) {\n  xs <- c(xs, x * 2)\n}\nxs\n#> [1] 1 2 3 2 4 6\nfor (i in 1:3) {\n  i <- i * 2\n  print(i) \n}\n#> [1] 2\n#> [1] 4\n#> [1] 6"},{"path":"control-flow.html","id":"control-flow-answers","chapter":"5 Control flow","heading":"5.4 Quiz answers","text":"works scalars; ifelse() works vectors.works scalars; ifelse() works vectors.x TRUE, y 3; FALSE, y NULL;\nNA statement throw error.x TRUE, y 3; FALSE, y NULL;\nNA statement throw error.switch() statement makes use fall-return 2.\nSee details Section 5.2.3.switch() statement makes use fall-return 2.\nSee details Section 5.2.3.","code":""},{"path":"functions.html","id":"functions","chapter":"6 Functions","heading":"6 Functions","text":"","code":""},{"path":"functions.html","id":"introduction-5","chapter":"6 Functions","heading":"6.1 Introduction","text":"\n’re reading book, ’ve probably already created many R functions know use reduce duplication code. chapter, ’ll learn turn informal, working knowledge rigorous, theoretical understanding. ’ll see interesting tricks techniques along way, keep mind ’ll learn important understanding advanced topics discussed later book.","code":""},{"path":"functions.html","id":"quiz-4","chapter":"6 Functions","heading":"Quiz","text":"Answer following questions see can safely skip chapter. can find answers Section 6.9.three components function?three components function?following code return?\n\nx <- 10\nf1 <- function(x) {\n  function() {\n    x + 10\n  }\n}\nf1(1)()following code return?usually write code?\n\n`+`(1, `*`(2, 3))usually write code?make call easier read?\n\nmean(, TRUE, x = c(1:10, NA))make call easier read?following code throw error executed? ?\n\nf2 <- function(, b) {\n  * 10\n}\nf2(10, stop(\"error!\"))following code throw error executed? ?infix function? write ? ’s replacement\nfunction? write ?infix function? write ? ’s replacement\nfunction? write ?ensure cleanup action occurs regardless function\nexits?ensure cleanup action occurs regardless function\nexits?","code":"\nx <- 10\nf1 <- function(x) {\n  function() {\n    x + 10\n  }\n}\nf1(1)()\n`+`(1, `*`(2, 3))\nmean(, TRUE, x = c(1:10, NA))\nf2 <- function(a, b) {\n  a * 10\n}\nf2(10, stop(\"This is an error!\"))"},{"path":"functions.html","id":"outline-4","chapter":"6 Functions","heading":"Outline","text":"Section 6.2 describes basics creating \nfunction, three main components function, exception\nmany function rules: primitive functions (implemented C, \nR).Section 6.2 describes basics creating \nfunction, three main components function, exception\nmany function rules: primitive functions (implemented C, \nR).Section 6.3 discusses strengths weaknesses\nthree forms function composition commonly used R code.Section 6.3 discusses strengths weaknesses\nthree forms function composition commonly used R code.Section 6.4 shows R finds value associated\ngiven name, .e. rules lexical scoping.Section 6.4 shows R finds value associated\ngiven name, .e. rules lexical scoping.Section 6.5 devoted important property \nfunction arguments: evaluated used first time.Section 6.5 devoted important property \nfunction arguments: evaluated used first time.Section 6.6 discusses special ... argument, \nallows pass extra arguments another function.Section 6.6 discusses special ... argument, \nallows pass extra arguments another function.Section 6.7 discusses two primary ways \nfunction can exit, define exit handler, code run \nexit, regardless triggers .Section 6.7 discusses two primary ways \nfunction can exit, define exit handler, code run \nexit, regardless triggers .Section 6.8 shows various ways R\ndisguises ordinary function calls, can use standard prefix\nform better understand ’s going .Section 6.8 shows various ways R\ndisguises ordinary function calls, can use standard prefix\nform better understand ’s going .","code":""},{"path":"functions.html","id":"function-fundamentals","chapter":"6 Functions","heading":"6.2 Function fundamentals","text":"understand functions R need internalise two important ideas:Functions can broken three components: arguments, body, environment.exceptions every rule, case, small selection “primitive” base functions implemented purely C.Functions objects, just vectors objects.","code":""},{"path":"functions.html","id":"fun-components","chapter":"6 Functions","heading":"6.2.1 Function components","text":"\n\n\n\n\n\n\nfunction three parts:formals(), list arguments control call function.formals(), list arguments control call function.body(), code inside function.body(), code inside function.environment(), data structure determines function finds\nvalues associated names.environment(), data structure determines function finds\nvalues associated names.formals body specified explicitly create function, environment specified implicitly, based defined function. function environment always exists, printed function isn’t defined global environment.’ll draw functions following diagram. black dot left environment. two blocks right function arguments. won’t draw body, ’s usually large, doesn’t help understand shape function.Like objects R, functions can also possess number additional attributes(). One attribute used base R srcref, short source reference. points source code used create function. srcref used printing , unlike body(), contains code comments formatting.","code":"\nf02 <- function(x, y) {\n  # A comment\n  x + y\n}\n\nformals(f02)\n#> $x\n#> \n#> \n#> $y\n\nbody(f02)\n#> {\n#>     x + y\n#> }\n\nenvironment(f02)\n#> <environment: R_GlobalEnv>\nattr(f02, \"srcref\")\n#> function(x, y) {\n#>   # A comment\n#>   x + y\n#> }"},{"path":"functions.html","id":"primitive-functions","chapter":"6 Functions","heading":"6.2.2 Primitive functions","text":"\n\none exception rule function three components. Primitive functions, like sum() [, call C code directly.either type builtin type special.functions exist primarily C, R, formals(), body(), environment() NULL:Primitive functions found base package. certain performance advantages, benefit comes price: harder write. reason, R-core generally avoids creating unless option.","code":"\nsum\n#> function (..., na.rm = FALSE)  .Primitive(\"sum\")\n`[`\n#> .Primitive(\"[\")\ntypeof(sum)\n#> [1] \"builtin\"\ntypeof(`[`)\n#> [1] \"special\"\nformals(sum)\n#> NULL\nbody(sum)\n#> NULL\nenvironment(sum)\n#> NULL"},{"path":"functions.html","id":"first-class-functions","chapter":"6 Functions","heading":"6.2.3 First-class functions","text":"\n’s important understand R functions objects right, language property often called “first-class functions.” Unlike many languages, special syntax defining naming function: simply create function object (function) bind name <-:almost always create function bind name, binding step compulsory. choose give function name, get anonymous function. useful ’s worth effort figure name:final option put functions list:R, ’ll often see functions called closures. name reflects fact R functions capture, enclose, environments, ’ll learn Section 7.4.2.","code":"\nf01 <- function(x) {\n  sin(1 / x ^ 2)\n}\nlapply(mtcars, function(x) length(unique(x)))\nFilter(function(x) !is.numeric(x), mtcars)\nintegrate(function(x) sin(x) ^ 2, 0, pi)\nfuns <- list(\n  half = function(x) x / 2,\n  double = function(x) x * 2\n)\n\nfuns$double(10)\n#> [1] 20"},{"path":"functions.html","id":"invoking-a-function","chapter":"6 Functions","heading":"6.2.4 Invoking a function","text":"normally call function placing arguments, wrapped parentheses, name: mean(1:10, na.rm = TRUE). happens arguments already data structure?can instead use .call(): two arguments. function call, list containing function arguments:’ll come back idea Section 19.6.","code":"\nargs <- list(1:10, na.rm = TRUE)\ndo.call(mean, args)\n#> [1] 5.5"},{"path":"functions.html","id":"exercises-14","chapter":"6 Functions","heading":"6.2.5 Exercises","text":"Given name, like \"mean\", match.fun() lets find function.\nGiven function, can find name? doesn’t make sense R?Given name, like \"mean\", match.fun() lets find function.\nGiven function, can find name? doesn’t make sense R?’s possible (although typically useful) call anonymous function.\ntwo approaches correct? ?\n\nfunction(x) 3()\n#> function(x) 3()\n(function(x) 3)()\n#> [1] 3It’s possible (although typically useful) call anonymous function.\ntwo approaches correct? ?good rule thumb anonymous function fit one line\nshouldn’t need use {}. Review code. \nused anonymous function instead named function? \nused named function instead anonymous function?good rule thumb anonymous function fit one line\nshouldn’t need use {}. Review code. \nused anonymous function instead named function? \nused named function instead anonymous function?function allows tell object function? function\nallows tell function primitive function?function allows tell object function? function\nallows tell function primitive function?code makes list functions base package.\n\nobjs <- mget(ls(\"package:base\", = TRUE), inherits = TRUE)\nfuns <- Filter(.function, objs)\nUse answer following questions:\nbase function arguments?\nmany base functions arguments? ’s special \nfunctions?\nadapt code find primitive functions?\ncode makes list functions base package.Use answer following questions:base function arguments?base function arguments?many base functions arguments? ’s special \nfunctions?many base functions arguments? ’s special \nfunctions?adapt code find primitive functions?adapt code find primitive functions?three important components function?three important components function?printing function show environment created ?printing function show environment created ?","code":"\nfunction(x) 3()\n#> function(x) 3()\n(function(x) 3)()\n#> [1] 3\nobjs <- mget(ls(\"package:base\", all = TRUE), inherits = TRUE)\nfuns <- Filter(is.function, objs)"},{"path":"functions.html","id":"function-composition","chapter":"6 Functions","heading":"6.3 Function composition","text":"\n\n\nBase R provides two ways compose multiple function calls. example, imagine want compute population standard deviation using sqrt() mean() building blocks:either nest function calls:save intermediate results variables:magrittr package35 provides third option: binary operator %>%, called pipe pronounced “.”x %>% f() equivalent f(x); x %>% f(y) equivalent f(x, y). pipe allows focus high-level composition functions rather low-level flow data; focus ’s done (verbs), rather ’s modified (nouns). style common Haskell F#, main inspiration magrittr, default style stack based programming languages like Forth Factor.three options strengths weaknesses:Nesting, f(g(x)), concise, well suited short sequences. \nlonger sequences hard read read inside \nright left. result, arguments can get spread long distances\ncreating Dagwood\nsandwich problem.Nesting, f(g(x)), concise, well suited short sequences. \nlonger sequences hard read read inside \nright left. result, arguments can get spread long distances\ncreating Dagwood\nsandwich problem.Intermediate objects, y <- f(x); g(y), requires name intermediate\nobjects. strength objects important, weakness \nvalues truly intermediate.Intermediate objects, y <- f(x); g(y), requires name intermediate\nobjects. strength objects important, weakness \nvalues truly intermediate.Piping, x %>% f() %>% g(), allows read code straightforward\nleft--right fashion doesn’t require name intermediate objects.\ncan use linear sequences transformations single\nobject. also requires additional third party package assumes \nreader understands piping.Piping, x %>% f() %>% g(), allows read code straightforward\nleft--right fashion doesn’t require name intermediate objects.\ncan use linear sequences transformations single\nobject. also requires additional third party package assumes \nreader understands piping.code use combination three styles. Piping common data analysis code, much analysis consists sequence transformations object (like data frame plot). tend use piping infrequently packages; bad idea, ’s often less natural fit.","code":"\nsquare <- function(x) x^2\ndeviation <- function(x) x - mean(x)\nx <- runif(100)\n\nsqrt(mean(square(deviation(x))))\n#> [1] 0.274\nout <- deviation(x)\nout <- square(out)\nout <- mean(out)\nout <- sqrt(out)\nout\n#> [1] 0.274\nlibrary(magrittr)\n\nx %>%\n  deviation() %>%\n  square() %>%\n  mean() %>%\n  sqrt()\n#> [1] 0.274"},{"path":"functions.html","id":"lexical-scoping","chapter":"6 Functions","heading":"6.4 Lexical scoping","text":"Chapter 2, discussed assignment, act binding name value. ’ll discuss scoping, act finding value associated name.basic rules scoping quite intuitive, ’ve probably already internalised , even never explicitly studied . example, following code return, 10 20?36In section, ’ll learn formal rules scoping well subtle details. deeper understanding scoping help use advanced functional programming tools, eventually, even write tools translate R code languages.R uses lexical scoping37: looks values names based function defined, called. “Lexical” English adjective means relating words vocabulary. ’s technical CS term tells us scoping rules use parse-time, rather run-time structure.R’s lexical scoping follows four primary rules:Name maskingFunctions versus variablesA fresh startDynamic lookup","code":"\nx <- 10\ng01 <- function() {\n  x <- 20\n  x\n}\n\ng01()"},{"path":"functions.html","id":"name-masking","chapter":"6 Functions","heading":"6.4.1 Name masking","text":"basic principle lexical scoping names defined inside function mask names defined outside function. illustrated following example.name isn’t defined inside function, R looks one level .rules apply function defined inside another function. First, R looks inside current function. , looks function defined (, way global environment). Finally, looks loaded packages.Run following code head, confirm result running code.38The rules also apply functions created functions, call manufactured functions, topic Chapter 10.","code":"\nx <- 10\ny <- 20\ng02 <- function() {\n  x <- 1\n  y <- 2\n  c(x, y)\n}\ng02()\n#> [1] 1 2\nx <- 2\ng03 <- function() {\n  y <- 1\n  c(x, y)\n}\ng03()\n#> [1] 2 1\n\n# And this doesn't change the previous value of y\ny\n#> [1] 20\nx <- 1\ng04 <- function() {\n  y <- 2\n  i <- function() {\n    z <- 3\n    c(x, y, z)\n  }\n  i()\n}\ng04()"},{"path":"functions.html","id":"functions-versus-variables","chapter":"6 Functions","heading":"6.4.2 Functions versus variables","text":"R, functions ordinary objects. means scoping rules described also apply functions:However, function non-function share name (must, course, reside different environments), applying rules gets little complicated. use name function call, R ignores non-function objects looking value. example, code , g09 takes two different values:record, using name different things confusing best avoided!","code":"\ng07 <- function(x) x + 1\ng08 <- function() {\n  g07 <- function(x) x + 100\n  g07(10)\n}\ng08()\n#> [1] 110\ng09 <- function(x) x + 100\ng10 <- function() {\n  g09 <- 10\n  g09(g09)\n}\ng10()\n#> [1] 110"},{"path":"functions.html","id":"fresh-start","chapter":"6 Functions","heading":"6.4.3 A fresh start","text":"happens values invocations function? Consider example . happen first time run function? happen second time?39 (haven’t seen exists() , returns TRUE ’s variable name returns FALSE .)might surprised g11() always returns value. happens every time function called new environment created host execution. means function way tell happened last time run; invocation completely independent. ’ll see ways get around Section 10.2.4.","code":"\ng11 <- function() {\n  if (!exists(\"a\")) {\n    a <- 1\n  } else {\n    a <- a + 1\n  }\n  a\n}\n\ng11()\ng11()"},{"path":"functions.html","id":"dynamic-lookup","chapter":"6 Functions","heading":"6.4.4 Dynamic lookup","text":"Lexical scoping determines , look values. R looks values function run, function created. Together, two properties tell us output function can differ depending objects outside function’s environment:behaviour can quite annoying. make spelling mistake code, won’t get error message create function. depending variables defined global environment, might even get error message run function.detect problem, use codetools::findGlobals(). function lists external dependencies (unbound symbols) within function:solve problem, can manually change function’s environment emptyenv(), environment contains nothing:problem solution reveal seemingly undesirable behaviour exists: R relies lexical scoping find everything, obvious, like mean(), less obvious, like + even {. gives R’s scoping rules rather beautiful simplicity.","code":"\ng12 <- function() x + 1\nx <- 15\ng12()\n#> [1] 16\n\nx <- 20\ng12()\n#> [1] 21\ncodetools::findGlobals(g12)\n#> [1] \"+\" \"x\"\nenvironment(g12) <- emptyenv()\ng12()\n#> Error in x + 1: no se pudo encontrar la función \"+\""},{"path":"functions.html","id":"exercises-15","chapter":"6 Functions","heading":"6.4.5 Exercises","text":"following code return? ? Describe three\nc’s interpreted.\n\nc <- 10\nc(c = c)following code return? ? Describe three\nc’s interpreted.four principles govern R looks values?four principles govern R looks values?following function return? Make prediction \nrunning code .\n\nf <- function(x) {\n  f <- function(x) {\n    f <- function() {\n      x ^ 2\n    }\n    f() + 1\n  }\n  f(x) * 2\n}\nf(10)following function return? Make prediction \nrunning code .","code":"\nc <- 10\nc(c = c)\nf <- function(x) {\n  f <- function(x) {\n    f <- function() {\n      x ^ 2\n    }\n    f() + 1\n  }\n  f(x) * 2\n}\nf(10)"},{"path":"functions.html","id":"lazy-evaluation","chapter":"6 Functions","heading":"6.5 Lazy evaluation","text":"\n\nR, function arguments lazily evaluated: ’re evaluated accessed. example, code doesn’t generate error x never used:important feature allows things like include potentially expensive computations function arguments evaluated needed.","code":"\nh01 <- function(x) {\n  10\n}\nh01(stop(\"This is an error!\"))\n#> [1] 10"},{"path":"functions.html","id":"promises","chapter":"6 Functions","heading":"6.5.1 Promises","text":"\nLazy evaluation powered data structure called promise, (less commonly) thunk. ’s one features makes R interesting programming language (’ll return promises Section 20.3).promise three components:expression, like x + y, gives rise delayed computation.expression, like x + y, gives rise delayed computation.environment expression evaluated, .e. \nenvironment function called. makes sure \nfollowing function returns 11, 101:\n\ny <- 10\nh02 <- function(x) {\n  y <- 100\n  x + 1\n}\n\nh02(y)\n#> [1] 11\nalso means assignment inside call function,\nvariable bound outside function, inside .\n\nh02(y <- 1000)\n#> [1] 1001\ny\n#> [1] 1000An environment expression evaluated, .e. \nenvironment function called. makes sure \nfollowing function returns 11, 101:also means assignment inside call function,\nvariable bound outside function, inside .value, computed cached first time promise \naccessed expression evaluated specified environment.\nensures promise evaluated , \nsee “Calculating…” printed following example.\n\ndouble <- function(x) { \n  message(\"Calculating...\")\n  x * 2\n}\n\nh03 <- function(x) {\n  c(x, x)\n}\n\nh03(double(20))\n#> Calculating...\n#> [1] 40 40A value, computed cached first time promise \naccessed expression evaluated specified environment.\nensures promise evaluated , \nsee “Calculating…” printed following example.manipulate promises R code. Promises like quantum state: attempt inspect R code force immediate evaluation, making promise disappear. Later, Section 20.3, ’ll learn quosures, convert promises R object can easily inspect expression environment.","code":"\ny <- 10\nh02 <- function(x) {\n  y <- 100\n  x + 1\n}\n\nh02(y)\n#> [1] 11\nh02(y <- 1000)\n#> [1] 1001\ny\n#> [1] 1000\ndouble <- function(x) { \n  message(\"Calculating...\")\n  x * 2\n}\n\nh03 <- function(x) {\n  c(x, x)\n}\n\nh03(double(20))\n#> Calculating...\n#> [1] 40 40"},{"path":"functions.html","id":"default-arguments","chapter":"6 Functions","heading":"6.5.2 Default arguments","text":"Thanks lazy evaluation, default values can defined terms arguments, even terms variables defined later function:Many base R functions use technique, don’t recommend . makes code harder understand: predict returned, need know exact order default arguments evaluated.evaluation environment slightly different default user supplied arguments, default arguments evaluated inside function. means seemingly identical calls can yield different results. ’s easiest see extreme example:","code":"\nh04 <- function(x = 1, y = x * 2, z = a + b) {\n  a <- 10\n  b <- 100\n  \n  c(x, y, z)\n}\n\nh04()\n#> [1]   1   2 110\nh05 <- function(x = ls()) {\n  a <- 1\n  x\n}\n\n# ls() evaluated inside h05:\nh05()\n#> [1] \"a\" \"x\"\n\n# ls() evaluated in global environment:\nh05(ls())\n#> [1] \"h05\""},{"path":"functions.html","id":"missing-arguments","chapter":"6 Functions","heading":"6.5.3 Missing arguments","text":"\ndetermine argument’s value comes user default, can use missing():missing() best used sparingly, however. Take sample(), example. many arguments required?looks like x size required, size supplied, sample() uses missing() provide default. rewrite sample, ’d use explicit NULL indicate size required can supplied:binary pattern created %||% infix function, uses left side ’s NULL right side otherwise, can simplify sample():\nlazy evaluation, don’t need worry unnecessary computation: right side %||% evaluated left side NULL.","code":"\nh06 <- function(x = 10) {\n  list(missing(x), x)\n}\nstr(h06())\n#> List of 2\n#>  $ : logi TRUE\n#>  $ : num 10\nstr(h06(10))\n#> List of 2\n#>  $ : logi FALSE\n#>  $ : num 10\nargs(sample)\n#> function (x, size, replace = FALSE, prob = NULL) \n#> NULL\nsample <- function(x, size = NULL, replace = FALSE, prob = NULL) {\n  if (is.null(size)) {\n    size <- length(x)\n  }\n  \n  x[sample.int(length(x), size, replace = replace, prob = prob)]\n}\n`%||%` <- function(lhs, rhs) {\n  if (!is.null(lhs)) {\n    lhs\n  } else {\n    rhs\n  }\n}\n\nsample <- function(x, size = NULL, replace = FALSE, prob = NULL) {\n  size <- size %||% length(x)\n  x[sample.int(length(x), size, replace = replace, prob = prob)]\n}"},{"path":"functions.html","id":"exercises-16","chapter":"6 Functions","heading":"6.5.4 Exercises","text":"important property && makes x_ok() work?\n\nx_ok <- function(x) {\n  !.null(x) && length(x) == 1 && x > 0\n}\n\nx_ok(NULL)\n#> [1] FALSE\nx_ok(1)\n#> [1] TRUE\nx_ok(1:3)\n#> [1] FALSE\ndifferent code? behaviour undesirable ?\n\nx_ok <- function(x) {\n  !.null(x) & length(x) == 1 & x > 0\n}\n\nx_ok(NULL)\n#> logical(0)\nx_ok(1)\n#> [1] TRUE\nx_ok(1:3)\n#> [1] FALSE FALSE FALSEWhat important property && makes x_ok() work?different code? behaviour undesirable ?function return? ? principle illustrate?\n\nf2 <- function(x = z) {\n  z <- 100\n  x\n}\nf2()function return? ? principle illustrate?function return? ? principle illustrate?\n\ny <- 10\nf1 <- function(x = {y <- 1; 2}, y = 0) {\n  c(x, y)\n}\nf1()\nyWhat function return? ? principle illustrate?hist(), default value xlim range(breaks), default\nvalue breaks \"Sturges\", \n\nrange(\"Sturges\")\n#> [1] \"Sturges\" \"Sturges\"\nExplain hist() works get correct xlim value.hist(), default value xlim range(breaks), default\nvalue breaks \"Sturges\", andExplain hist() works get correct xlim value.Explain function works. confusing?\n\nshow_time <- function(x = stop(\"Error!\")) {\n  stop <- function(...) Sys.time()\n  print(x)\n}\nshow_time()\n#> [1] \"2021-11-27 18:57:52 CST\"Explain function works. confusing?many arguments required calling library()?many arguments required calling library()?","code":"\nx_ok <- function(x) {\n  !is.null(x) && length(x) == 1 && x > 0\n}\n\nx_ok(NULL)\n#> [1] FALSE\nx_ok(1)\n#> [1] TRUE\nx_ok(1:3)\n#> [1] FALSE\nx_ok <- function(x) {\n  !is.null(x) & length(x) == 1 & x > 0\n}\n\nx_ok(NULL)\n#> logical(0)\nx_ok(1)\n#> [1] TRUE\nx_ok(1:3)\n#> [1] FALSE FALSE FALSE\nf2 <- function(x = z) {\n  z <- 100\n  x\n}\nf2()\ny <- 10\nf1 <- function(x = {y <- 1; 2}, y = 0) {\n  c(x, y)\n}\nf1()\ny\nrange(\"Sturges\")\n#> [1] \"Sturges\" \"Sturges\"\nshow_time <- function(x = stop(\"Error!\")) {\n  stop <- function(...) Sys.time()\n  print(x)\n}\nshow_time()\n#> [1] \"2021-11-27 18:57:52 CST\""},{"path":"functions.html","id":"fun-dot-dot-dot","chapter":"6 Functions","heading":"6.6 ... (dot-dot-dot)","text":"\n\nFunctions can special argument ... (pronounced dot-dot-dot). , function can take number additional arguments. programming languages, type argument often called varargs (short variable arguments), function uses said variadic.can also use ... pass additional arguments another function.Using special form, ..N, ’s possible (rarely useful) refer elements ... position:useful list(...), evaluates arguments stores list:(See also rlang::list2() support splicing silently ignore trailing commas, rlang::enquos() capture unevaluated arguments, topic quasiquotation.)two primary uses ..., ’ll come back later book:function takes function argument, want way \npass additional arguments function. example, lapply()\nuses ... pass na.rm mean():\n\nx <- list(c(1, 3, NA), c(4, NA, 6))\nstr(lapply(x, mean, na.rm = TRUE))\n#> List 2\n#>  $ : num 2\n#>  $ : num 5\n’ll come back technique Section 9.2.3.function takes function argument, want way \npass additional arguments function. example, lapply()\nuses ... pass na.rm mean():’ll come back technique Section 9.2.3.function S3 generic, need way allow methods \ntake arbitrary extra arguments. example, take print() function.\ndifferent options printing depending type \nobject, ’s way pre-specify every possible argument ...\nallows individual methods different arguments:\n\nprint(factor(letters), max.levels = 4)\n\nprint(y ~ x, showEnv = TRUE)\n’ll come back use ... Section 13.4.3.function S3 generic, need way allow methods \ntake arbitrary extra arguments. example, take print() function.\ndifferent options printing depending type \nobject, ’s way pre-specify every possible argument ...\nallows individual methods different arguments:’ll come back use ... Section 13.4.3.Using ... comes two downsides:use pass arguments another function, \ncarefully explain user arguments go. makes \nhard understand can functions like lapply() \nplot().use pass arguments another function, \ncarefully explain user arguments go. makes \nhard understand can functions like lapply() \nplot().misspelled argument raise error. makes easy \ntypos go unnoticed:\n\nsum(1, 2, NA, na_rm = TRUE)\n#> [1] NAA misspelled argument raise error. makes easy \ntypos go unnoticed:","code":"\ni01 <- function(y, z) {\n  list(y = y, z = z)\n}\n\ni02 <- function(x, ...) {\n  i01(...)\n}\n\nstr(i02(x = 1, y = 2, z = 3))\n#> List of 2\n#>  $ y: num 2\n#>  $ z: num 3\ni03 <- function(...) {\n  list(first = ..1, third = ..3)\n}\nstr(i03(1, 2, 3))\n#> List of 2\n#>  $ first: num 1\n#>  $ third: num 3\ni04 <- function(...) {\n  list(...)\n}\nstr(i04(a = 1, b = 2))\n#> List of 2\n#>  $ a: num 1\n#>  $ b: num 2\nx <- list(c(1, 3, NA), c(4, NA, 6))\nstr(lapply(x, mean, na.rm = TRUE))\n#> List of 2\n#>  $ : num 2\n#>  $ : num 5\nprint(factor(letters), max.levels = 4)\n\nprint(y ~ x, showEnv = TRUE)\nsum(1, 2, NA, na_rm = TRUE)\n#> [1] NA"},{"path":"functions.html","id":"exercises-17","chapter":"6 Functions","heading":"6.6.1 Exercises","text":"Explain following results:\n\nsum(1, 2, 3)\n#> [1] 6\nmean(1, 2, 3)\n#> [1] 1\n\nsum(1, 2, 3, na.omit = TRUE)\n#> [1] 7\nmean(1, 2, 3, na.omit = TRUE)\n#> [1] 1Explain following results:Explain find documentation named arguments \nfollowing function call:\n\nplot(1:10, col = \"red\", pch = 20, xlab = \"x\", col.lab = \"blue\")\nExplain find documentation named arguments \nfollowing function call:plot(1:10, col = \"red\") colour points, axes\nlabels? Read source code plot.default() find .plot(1:10, col = \"red\") colour points, axes\nlabels? Read source code plot.default() find .","code":"\nsum(1, 2, 3)\n#> [1] 6\nmean(1, 2, 3)\n#> [1] 1\n\nsum(1, 2, 3, na.omit = TRUE)\n#> [1] 7\nmean(1, 2, 3, na.omit = TRUE)\n#> [1] 1\nplot(1:10, col = \"red\", pch = 20, xlab = \"x\", col.lab = \"blue\")"},{"path":"functions.html","id":"exiting-a-function","chapter":"6 Functions","heading":"6.7 Exiting a function","text":"functions exit one two ways40: either return value, indicating success, throw error, indicating failure. section describes return values (implicit versus explicit; visible versus invisible), briefly discusses errors, introduces exit handlers, allow run code function exits.","code":""},{"path":"functions.html","id":"implicit-versus-explicit-returns","chapter":"6 Functions","heading":"6.7.1 Implicit versus explicit returns","text":"\ntwo ways function can return value:Implicitly, last evaluated expression return value:\n\nj01 <- function(x) {\n  (x < 10) {\n    0\n  } else {\n    10\n  }\n}\nj01(5)\n#> [1] 0\nj01(15)\n#> [1] 10Implicitly, last evaluated expression return value:Explicitly, calling return():\n\nj02 <- function(x) {\n  (x < 10) {\n    return(0)\n  } else {\n    return(10)\n  }\n}Explicitly, calling return():","code":"\nj01 <- function(x) {\n  if (x < 10) {\n    0\n  } else {\n    10\n  }\n}\nj01(5)\n#> [1] 0\nj01(15)\n#> [1] 10\nj02 <- function(x) {\n  if (x < 10) {\n    return(0)\n  } else {\n    return(10)\n  }\n}"},{"path":"functions.html","id":"invisible","chapter":"6 Functions","heading":"6.7.2 Invisible values","text":"\nfunctions return visibly: calling function interactive context prints result.However, can prevent automatic printing applying invisible() last value:verify value indeed exist, can explicitly print wrap parentheses:Alternatively, can use withVisible() return value visibility flag:common function returns invisibly <-:makes possible chain assignments:general, function called primarily side effect (like <-, print(), plot()) return invisible value (typically value first argument).","code":"\nj03 <- function() 1\nj03()\n#> [1] 1\nj04 <- function() invisible(1)\nj04()\nprint(j04())\n#> [1] 1\n\n(j04())\n#> [1] 1\nstr(withVisible(j04()))\n#> List of 2\n#>  $ value  : num 1\n#>  $ visible: logi FALSE\na <- 2\n(a <- 2)\n#> [1] 2\na <- b <- c <- d <- 2"},{"path":"functions.html","id":"errors","chapter":"6 Functions","heading":"6.7.3 Errors","text":"function complete assigned task, throw error stop(), immediately terminates execution function.error indicates something gone wrong, forces user deal problem. languages (like C, Go, Rust) rely special return values indicate problems, R always throw error. ’ll learn errors, handle , Chapter 8.","code":"\nj05 <- function() {\n  stop(\"I'm an error\")\n  return(10)\n}\nj05()\n#> Error in j05(): I'm an error"},{"path":"functions.html","id":"on-exit","chapter":"6 Functions","heading":"6.7.4 Exit handlers","text":"Sometimes function needs make temporary changes global state. cleanup changes can painful (happens ’s error?). ensure changes undone global state restored matter function exits, use .exit() set exit handler. following simple example shows exit handler run regardless whether function exits normally error.Always set add = TRUE using .exit(). don’t, call .exit() overwrite previous exit handler. Even registering single handler, ’s good practice set add = TRUE won’t get unpleasant surprises later add exit handlers..exit() useful allows place clean-code directly next code requires clean-:Coupled lazy evaluation, creates useful pattern running block code altered environment:use force() isn’t strictly necessary simply referring code force evaluation. However, using force() makes clear deliberately forcing execution. ’ll learn uses force() Chapter 10.withr package41 provides collection functions setting temporary state.R 3.4 earlier, .exit() expressions always run order creation:can make cleanup little tricky actions need happen specific order; typically want recent added expression run first. R 3.5 later, can control setting = FALSE:","code":"\nj06 <- function(x) {\n  cat(\"Hello\\n\")\n  on.exit(cat(\"Goodbye!\\n\"), add = TRUE)\n  \n  if (x) {\n    return(10)\n  } else {\n    stop(\"Error\")\n  }\n}\n\nj06(TRUE)\n#> Hello\n#> Goodbye!\n#> [1] 10\n\nj06(FALSE)\n#> Hello\n#> Error in j06(FALSE): Error\n#> Goodbye!\ncleanup <- function(dir, code) {\n  old_dir <- setwd(dir)\n  on.exit(setwd(old_dir), add = TRUE)\n  \n  old_opt <- options(stringsAsFactors = FALSE)\n  on.exit(options(old_opt), add = TRUE)\n}\nwith_dir <- function(dir, code) {\n  old <- setwd(dir)\n  on.exit(setwd(old), add = TRUE)\n\n  force(code)\n}\n\ngetwd()\n#> [1] \"C:/Users/Jeshua/Downloads/MEGA/Bookdown/@ R_avanzado\"\nwith_dir(\"~\", getwd())\n#> [1] \"C:/Users/Jeshua/Documents\"\nj08 <- function() {\n  on.exit(message(\"a\"), add = TRUE)\n  on.exit(message(\"b\"), add = TRUE)\n}\nj08()\n#> a\n#> b\nj09 <- function() {\n  on.exit(message(\"a\"), add = TRUE, after = FALSE)\n  on.exit(message(\"b\"), add = TRUE, after = FALSE)\n}\nj09()\n#> b\n#> a"},{"path":"functions.html","id":"exercises-18","chapter":"6 Functions","heading":"6.7.5 Exercises","text":"load() return? don’t normally see values?load() return? don’t normally see values?write.table() return? useful?write.table() return? useful?chdir parameter source() compare with_dir()? \nmight prefer one ?chdir parameter source() compare with_dir()? \nmight prefer one ?Write function opens graphics device, runs supplied code, \ncloses graphics device (always, regardless whether \nplotting code works).Write function opens graphics device, runs supplied code, \ncloses graphics device (always, regardless whether \nplotting code works).can use .exit() implement simple version capture.output().\n\ncapture.output2 <- function(code) {\n  temp <- tempfile()\n  .exit(file.remove(temp), add = TRUE, = TRUE)\n\n  sink(temp)\n  .exit(sink(), add = TRUE, = TRUE)\n\n  force(code)\n  readLines(temp)\n}\ncapture.output2(cat(\"\", \"b\", \"c\", sep = \"\\n\"))\n#> Warning file.remove(temp): fue posible abrir el archivo 'C:\n#> \\Users\\Jeshua\\AppData\\Local\\Temp\\RtmpKoQl1C\\file1ce859bf12de', motivo\n#> 'Permission denied'\n#> [1] \"\" \"b\" \"c\"\nCompare capture.output() capture.output2(). functions\ndiffer? features removed make key ideas easier see?\nrewritten key ideas ’re easier understand?can use .exit() implement simple version capture.output().Compare capture.output() capture.output2(). functions\ndiffer? features removed make key ideas easier see?\nrewritten key ideas ’re easier understand?","code":"\ncapture.output2 <- function(code) {\n  temp <- tempfile()\n  on.exit(file.remove(temp), add = TRUE, after = TRUE)\n\n  sink(temp)\n  on.exit(sink(), add = TRUE, after = TRUE)\n\n  force(code)\n  readLines(temp)\n}\ncapture.output2(cat(\"a\", \"b\", \"c\", sep = \"\\n\"))\n#> Warning in file.remove(temp): no fue posible abrir el archivo 'C:\n#> \\Users\\Jeshua\\AppData\\Local\\Temp\\RtmpKoQl1C\\file1ce859bf12de', motivo\n#> 'Permission denied'\n#> [1] \"a\" \"b\" \"c\""},{"path":"functions.html","id":"function-forms","chapter":"6 Functions","heading":"6.8 Function forms","text":"understand computations R, two slogans helpful:Everything exists object.Everything happens function call.— John ChambersWhile everything happens R result function call, calls look . Function calls come four varieties:prefix: function name comes arguments, like\nfoofy(, b, c). constitute majority function calls R.prefix: function name comes arguments, like\nfoofy(, b, c). constitute majority function calls R.infix: function name comes arguments, like\nx + y. Infix forms used many mathematical operators, \nuser-defined functions begin end %.infix: function name comes arguments, like\nx + y. Infix forms used many mathematical operators, \nuser-defined functions begin end %.replacement: functions replace values assignment, like\nnames(df) <- c(\"\", \"b\", \"c\"). actually look like prefix functions.replacement: functions replace values assignment, like\nnames(df) <- c(\"\", \"b\", \"c\"). actually look like prefix functions.special: functions like [[, , . don’t \nconsistent structure, play important roles R’s syntax.special: functions like [[, , . don’t \nconsistent structure, play important roles R’s syntax.four forms, actually need one call can written prefix form. ’ll demonstrate property, ’ll learn forms turn.","code":""},{"path":"functions.html","id":"prefix-transform","chapter":"6 Functions","heading":"6.8.1 Rewriting to prefix form","text":"\n\ninteresting property R every infix, replacement, special form can rewritten prefix form. useful helps better understand structure language, gives real name every function, allows modify functions fun profit.following example shows three pairs equivalent calls, rewriting infix form, replacement form, special form prefix form.Suprisingly, R, can called like regular function! true basically every operation R, means knowing function name non-prefix function allows override behaviour. example, ’re ever feeling particularly evil, run following code friend away computer. introduce fun bug: 10% time, add 1 numeric calculation inside parentheses.course, overriding built-functions like bad idea, , ’ll learn Section 21.2.5, ’s possible apply selected code blocks. provides clean elegant approach writing domain specific languages translators languages.useful application comes using functional programming tools. example, use lapply() add 3 every element list first defining function add():can also get result simply relying existing + function:’ll explore idea detail Section 9.","code":"\nx + y\n`+`(x, y)\n\nnames(df) <- c(\"x\", \"y\", \"z\")\n`names<-`(df, c(\"x\", \"y\", \"z\"))\n\nfor(i in 1:10) print(i)\n`for`(i, 1:10, print(i))\n`(` <- function(e1) {\n  if (is.numeric(e1) && runif(1) < 0.1) {\n    e1 + 1\n  } else {\n    e1\n  }\n}\nreplicate(50, (1 + 2))\n#>  [1] 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n#> [39] 4 3 4 3 3 3 3 4 3 3 3 3\nrm(\"(\")\nadd <- function(x, y) x + y\nlapply(list(1:3, 4:5), add, 3)\n#> [[1]]\n#> [1] 4 5 6\n#> \n#> [[2]]\n#> [1] 7 8\nlapply(list(1:3, 4:5), `+`, 3)\n#> [[1]]\n#> [1] 4 5 6\n#> \n#> [[2]]\n#> [1] 7 8"},{"path":"functions.html","id":"prefix-form","chapter":"6 Functions","heading":"6.8.2 Prefix form","text":"\nprefix form common form R code, indeed majority programming languages. Prefix calls R little special can specify arguments three ways:position, like help(mean).Using partial matching, like help(top = mean).name, like help(topic = mean).illustrated following chunk, arguments matched exact name, unique prefixes, finally position.general, use positional matching first one two arguments; commonly used, readers know . Avoid using positional matching less commonly used arguments, never use partial matching. Unfortunately can’t disable partial matching, can turn warning warnPartialMatchArgs option:\n","code":"\nk01 <- function(abcdef, bcde1, bcde2) {\n  list(a = abcdef, b1 = bcde1, b2 = bcde2)\n}\nstr(k01(1, 2, 3))\n#> List of 3\n#>  $ a : num 1\n#>  $ b1: num 2\n#>  $ b2: num 3\nstr(k01(2, 3, abcdef = 1))\n#> List of 3\n#>  $ a : num 1\n#>  $ b1: num 2\n#>  $ b2: num 3\n\n# Can abbreviate long argument names:\nstr(k01(2, 3, a = 1))\n#> List of 3\n#>  $ a : num 1\n#>  $ b1: num 2\n#>  $ b2: num 3\n\n# But this doesn't work because abbreviation is ambiguous\nstr(k01(1, 3, b = 1))\n#> Error in k01(1, 3, b = 1): el argumento 3 concuerda con multiples argumentos formales\noptions(warnPartialMatchArgs = TRUE)\nx <- k01(a = 1, 2, 3)\n#> Warning in k01(a = 1, 2, 3): argumentos parcialmente correctos de 'a' a 'abcdef'"},{"path":"functions.html","id":"infix-functions","chapter":"6 Functions","heading":"6.8.3 Infix functions","text":"\n\nInfix functions get name fact function name comes inbetween arguments, hence two arguments. R comes number built-infix operators: :, ::, :::, $, @, ^, *, /, +, -, >, >=, <, <=, ==, !=, !, &, &&, |, ||, ~, <-, <<-. can also create infix functions start end %. Base R uses pattern define %%, %*%, %/%, %%, %o%, %x%.Defining infix function simple. create two argument function bind name starts ends %:names infix functions flexible regular R functions: can contain sequence characters except %. need escape special characters string used define function, call :R’s default precedence rules mean infix operators composed left right:two special infix functions can called single argument: + -.","code":"\n`%+%` <- function(a, b) paste0(a, b)\n\"new \" %+% \"string\"\n#> [1] \"new string\"\n`% %` <- function(a, b) paste(a, b)\n`%/\\\\%` <- function(a, b) paste(a, b)\n\n\"a\" % % \"b\"\n#> [1] \"a b\"\n\"a\" %/\\% \"b\"\n#> [1] \"a b\"\n`%-%` <- function(a, b) paste0(\"(\", a, \" %-% \", b, \")\")\n\"a\" %-% \"b\" %-% \"c\"\n#> [1] \"((a %-% b) %-% c)\"\n-1\n#> [1] -1\n+10\n#> [1] 10"},{"path":"functions.html","id":"replacement-functions","chapter":"6 Functions","heading":"6.8.4 Replacement functions","text":"\n\nReplacement functions act like modify arguments place, special name xxx<-. must arguments named x value, must return modified object. example, following function modifies second element vector:Replacement functions used placing function call left side <-:say act like modify arguments place, , explained Section 2.5, actually create modified copy. can see using tracemem():replacement function needs additional arguments, place x value, call replacement function additional arguments left:write modify(x, 1) <- 10, behind scenes R turns :Combining replacement functions requires complex translation. example:translated :(Yes, really create local variable named *tmp*, removed afterwards.)","code":"\n`second<-` <- function(x, value) {\n  x[2] <- value\n  x\n}\nx <- 1:10\nsecond(x) <- 5L\nx\n#>  [1]  1  5  3  4  5  6  7  8  9 10\nx <- 1:10\ntracemem(x)\n#> <0x7ffae71bd880>\n\nsecond(x) <- 6L\n#> tracemem[0x7ffae71bd880 -> 0x7ffae61b5480]: \n#> tracemem[0x7ffae61b5480 -> 0x7ffae73f0408]: second<- \n`modify<-` <- function(x, position, value) {\n  x[position] <- value\n  x\n}\nmodify(x, 1) <- 10\nx\n#>  [1] 10  5  3  4  5  6  7  8  9 10\nx <- `modify<-`(x, 1, 10)\nx <- c(a = 1, b = 2, c = 3)\nnames(x)\n#> [1] \"a\" \"b\" \"c\"\n\nnames(x)[2] <- \"two\"\nnames(x)\n#> [1] \"a\"   \"two\" \"c\"\n`*tmp*` <- x\nx <- `names<-`(`*tmp*`, `[<-`(names(`*tmp*`), 2, \"two\"))\nrm(`*tmp*`)"},{"path":"functions.html","id":"special-forms","chapter":"6 Functions","heading":"6.8.5 Special forms","text":"\nFinally, bunch language features usually written special ways, also prefix forms. include parentheses:(x) (`(`(x)){x} (`{`(x)).subsetting operators:x[] (`[`(x, ))x[[]] (`[[`(x, ))tools control flow:(cond) true (``(cond, true))(cond) true else false (``(cond, true, false))(var seq) action (``(var, seq, action))(cond) action (``(cond, action))repeat expr (`repeat`(expr))next (`next`())break (`break`())Finally, complex function function:function(arg1, arg2) {body} (`function`(alist(arg1, arg2), body, env))Knowing name function underlies special form useful getting documentation: ?( syntax error; ?`(` give documentation parentheses.special forms implemented primitive functions (.e. C); means printing functions informative:","code":"\n`for`\n#> .Primitive(\"for\")"},{"path":"functions.html","id":"exercises-19","chapter":"6 Functions","heading":"6.8.6 Exercises","text":"Rewrite following code snippets prefix form:\n\n1 + 2 + 3\n\n1 + (2 + 3)\n\n(length(x) <= 5) x[[5]] else x[[n]]Rewrite following code snippets prefix form:Clarify following list odd function calls:\n\nx <- sample(replace = TRUE, 20, x = c(1:10, NA))\ny <- runif(min = 0, max = 1, 20)\ncor(m = \"k\", y = y, u = \"p\", x = x)Clarify following list odd function calls:Explain following code fails:\n\nmodify(get(\"x\"), 1) <- 10\n#> Error: target assignment expands non-language objectExplain following code fails:Create replacement function modifies random location vector.Create replacement function modifies random location vector.Write version + pastes inputs together \ncharacter vectors behaves usual otherwise. words, make \ncode work:\n\n1 + 2\n#> [1] 3\n\n\"\" + \"b\"\n#> [1] \"ab\"Write version + pastes inputs together \ncharacter vectors behaves usual otherwise. words, make \ncode work:Create list replacement functions found base package.\nones primitive functions? (Hint: use apropos().)Create list replacement functions found base package.\nones primitive functions? (Hint: use apropos().)valid names user-created infix functions?valid names user-created infix functions?Create infix xor() operator.Create infix xor() operator.Create infix versions set functions intersect(), union(), \nsetdiff(). might call %n%, %u%, %/% match\nconventions mathematics.Create infix versions set functions intersect(), union(), \nsetdiff(). might call %n%, %u%, %/% match\nconventions mathematics.","code":"\n1 + 2 + 3\n\n1 + (2 + 3)\n\nif (length(x) <= 5) x[[5]] else x[[n]]\nx <- sample(replace = TRUE, 20, x = c(1:10, NA))\ny <- runif(min = 0, max = 1, 20)\ncor(m = \"k\", y = y, u = \"p\", x = x)\nmodify(get(\"x\"), 1) <- 10\n#> Error: target of assignment expands to non-language object\n1 + 2\n#> [1] 3\n\n\"a\" + \"b\"\n#> [1] \"ab\""},{"path":"functions.html","id":"function-answers","chapter":"6 Functions","heading":"6.9 Quiz answers","text":"three components function body, arguments, environment.three components function body, arguments, environment.f1(1)() returns 11.f1(1)() returns 11.’d normally write infix style: 1 + (2 * 3).’d normally write infix style: 1 + (2 * 3).Rewriting call mean(c(1:10, NA), na.rm = TRUE) easier \nunderstand.Rewriting call mean(c(1:10, NA), na.rm = TRUE) easier \nunderstand., throw error second argument never used\n’s never evaluated., throw error second argument never used\n’s never evaluated.See Sections 6.8.3 6.8.4.See Sections 6.8.3 6.8.4.use .exit(); see Section 6.7.4 details.use .exit(); see Section 6.7.4 details.","code":""},{"path":"environments.html","id":"environments","chapter":"7 Environments","heading":"7 Environments","text":"","code":""},{"path":"environments.html","id":"introduction-6","chapter":"7 Environments","heading":"7.1 Introduction","text":"environment data structure powers scoping. chapter dives deep environments, describing structure depth, using improve understanding four scoping rules described Section 6.4.\nUnderstanding environments necessary day--day use R. important understand power many important R features like lexical scoping, namespaces, R6 classes, interact evaluation give powerful tools making domain specific languages, like dplyr ggplot2.","code":""},{"path":"environments.html","id":"quiz-5","chapter":"7 Environments","heading":"Quiz","text":"can answer following questions correctly, already know important topics chapter. can find answers end chapter Section 7.7.List least three ways environment differs list.List least three ways environment differs list.parent global environment? \nenvironment doesn’t parent?parent global environment? \nenvironment doesn’t parent?enclosing environment function? \nimportant?enclosing environment function? \nimportant?determine environment function called?determine environment function called?<- <<- different?<- <<- different?","code":""},{"path":"environments.html","id":"outline-5","chapter":"7 Environments","heading":"Outline","text":"Section 7.2 introduces basic properties\nenvironment shows create .Section 7.2 introduces basic properties\nenvironment shows create .Section 7.3 provides function template\ncomputing environments, illustrating idea useful\nfunction.Section 7.3 provides function template\ncomputing environments, illustrating idea useful\nfunction.Section 7.4 describes environments used special\npurposes: packages, within functions, namespaces, \nfunction execution.Section 7.4 describes environments used special\npurposes: packages, within functions, namespaces, \nfunction execution.Section 7.5 explains last important environment: \ncaller environment. requires learn call stack,\ndescribes function called. ’ll seen call stack\n’ve ever called traceback() aid debugging.Section 7.5 explains last important environment: \ncaller environment. requires learn call stack,\ndescribes function called. ’ll seen call stack\n’ve ever called traceback() aid debugging.Section 7.6 briefly discusses three places \nenvironments useful data structures solving problems.Section 7.6 briefly discusses three places \nenvironments useful data structures solving problems.","code":""},{"path":"environments.html","id":"prerequisites-1","chapter":"7 Environments","heading":"Prerequisites","text":"chapter use rlang functions working environments, allows us focus essence environments, rather incidental details.env_ functions rlang designed work pipe: take environment first argument, many also return environment. won’t use pipe chapter interest keeping code simple possible, consider code.","code":"\nlibrary(rlang)"},{"path":"environments.html","id":"env-basics","chapter":"7 Environments","heading":"7.2 Environment basics","text":"Generally, environment similar named list, four important exceptions:Every name must unique.Every name must unique.names environment ordered.names environment ordered.environment parent.environment parent.Environments copied modified.Environments copied modified.Let’s explore ideas code pictures.","code":""},{"path":"environments.html","id":"basics","chapter":"7 Environments","heading":"7.2.1 Basics","text":"\n\n\ncreate environment, use rlang::env(). works like list(), taking set name-value pairs:Use new.env() create new environment. Ignore hash size parameters; needed. simultaneously create define values; use $<-, shown .job environment associate, bind, set names set values. can think environment bag names, implied order (.e. doesn’t make sense ask first element environment). reason, ’ll draw environment :discussed Section 2.5.2, environments reference semantics: unlike R objects, modify , modify place, don’t create copy. One important implication environments can contain .Printing environment just displays memory address, terribly useful:Instead, ’ll use env_print() gives us little information:can use env_names() get character vector giving current bindingsIn R 3.2.0 greater, use names() list bindings environment. code needs work R 3.1.0 earlier, use ls(), note ’ll need set .names = TRUE show bindings.","code":"\ne1 <- env(\n  a = FALSE,\n  b = \"a\",\n  c = 2.3,\n  d = 1:3,\n)\ne1$d <- e1\ne1\n#> <environment: 0x000000002333a5d8>\nenv_print(e1)\n#> <environment: 000000002333A5D8>\n#> parent: <environment: global>\n#> bindings:\n#>  * a: <lgl>\n#>  * b: <chr>\n#>  * c: <dbl>\n#>  * d: <env>\nenv_names(e1)\n#> [1] \"a\" \"b\" \"c\" \"d\""},{"path":"environments.html","id":"important-environments","chapter":"7 Environments","heading":"7.2.2 Important environments","text":"\n’ll talk detail special environments 7.4, now need mention two. current environment, current_env() environment code currently executing. ’re experimenting interactively, ’s usually global environment, global_env(). global environment sometimes called “workspace,” ’s interactive (.e. outside function) computation takes place.compare environments, need use identical() ==. == vectorised operator, environments vectors.Access global environment globalenv() current environment environment(). global environment printed R_GlobalEnv .GlobalEnv.","code":"\nidentical(global_env(), current_env())\n#> [1] TRUE\n\nglobal_env() == current_env()\n#> Error in global_env() == current_env(): comparación  (1) es posible solo para tipos lista y atómico"},{"path":"environments.html","id":"parents","chapter":"7 Environments","heading":"7.2.3 Parents","text":"\nEvery environment parent, another environment. diagrams, parent shown small pale blue circle arrow points another environment. parent ’s used implement lexical scoping: name found environment, R look parent (). can set parent environment supplying unnamed argument env(). don’t supply , defaults current environment. code , e2a parent e2b.save space, typically won’t draw ancestors; just remember whenever see pale blue circle, ’s parent environment somewhere.can find parent environment env_parent():one environment doesn’t parent: empty environment. draw empty environment hollow parent environment, space allows ’ll label R_EmptyEnv, name R uses.ancestors every environment eventually terminate empty environment. can see ancestors env_parents():default, env_parents() stops gets global environment. useful ancestors global environment include every attached package, can see override default behaviour . ’ll come back environments Section 7.4.1.Use parent.env() find parent environment. base function returns ancestors.","code":"\ne2a <- env(d = 4, e = 5)\ne2b <- env(e2a, a = 1, b = 2, c = 3)\nenv_parent(e2b)\n#> <environment: 0x00000000224dd690>\nenv_parent(e2a)\n#> <environment: R_GlobalEnv>\ne2c <- env(empty_env(), d = 4, e = 5)\ne2d <- env(e2c, a = 1, b = 2, c = 3)\nenv_parents(e2b)\n#> [[1]]   <env: 00000000224DD690>\n#> [[2]] $ <env: global>\nenv_parents(e2d)\n#> [[1]]   <env: 0000000022C689B0>\n#> [[2]] $ <env: empty>\nenv_parents(e2b, last = empty_env())\n#>  [[1]]   <env: 00000000224DD690>\n#>  [[2]] $ <env: global>\n#>  [[3]] $ <env: package:rlang>\n#>  [[4]] $ <env: package:stats>\n#>  [[5]] $ <env: package:graphics>\n#>  [[6]] $ <env: package:grDevices>\n#>  [[7]] $ <env: package:utils>\n#>  [[8]] $ <env: package:datasets>\n#>  [[9]] $ <env: package:methods>\n#> [[10]] $ <env: Autoloads>\n#> [[11]] $ <env: package:base>\n#> [[12]] $ <env: empty>"},{"path":"environments.html","id":"super-assignment--","chapter":"7 Environments","heading":"7.2.4 Super assignment, <<-","text":"\nancestors environment important relationship <<-. Regular assignment, <-, always creates variable current environment. Super assignment, <<-, never creates variable current environment, instead modifies existing variable found parent environment.<<- doesn’t find existing variable, create one global environment. usually undesirable, global variables introduce non-obvious dependencies functions. <<- often used conjunction function factory, described Section 10.2.4.","code":"\nx <- 0\nf <- function() {\n  x <<- 1\n}\nf()\nx\n#> [1] 1"},{"path":"environments.html","id":"getting-and-setting-1","chapter":"7 Environments","heading":"7.2.5 Getting and setting","text":"\ncan get set elements environment $ [[ way list:can’t use [[ numeric indices, can’t use [:$ [[ return NULL binding doesn’t exist. Use env_get() want error:want use default value binding doesn’t exist, can use default argument.two ways add bindings environment:env_poke()42 takes name (string) value:\n\nenv_poke(e3, \"\", 100)\ne3$\n#> [1] 100env_poke()42 takes name (string) value:env_bind() allows bind multiple values:\n\nenv_bind(e3, = 10, b = 20)\nenv_names(e3)\n#> [1] \"x\" \"y\" \"z\" \"\" \"b\"env_bind() allows bind multiple values:can determine environment binding env_has():Unlike lists, setting element NULL remove , sometimes want name refers NULL. Instead, use env_unbind():Unbinding name doesn’t delete object. ’s job garbage collector, automatically removes objects names binding . process described detail Section 2.6.\nSee get(), assign(), exists(), rm(). designed interactively use current environment, working environments little clunky. Also beware inherits argument: defaults TRUE meaning base equivalents inspect supplied environment ancestors.","code":"\ne3 <- env(x = 1, y = 2)\ne3$x\n#> [1] 1\ne3$z <- 3\ne3[[\"z\"]]\n#> [1] 3\ne3[[1]]\n#> Error in e3[[1]]: argumentos incorrectos para obtención de subconjuntos de un ambiente\n\ne3[c(\"x\", \"y\")]\n#> Error in e3[c(\"x\", \"y\")]: objeto de tipo 'environment' no es subconjunto\ne3$xyz\n#> NULL\n\nenv_get(e3, \"xyz\")\n#> Error in env_get(e3, \"xyz\"): el argumento \"default\" está ausente, sin valor por omisión\nenv_get(e3, \"xyz\", default = NA)\n#> [1] NA\nenv_poke(e3, \"a\", 100)\ne3$a\n#> [1] 100\nenv_bind(e3, a = 10, b = 20)\nenv_names(e3)\n#> [1] \"x\" \"y\" \"z\" \"a\" \"b\"\nenv_has(e3, \"a\")\n#>    a \n#> TRUE\ne3$a <- NULL\nenv_has(e3, \"a\")\n#>    a \n#> TRUE\n\nenv_unbind(e3, \"a\")\nenv_has(e3, \"a\")\n#>     a \n#> FALSE"},{"path":"environments.html","id":"advanced-bindings","chapter":"7 Environments","heading":"7.2.6 Advanced bindings","text":"\n\n\n\ntwo exotic variants env_bind():env_bind_lazy() creates delayed bindings, evaluated \nfirst time accessed. Behind scenes, delayed bindings create\npromises, behave way function arguments.\n\nenv_bind_lazy(current_env(), b = {Sys.sleep(1); 1})\n\nsystem.time(print(b))\n#> [1] 1\n#>    user  system elapsed \n#>    0.00    0.00    1.03\nsystem.time(print(b))\n#> [1] 1\n#>    user  system elapsed \n#>       0       0       0\nprimary use delayed bindings autoload(), \nallows R packages provide datasets behave like loaded \nmemory, even though ’re loaded disk needed.env_bind_lazy() creates delayed bindings, evaluated \nfirst time accessed. Behind scenes, delayed bindings create\npromises, behave way function arguments.primary use delayed bindings autoload(), \nallows R packages provide datasets behave like loaded \nmemory, even though ’re loaded disk needed.env_bind_active() creates active bindings re-computed every\ntime ’re accessed:\n\nenv_bind_active(current_env(), z1 = function(val) runif(1))\n\nz1\n#> [1] 0.0808\nz1\n#> [1] 0.834\nActive bindings used implement R6’s active fields, ’ll learn\nSection 14.3.2.env_bind_active() creates active bindings re-computed every\ntime ’re accessed:Active bindings used implement R6’s active fields, ’ll learn\nSection 14.3.2.See ?delayedAssign() ?makeActiveBinding().","code":"\nenv_bind_lazy(current_env(), b = {Sys.sleep(1); 1})\n\nsystem.time(print(b))\n#> [1] 1\n#>    user  system elapsed \n#>    0.00    0.00    1.03\nsystem.time(print(b))\n#> [1] 1\n#>    user  system elapsed \n#>       0       0       0\nenv_bind_active(current_env(), z1 = function(val) runif(1))\n\nz1\n#> [1] 0.0808\nz1\n#> [1] 0.834"},{"path":"environments.html","id":"exercises-20","chapter":"7 Environments","heading":"7.2.7 Exercises","text":"List three ways environment differs list.List three ways environment differs list.Create environment illustrated picture.\nCreate environment illustrated picture.Create pair environments illustrated picture.\nCreate pair environments illustrated picture.Explain e[[1]] e[c(\"\", \"b\")] don’t make sense e \nenvironment.Explain e[[1]] e[c(\"\", \"b\")] don’t make sense e \nenvironment.Create version env_poke() bind new names, never\nre-bind old names. programming languages , known\nsingle assignment languages.Create version env_poke() bind new names, never\nre-bind old names. programming languages , known\nsingle assignment languages.function ? differ <<- \nmight prefer ?\n\nrebind <- function(name, value, env = caller_env()) {\n  (identical(env, empty_env())) {\n    stop(\"find `\", name, \"`\", call. = FALSE)\n  } else (env_has(env, name)) {\n    env_poke(env, name, value)\n  } else {\n    rebind(name, value, env_parent(env))\n  }\n}\nrebind(\"\", 10)\n#> Error: find ``\n<- 5\nrebind(\"\", 10)\n\n#> [1] 10What function ? differ <<- \nmight prefer ?","code":"\nrebind <- function(name, value, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    stop(\"Can't find `\", name, \"`\", call. = FALSE)\n  } else if (env_has(env, name)) {\n    env_poke(env, name, value)\n  } else {\n    rebind(name, value, env_parent(env))\n  }\n}\nrebind(\"a\", 10)\n#> Error: Can't find `a`\na <- 5\nrebind(\"a\", 10)\na\n#> [1] 10"},{"path":"environments.html","id":"env-recursion","chapter":"7 Environments","heading":"7.3 Recursing over environments","text":"want operate every ancestor environment, ’s often convenient write recursive function. section shows , applying new knowledge environments write function given name, finds environment () name defined, using R’s regular scoping rules.definition () straightforward. two arguments: name look (string), environment start search. (’ll learn caller_env() good default Section 7.5.)three cases:base case: ’ve reached empty environment haven’t found \nbinding. can’t go , throw error.base case: ’ve reached empty environment haven’t found \nbinding. can’t go , throw error.successful case: name exists environment, return \nenvironment.successful case: name exists environment, return \nenvironment.recursive case: name found environment, try \nparent.recursive case: name found environment, try \nparent.three cases illustrated three examples:might help see picture. Imagine two environments, following code diagram:(\"\", e4b) find e4b.(\"\", e4b) find e4b.(\"b\", e4b) doesn’t find b e4b, looks parent, e4a,\nfinds .(\"b\", e4b) doesn’t find b e4b, looks parent, e4a,\nfinds .(\"c\", e4b) looks e4b, e4a, hits empty environment\nthrows error.(\"c\", e4b) looks e4b, e4a, hits empty environment\nthrows error.’s natural work environments recursively, () provides useful template. Removing specifics () shows structure clearly:","code":"\nwhere <- function(name, env = caller_env()) {\n  if (identical(env, empty_env())) {\n    # Base case\n    stop(\"Can't find \", name, call. = FALSE)\n  } else if (env_has(env, name)) {\n    # Success case\n    env\n  } else {\n    # Recursive case\n    where(name, env_parent(env))\n  }\n}\nwhere(\"yyy\")\n#> Error: Can't find yyy\n\nx <- 5\nwhere(\"x\")\n#> <environment: R_GlobalEnv>\n\nwhere(\"mean\")\n#> <environment: base>\ne4a <- env(empty_env(), a = 1, b = 2)\ne4b <- env(e4a, x = 10, a = 11)\nf <- function(..., env = caller_env()) {\n  if (identical(env, empty_env())) {\n    # base case\n  } else if (success) {\n    # success case\n  } else {\n    # recursive case\n    f(..., env = env_parent(env))\n  }\n}"},{"path":"environments.html","id":"iteration-versus-recursion","chapter":"7 Environments","heading":"Iteration versus recursion","text":"’s possible use loop instead recursion. think ’s harder understand recursive version, include might find easier see ’s happening haven’t written many recursive functions.","code":"\nf2 <- function(..., env = caller_env()) {\n  while (!identical(env, empty_env())) {\n    if (success) {\n      # success case\n      return()\n    }\n    # inspect parent\n    env <- env_parent(env)\n  }\n\n  # base case\n}"},{"path":"environments.html","id":"exercises-21","chapter":"7 Environments","heading":"7.3.1 Exercises","text":"Modify () return environments contain binding \nname. Carefully think type object function \nneed return.Modify () return environments contain binding \nname. Carefully think type object function \nneed return.Write function called fget() finds function objects. \ntwo arguments, name env, obey regular\nscoping rules functions: ’s object matching name\n’s function, look parent. added challenge, also\nadd inherits argument controls whether function recurses \nparents looks one environment.Write function called fget() finds function objects. \ntwo arguments, name env, obey regular\nscoping rules functions: ’s object matching name\n’s function, look parent. added challenge, also\nadd inherits argument controls whether function recurses \nparents looks one environment.","code":""},{"path":"environments.html","id":"special-environments","chapter":"7 Environments","heading":"7.4 Special environments","text":"environments created (e.g. env()) instead created R. section, ’ll learn important environments, starting package environments. ’ll learn function environment bound function created, (usually) ephemeral execution environment created every time function called. Finally, ’ll see package function environments interact support namespaces, ensure package always behaves way, regardless packages user loaded.","code":""},{"path":"environments.html","id":"search-path","chapter":"7 Environments","heading":"7.4.1 Package environments and the search path","text":"\n\npackage attached library() require() becomes one parents global environment. immediate parent global environment last package attached43, parent package second last package attached, …follow parents back, see order every package attached. known search path objects environments can found top-level interactive workspace. can see names environments base::search(), environments rlang::search_envs():last two environments search path always :Autoloads environment uses delayed bindings save memory \nloading package objects (like big datasets) needed.Autoloads environment uses delayed bindings save memory \nloading package objects (like big datasets) needed.base environment, package:base sometimes just base, \nenvironment base package. special able\nbootstrap loading packages. can access directly\nbase_env().base environment, package:base sometimes just base, \nenvironment base package. special able\nbootstrap loading packages. can access directly\nbase_env().Note attach another package library(), parent environment global environment changes:","code":"\nsearch()\n#>  [1] \".GlobalEnv\"        \"package:rlang\"     \"package:stats\"    \n#>  [4] \"package:graphics\"  \"package:grDevices\" \"package:utils\"    \n#>  [7] \"package:datasets\"  \"package:methods\"   \"Autoloads\"        \n#> [10] \"package:base\"\n\nsearch_envs()\n#>  [[1]] $ <env: global>\n#>  [[2]] $ <env: package:rlang>\n#>  [[3]] $ <env: package:stats>\n#>  [[4]] $ <env: package:graphics>\n#>  [[5]] $ <env: package:grDevices>\n#>  [[6]] $ <env: package:utils>\n#>  [[7]] $ <env: package:datasets>\n#>  [[8]] $ <env: package:methods>\n#>  [[9]] $ <env: Autoloads>\n#> [[10]] $ <env: package:base>"},{"path":"environments.html","id":"function-environments","chapter":"7 Environments","heading":"7.4.2 The function environment","text":"\nfunction binds current environment created. called function environment, used lexical scoping. Across computer languages, functions capture (enclose) environments called closures, term often used interchangeably function R’s documentation.can get function environment fn_env():Use environment(f) access environment function f.diagrams, ’ll draw function rectangle rounded end binds environment.case, f() binds environment binds name f function. ’s always case: following example g bound new environment e, g() binds global environment. distinction binding bound subtle important; difference find g versus g finds variables.","code":"\ny <- 1\nf <- function(x) x + y\nfn_env(f)\n#> <environment: R_GlobalEnv>\ne <- env()\ne$g <- function() 1"},{"path":"environments.html","id":"namespaces","chapter":"7 Environments","heading":"7.4.3 Namespaces","text":"diagram , saw parent environment package varies based packages loaded. seems worrying: doesn’t mean package find different functions packages loaded different order? goal namespaces make sure happen, every package works way regardless packages attached user.example, take sd():sd() defined terms var(), might worry result sd() affected function called var() either global environment, one attached packages. R avoids problem taking advantage function versus binding environment described . Every function package associated pair environments: package environment, learned earlier, namespace environment.package environment external interface package. ’s \n, R user, find function attached package ::. \nparent determined search path, .e. order packages \nattached.package environment external interface package. ’s \n, R user, find function attached package ::. \nparent determined search path, .e. order packages \nattached.namespace environment internal interface package. \npackage environment controls find function; namespace\ncontrols function finds variables.namespace environment internal interface package. \npackage environment controls find function; namespace\ncontrols function finds variables.Every binding package environment also found namespace environment; ensures every function can use every function package. bindings occur namespace environment. known internal non-exported objects, make possible hide internal implementation details user.Every namespace environment set ancestors:namespace imports environment contains bindings \nfunctions used package. imports environment controlled \npackage developer NAMESPACE file.namespace imports environment contains bindings \nfunctions used package. imports environment controlled \npackage developer NAMESPACE file.Explicitly importing every base function tiresome, parent\nimports environment base namespace. base namespace\ncontains bindings base environment, different\nparent.Explicitly importing every base function tiresome, parent\nimports environment base namespace. base namespace\ncontains bindings base environment, different\nparent.parent base namespace global environment. means \nbinding isn’t defined imports environment package look\nusual way. usually bad idea (makes code\ndepend loaded packages), R CMD check automatically warns \ncode. needed primarily historical reasons, particularly due\nS3 method dispatch works.parent base namespace global environment. means \nbinding isn’t defined imports environment package look\nusual way. usually bad idea (makes code\ndepend loaded packages), R CMD check automatically warns \ncode. needed primarily historical reasons, particularly due\nS3 method dispatch works.Putting diagrams together get:sd() looks value var always finds sequence environments determined package developer, package user. ensures package code always works way regardless packages attached user.’s direct link package namespace environments; link defined function environments.","code":"\nsd\n#> function (x, na.rm = FALSE) \n#> sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), \n#>     na.rm = na.rm))\n#> <bytecode: 0x0000000022e06bd0>\n#> <environment: namespace:stats>"},{"path":"environments.html","id":"execution-environments","chapter":"7 Environments","heading":"7.4.4 Execution environments","text":"\nlast important topic need cover execution environment. following function return first time ’s run? second?Think moment read .function returns value every time fresh start principle, described Section 6.4.3. time function called, new environment created host execution. called execution environment, parent function environment. Let’s illustrate process simpler function. Figure 7.1 illustrates graphical conventions: draw execution environments indirect parent; parent environment found via function environment.\nFigure 7.1: execution environment simple function call. Note parent execution environment function environment.\nexecution environment usually ephemeral; function completed, environment garbage collected. several ways make stay around longer. first explicitly return :Another way capture return object binding environment, like function. following example illustrates idea function factory, plus(). use factory create function called plus_one().’s lot going diagram enclosing environment plus_one() execution environment plus().happens call plus_one()? execution environment captured execution environment plus() parent:’ll learn function factories Section 10.2.","code":"\ng <- function(x) {\n  if (!env_has(current_env(), \"a\")) {\n    message(\"Defining a\")\n    a <- 1\n  } else {\n    a <- a + 1\n  }\n  a\n}\ng(10)\n#> Defining a\n#> [1] 1\ng(10)\n#> Defining a\n#> [1] 1\nh <- function(x) {\n  # 1.\n  a <- 2 # 2.\n  x + a\n}\ny <- h(1) # 3.\nh2 <- function(x) {\n  a <- x * 2\n  current_env()\n}\n\ne <- h2(x = 10)\nenv_print(e)\n#> <environment: 00000000221FB160>\n#> parent: <environment: global>\n#> bindings:\n#>  * a: <dbl>\n#>  * x: <dbl>\nfn_env(h2)\n#> <environment: R_GlobalEnv>\nplus <- function(x) {\n  function(y) x + y\n}\n\nplus_one <- plus(1)\nplus_one\n#> function(y) x + y\n#> <environment: 0x0000000010c562a8>\nplus_one(2)\n#> [1] 3"},{"path":"environments.html","id":"exercises-22","chapter":"7 Environments","heading":"7.4.5 Exercises","text":"search_envs() different env_parents(global_env())?search_envs() different env_parents(global_env())?Draw diagram shows enclosing environments function:\n\nf1 <- function(x1) {\n  f2 <- function(x2) {\n    f3 <- function(x3) {\n      x1 + x2 + x3\n    }\n    f3(3)\n  }\n  f2(2)\n}\nf1(1)Draw diagram shows enclosing environments function:Write enhanced version str() provides information\nfunctions. Show function found environment\ndefined .Write enhanced version str() provides information\nfunctions. Show function found environment\ndefined .","code":"\nf1 <- function(x1) {\n  f2 <- function(x2) {\n    f3 <- function(x3) {\n      x1 + x2 + x3\n    }\n    f3(3)\n  }\n  f2(2)\n}\nf1(1)"},{"path":"environments.html","id":"call-stack","chapter":"7 Environments","heading":"7.5 Call stacks","text":"\n\none last environment need explain, caller environment, accessed rlang::caller_env(). provides environment function called, hence varies based function called, function created. saw useful default whenever write function takes environment argument.parent.frame() equivalent caller_env(); just note returns environment, frame.fully understand caller environment need discuss two related concepts: call stack, made frames. Executing function creates two types context. ’ve learned one already: execution environment child function environment, determined function created. ’s another type context created function called: called call stack.","code":""},{"path":"environments.html","id":"simple-stack","chapter":"7 Environments","heading":"7.5.1 Simple call stacks","text":"Let’s illustrate simple sequence calls: f() calls g() calls h().way commonly see call stack R looking traceback() error occurred:Instead stop() + traceback() understand call stack, ’re going use lobstr::cst() print call stack tree:shows us cst() called h(), called g(), called f(). Note order opposite traceback(). call stacks get complicated, think ’s easier understand sequence calls start beginning, rather end (.e. f() calls g(); rather g() called f()).","code":"\nf <- function(x) {\n  g(x = 2)\n}\ng <- function(x) {\n  h(x = 3)\n}\nh <- function(x) {\n  stop()\n}\nf(x = 1)\n#> Error:\ntraceback()\n#> 4: stop()\n#> 3: h(x = 3) \n#> 2: g(x = 2)\n#> 1: f(x = 1)\nh <- function(x) {\n  lobstr::cst()\n}\nf(x = 1)\n#> █\n#> └─f(x = 1)\n#>   └─g(x = 2)\n#>     └─h(x = 3)\n#>       └─lobstr::cst()"},{"path":"environments.html","id":"lazy-call-stack","chapter":"7 Environments","heading":"7.5.2 Lazy evaluation","text":"call stack simple: get hint ’s tree-like structure involved, everything happens single branch. typical call stack arguments eagerly evaluated.Let’s create complicated example involves lazy evaluation. ’ll create sequence functions, (), b(), c(), pass along argument x.x lazily evaluated tree gets two branches. first branch () calls b(), b() calls c(). second branch starts c() evaluates argument x. argument evaluated new branch environment evaluated global environment, environment c().","code":"\na <- function(x) b(x)\nb <- function(x) c(x)\nc <- function(x) x\n\na(f())\n#> █\n#> ├─a(f())\n#> │ └─b(x)\n#> │   └─c(x)\n#> └─f()\n#>   └─g(x = 2)\n#>     └─h(x = 3)\n#>       └─lobstr::cst()"},{"path":"environments.html","id":"frames","chapter":"7 Environments","heading":"7.5.3 Frames","text":"\nelement call stack frame44, also known evaluation context. frame extremely important internal data structure, R code can access small part data structure tampering break R. frame three key components:expression (labelled expr) giving function call. \ntraceback() prints .expression (labelled expr) giving function call. \ntraceback() prints .environment (labelled env), typically execution\nenvironment function. two main exceptions: environment \nglobal frame global environment, calling eval() also\ngenerates frames, environment can anything.environment (labelled env), typically execution\nenvironment function. two main exceptions: environment \nglobal frame global environment, calling eval() also\ngenerates frames, environment can anything.parent, previous call call stack (shown grey arrow).parent, previous call call stack (shown grey arrow).Figure 7.2 illustrates stack call f(x = 1) shown Section 7.5.1.\nFigure 7.2: graphical depiction simple call stack\n(focus calling environments, omitted bindings global environment f, g, h respective function objects.)frame also holds exit handlers created .exit(), restarts handlers condition system, context return() function completes. important internal details accessible R code.","code":""},{"path":"environments.html","id":"dynamic-scope","chapter":"7 Environments","heading":"7.5.4 Dynamic scope","text":"Looking variables calling stack rather enclosing environment called dynamic scoping. languages implement dynamic scoping (Emacs Lisp notable exception.) dynamic scoping makes much harder reason function operates: need know defined, also need know context called. Dynamic scoping primarily useful developing functions aid interactive data analysis, one topics discussed Chapter 20.","code":""},{"path":"environments.html","id":"exercises-23","chapter":"7 Environments","heading":"7.5.5 Exercises","text":"Write function lists variables defined environment\ncalled. return results ls().","code":""},{"path":"environments.html","id":"explicit-envs","chapter":"7 Environments","heading":"7.6 As data structures","text":"\nwell powering scoping, environments also useful data structures right reference semantics. three common problems can help solve:Avoiding copies large data. Since environments reference\nsemantics, ’ll never accidentally create copy. bare environments\npainful work , instead recommend using R6 objects, \nbuilt top environments. Learn Chapter 14.Avoiding copies large data. Since environments reference\nsemantics, ’ll never accidentally create copy. bare environments\npainful work , instead recommend using R6 objects, \nbuilt top environments. Learn Chapter 14.Managing state within package. Explicit environments useful \npackages allow maintain state across function calls.\nNormally, objects package locked, can’t modify \ndirectly. Instead, can something like :\n\nmy_env <- new.env(parent = emptyenv())\nmy_env$<- 1\n\nget_a <- function() {\n  my_env$\n}\nset_a <- function(value) {\n  old <- my_env$\n  my_env$<- value\n  invisible(old)\n}\nReturning old value setter functions good pattern \nmakes easier reset previous value conjunction \n.exit() (Section 6.7.4).Managing state within package. Explicit environments useful \npackages allow maintain state across function calls.\nNormally, objects package locked, can’t modify \ndirectly. Instead, can something like :Returning old value setter functions good pattern \nmakes easier reset previous value conjunction \n.exit() (Section 6.7.4).hashmap. hashmap data structure takes constant, O(1),\ntime find object based name. Environments provide \nbehaviour default, can used simulate hashmap. See \nhash package45 complete development idea.hashmap. hashmap data structure takes constant, O(1),\ntime find object based name. Environments provide \nbehaviour default, can used simulate hashmap. See \nhash package45 complete development idea.","code":"\nmy_env <- new.env(parent = emptyenv())\nmy_env$a <- 1\n\nget_a <- function() {\n  my_env$a\n}\nset_a <- function(value) {\n  old <- my_env$a\n  my_env$a <- value\n  invisible(old)\n}"},{"path":"environments.html","id":"env-answers","chapter":"7 Environments","heading":"7.7 Quiz answers","text":"four ways: every object environment must name;\norder doesn’t matter; environments parents; environments \nreference semantics.four ways: every object environment must name;\norder doesn’t matter; environments parents; environments \nreference semantics.parent global environment last package \nloaded. environment doesn’t parent empty\nenvironment.parent global environment last package \nloaded. environment doesn’t parent empty\nenvironment.enclosing environment function environment \ncreated. determines function looks variables.enclosing environment function environment \ncreated. determines function looks variables.Use caller_env() parent.frame().Use caller_env() parent.frame().<- always creates binding current environment; <<-\nrebinds existing name parent current environment.<- always creates binding current environment; <<-\nrebinds existing name parent current environment.","code":""},{"path":"conditions.html","id":"conditions","chapter":"8 Conditions","heading":"8 Conditions","text":"","code":""},{"path":"conditions.html","id":"introduction-7","chapter":"8 Conditions","heading":"8.1 Introduction","text":"condition system provides paired set tools allow author function indicate something unusual happening, user function deal . function author signals conditions functions like stop() (errors), warning() (warnings), message() (messages), function user can handle functions like tryCatch() withCallingHandlers(). Understanding condition system important ’ll often need play roles: signalling conditions functions create, handle conditions signalled functions call.R offers powerful condition system based ideas Common Lisp. Like R’s approach object-oriented programming, rather different currently popular programming languages easy misunderstand, relatively little written use effectively. Historically, meant people (included) taken full advantage power. goal chapter remedy situation. learn big ideas R’s condition system, well learning bunch practical tools make code stronger.found two resources particularly useful writing chapter. may also want read want learn inspirations motivations system:prototype condition system R Robert Gentleman\nLuke Tierney. describes early version R’s condition system.\nimplementation changed somewhat since document \nwritten, provides good overview pieces fit together, \nmotivation design.prototype condition system R Robert Gentleman\nLuke Tierney. describes early version R’s condition system.\nimplementation changed somewhat since document \nwritten, provides good overview pieces fit together, \nmotivation design.Beyond exception handling: conditions restarts\nPeter Seibel. describes exception handling Lisp, happens\nsimilar R’s approach. provides useful motivation \nsophisticated examples. provided R translation \nchapter http://adv-r..co.nz/beyond-exception-handling.html.Beyond exception handling: conditions restarts\nPeter Seibel. describes exception handling Lisp, happens\nsimilar R’s approach. provides useful motivation \nsophisticated examples. provided R translation \nchapter http://adv-r..co.nz/beyond-exception-handling.html.also found helpful work underlying C code implements ideas. ’re interested understanding works, might find notes useful.","code":""},{"path":"conditions.html","id":"quiz-6","chapter":"8 Conditions","heading":"Quiz","text":"Want skip chapter? Go , can answer questions . Find answers end chapter Section 8.7.three important types condition?three important types condition?function use ignore errors block code?function use ignore errors block code?’s main difference tryCatch() withCallingHandlers()?’s main difference tryCatch() withCallingHandlers()?might want create custom error object?might want create custom error object?","code":""},{"path":"conditions.html","id":"outline-6","chapter":"8 Conditions","heading":"Outline","text":"Section 8.2 introduces basic tools \nsignalling conditions, discusses appropriate use type.Section 8.2 introduces basic tools \nsignalling conditions, discusses appropriate use type.Section 8.3 teaches simplest tools \nhandling conditions: functions like try() supressMessages() \nswallow conditions prevent getting top level.Section 8.3 teaches simplest tools \nhandling conditions: functions like try() supressMessages() \nswallow conditions prevent getting top level.Section 8.4 introduces condition object, \ntwo fundamental tools condition handling: tryCatch() error\nconditions, withCallingHandlers() everything else.Section 8.4 introduces condition object, \ntwo fundamental tools condition handling: tryCatch() error\nconditions, withCallingHandlers() everything else.Section 8.5 shows extend built-\ncondition objects store useful data condition handlers can use \nmake informed decisions.Section 8.5 shows extend built-\ncondition objects store useful data condition handlers can use \nmake informed decisions.Section 8.6 closes chapter grab bag\npractical applications based low-level tools found earlier\nsections.Section 8.6 closes chapter grab bag\npractical applications based low-level tools found earlier\nsections.","code":""},{"path":"conditions.html","id":"prerequisites-2","chapter":"8 Conditions","heading":"8.1.1 Prerequisites","text":"well base R functions, chapter uses condition signalling handling functions rlang.","code":"\nlibrary(rlang)"},{"path":"conditions.html","id":"signalling-conditions","chapter":"8 Conditions","heading":"8.2 Signalling conditions","text":"\nthree conditions can signal code: errors, warnings, messages.Errors severe; indicate way function\ncontinue execution must stop.Errors severe; indicate way function\ncontinue execution must stop.Warnings fall somewhat errors message, typically indicate\nsomething gone wrong function able least\npartially recover.Warnings fall somewhat errors message, typically indicate\nsomething gone wrong function able least\npartially recover.Messages mildest; way informing users action\nperformed behalf.Messages mildest; way informing users action\nperformed behalf.final condition can generated interactively: interrupt, indicates user interrupted execution pressing Escape, Ctrl + Break, Ctrl + C (depending platform).Conditions usually displayed prominently, bold font coloured red, depending R interface. can tell apart errors always start “Error,” warnings “Warning” “Warning message,” messages nothing.following three sections describe errors, warnings, messages detail.","code":"\nstop(\"This is what an error looks like\")\n#> Error in eval(expr, envir, enclos): This is what an error looks like\n\nwarning(\"This is what a warning looks like\")\n#> Warning: This is what a warning looks like\n\nmessage(\"This is what a message looks like\")\n#> This is what a message looks like"},{"path":"conditions.html","id":"errors-1","chapter":"8 Conditions","heading":"8.2.1 Errors","text":"\n\nbase R, errors signalled, thrown, stop():default, error message includes call, typically useful (recapitulates information can easily get traceback()), think ’s good practice use call. = FALSE46:rlang equivalent stop(), rlang::abort(), automatically. ’ll use abort() throughout chapter, won’t get compelling feature, ability add additional metadata condition object, ’re near end chapter.(NB: stop() pastes together multiple inputs, abort() . create complex error messages abort, recommend using glue::glue(). allows us use arguments abort() useful features ’ll learn Section 8.5.)best error messages tell wrong point right direction fix problem. Writing good error messages hard errors usually occur user flawed mental model function. developer, ’s hard imagine user might thinking incorrectly function, thus ’s hard write message steer user correct direction. said, tidyverse style guide discusses general principles found useful: http://style.tidyverse.org/error-messages.html.","code":"\nf <- function() g()\ng <- function() h()\nh <- function() stop(\"This is an error!\")\n\nf()\n#> Error in h(): This is an error!\nh <- function() stop(\"This is an error!\", call. = FALSE)\nf()\n#> Error: This is an error!\nh <- function() abort(\"This is an error!\")\nf()\n#> Error: This is an error!"},{"path":"conditions.html","id":"warnings","chapter":"8 Conditions","heading":"8.2.2 Warnings","text":"Warnings, signalled warning(), weaker errors: signal something gone wrong, code able recover continue. Unlike errors, can multiple warnings single function call:default, warnings cached printed control returns top level:\ncan control behaviour warn option:make warnings appear immediately, set options(warn = 1).make warnings appear immediately, set options(warn = 1).turn warnings errors, set options(warn = 2). usually\neasiest way debug warning, ’s error can\nuse tools like traceback() find source.turn warnings errors, set options(warn = 2). usually\neasiest way debug warning, ’s error can\nuse tools like traceback() find source.Restore default behaviour options(warn = 0).Restore default behaviour options(warn = 0).Like stop(), warning() also call argument. slightly useful (since warnings often distant source), still generally suppress call. = FALSE. Like rlang::abort(), rlang equivalent warning(), rlang::warn(), also suppresses call. default.Warnings occupy somewhat challenging place messages (“know ”) errors (“must fix !”), ’s hard give precise advice use . Generally, restrained, warnings easy miss ’s lot output, don’t want function recover easily clearly invalid input. opinion, base R tends overuse warnings, many warnings base R better errors. example, think warnings helpful errors:couple cases using warning clearly appropriate:deprecate function want allow older code continue\nwork (ignoring warning OK) want encourage user\nswitch new function.deprecate function want allow older code continue\nwork (ignoring warning OK) want encourage user\nswitch new function.reasonably certain can recover problem:\n100% certain fix problem, wouldn’t need\nmessage; uncertain correctly fix \nissue, ’d throw error.reasonably certain can recover problem:\n100% certain fix problem, wouldn’t need\nmessage; uncertain correctly fix \nissue, ’d throw error.Otherwise use warnings restraint, carefully consider error appropriate.","code":"\nfw <- function() {\n  cat(\"1\\n\")\n  warning(\"W1\")\n  cat(\"2\\n\")\n  warning(\"W2\")\n  cat(\"3\\n\")\n  warning(\"W3\")\n}\nfw()\n#> 1\n#> 2\n#> 3\n#> Warning messages:\n#> 1: In f() : W1\n#> 2: In f() : W2\n#> 3: In f() : W3\nformals(1)\n#> Warning in formals(fun): argument is not a function\n#> NULL\n\nfile.remove(\"this-file-doesn't-exist\")\n#> Warning in file.remove(\"this-file-doesn't-exist\"): no fue posible abrir el\n#> archivo 'this-file-doesn't-exist', motivo 'No such file or directory'\n#> [1] FALSE\n\nlag(1:3, k = 1.5)\n#> Warning in lag.default(1:3, k = 1.5): 'k' is not an integer\n#> [1] 1 2 3\n#> attr(,\"tsp\")\n#> [1] -1  1  1\n\nas.numeric(c(\"18\", \"30\", \"50+\", \"345,678\"))\n#> Warning: NAs introducidos por coerción\n#> [1] 18 30 NA NA"},{"path":"conditions.html","id":"messages","chapter":"8 Conditions","heading":"8.2.3 Messages","text":"\n\nMessages, signalled message(), informational; use tell user ’ve done something behalf. Good messages balancing act: want provide just enough information user knows ’s going , much ’re overwhelmed.message()s displayed immediately call. argument:Good places use message :default argument requires non-trivial amount computation\nwant tell user value used. example, ggplot2\nreports number bins used don’t supply binwidth.default argument requires non-trivial amount computation\nwant tell user value used. example, ggplot2\nreports number bins used don’t supply binwidth.functions called primarily side-effects \notherwise silent. example, writing files disk, calling web\nAPI, writing database, ’s useful provide regular status messages\ntelling user ’s happening.functions called primarily side-effects \notherwise silent. example, writing files disk, calling web\nAPI, writing database, ’s useful provide regular status messages\ntelling user ’s happening.’re start long running process \nintermediate output. progress bar (e.g. \nprogress) better, message\ngood place start.’re start long running process \nintermediate output. progress bar (e.g. \nprogress) better, message\ngood place start.writing package, sometimes want display message \npackage loaded (.e. .onAttach()); must use\npackageStartupMessage().writing package, sometimes want display message \npackage loaded (.e. .onAttach()); must use\npackageStartupMessage().Generally function produces message way suppress , like quiet = TRUE argument. possible suppress messages suppressMessages(), ’ll learn shortly, nice also give finer grained control.’s important compare message() closely related cat(). terms usage result, appear quite similar47:However, purposes cat() message() different. Use cat() primary role function print console, like print() str() methods. Use message() side-channel print console primary purpose function something else. words, cat() user asks something printed message() developer elects print something.","code":"\nfm <- function() {\n  cat(\"1\\n\")\n  message(\"M1\")\n  cat(\"2\\n\")\n  message(\"M2\")\n  cat(\"3\\n\")\n  message(\"M3\")\n}\n\nfm()\n#> 1\n#> M1\n#> 2\n#> M2\n#> 3\n#> M3\ncat(\"Hi!\\n\")\n#> Hi!\n\nmessage(\"Hi!\")\n#> Hi!"},{"path":"conditions.html","id":"exercises-24","chapter":"8 Conditions","heading":"8.2.4 Exercises","text":"Write wrapper around file.remove() throws error file\ndeleted exist.Write wrapper around file.remove() throws error file\ndeleted exist.appendLF argument message() ? related \ncat()?appendLF argument message() ? related \ncat()?","code":""},{"path":"conditions.html","id":"ignoring-conditions","chapter":"8 Conditions","heading":"8.3 Ignoring conditions","text":"\n\n\nsimplest way handling conditions R simply ignore :Ignore errors try().Ignore warnings suppressWarnings().Ignore messages suppressMessages().functions heavy handed can’t use suppress single type condition know , allowing everything else pass . ’ll come back challenge later chapter.try() allows execution continue even error occurred. Normally run function throws error, terminates immediately doesn’t return value:However, wrap statement creates error try(), error message displayed48 execution continue:possible, recommended, save result try() perform different actions based whether code succeeded failed49. Instead, better use tryCatch() higher-level helper; ’ll learn shortly.simple, useful, pattern assignment inside call: lets define default value used code succeed. works argument evaluated calling environment, inside function. (See Section 6.5.1 details.)suppressWarnings() suppressMessages() suppress warnings messages. Unlike errors, messages warnings don’t terminate execution, may multiple warnings messages signalled single block.","code":"\nf1 <- function(x) {\n  log(x)\n  10\n}\nf1(\"x\")\n#> Error in log(x): non-numeric argument to mathematical function\nf2 <- function(x) {\n  try(log(x))\n  10\n}\nf2(\"a\")\n#> Error in log(x) : non-numeric argument to mathematical function\n#> [1] 10\ndefault <- NULL\ntry(default <- read.csv(\"possibly-bad-input.csv\"), silent = TRUE)\nsuppressWarnings({\n  warning(\"Uhoh!\")\n  warning(\"Another warning\")\n  1\n})\n#> [1] 1\n\nsuppressMessages({\n  message(\"Hello there\")\n  2\n})\n#> [1] 2\n\nsuppressWarnings({\n  message(\"You can still see me\")\n  3\n})\n#> You can still see me\n#> [1] 3"},{"path":"conditions.html","id":"handling-conditions","chapter":"8 Conditions","heading":"8.4 Handling conditions","text":"\n\n\nEvery condition default behaviour: errors stop execution return top level, warnings captured displayed aggregate, messages immediately displayed. Condition handlers allow us temporarily override supplement default behaviour.Two functions, tryCatch() withCallingHandlers(), allow us register handlers, functions take signalled condition single argument. registration functions basic form:differ type handlers create:tryCatch() defines exiting handlers; condition handled,\ncontrol returns context tryCatch() called. makes\ntryCatch() suitable working errors interrupts, \nexit anyway.tryCatch() defines exiting handlers; condition handled,\ncontrol returns context tryCatch() called. makes\ntryCatch() suitable working errors interrupts, \nexit anyway.withCallingHandlers() defines calling handlers; condition\ncaptured control returns context condition signalled.\nmakes suitable working non-error conditions.withCallingHandlers() defines calling handlers; condition\ncaptured control returns context condition signalled.\nmakes suitable working non-error conditions.can learn use handlers, need talk little bit condition objects. created implicitly whenever signal condition, become explicit inside handler.","code":"\ntryCatch(\n  error = function(cnd) {\n    # code to run when error is thrown\n  },\n  code_to_run_while_handlers_are_active\n)\n\nwithCallingHandlers(\n  warning = function(cnd) {\n    # code to run when warning is signalled\n  },\n  message = function(cnd) {\n    # code to run when message is signalled\n  },\n  code_to_run_while_handlers_are_active\n)"},{"path":"conditions.html","id":"condition-objects","chapter":"8 Conditions","heading":"8.4.1 Condition objects","text":"\nfar ’ve just signalled conditions, looked objects created behind scenes. easiest way see condition object catch one signalled condition. ’s job rlang::catch_cnd():Built-conditions lists two elements:message, length-1 character vector containing text display user.\nextract message, use conditionMessage(cnd).message, length-1 character vector containing text display user.\nextract message, use conditionMessage(cnd).call, call triggered condition. described , don’t\nuse call, often NULL. extract , use\nconditionCall(cnd).call, call triggered condition. described , don’t\nuse call, often NULL. extract , use\nconditionCall(cnd).Custom conditions may contain components, ’ll discuss Section 8.5.Conditions also class attribute, makes S3 objects. won’t discuss S3 Chapter 13, fortunately, even don’t know S3, condition objects quite simple. important thing know class attribute character vector, determines handlers match condition.","code":"\ncnd <- catch_cnd(stop(\"An error\"))\nstr(cnd)\n#> List of 2\n#>  $ message: chr \"An error\"\n#>  $ call   : language force(expr)\n#>  - attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\""},{"path":"conditions.html","id":"exiting-handlers","chapter":"8 Conditions","heading":"8.4.2 Exiting handlers","text":"tryCatch() registers exiting handlers, typically used handle error conditions. allows override default error behaviour. example, following code return NA instead throwing error:conditions signalled, class signalled condition match handler name, code executes normally:handlers set tryCatch() called exiting handlers condition signalled, control passes handler never returns original code, effectively meaning code exits:protected code evaluated environment tryCatch(), handler code , handlers functions. important remember ’re trying modify objects parent environment.handler functions called single argument, condition object. call argument cnd, convention. value moderately useful base conditions contain relatively little data. ’s useful make custom conditions, ’ll see shortly.tryCatch() one argument: finally. specifies block code (function) run regardless whether initial expression succeeds fails. can useful clean , like deleting files, closing connections. functionally equivalent using .exit() (indeed ’s ’s implemented) can wrap smaller chunks code entire function.\n","code":"\nf3 <- function(x) {\n  tryCatch(\n    error = function(cnd) NA,\n    log(x)\n  )\n}\n\nf3(\"x\")\n#> [1] NA\ntryCatch(\n  error = function(cnd) 10,\n  1 + 1\n)\n#> [1] 2\n\ntryCatch(\n  error = function(cnd) 10,\n  {\n    message(\"Hi!\")\n    1 + 1\n  }\n)\n#> Hi!\n#> [1] 2\ntryCatch(\n  message = function(cnd) \"There\",\n  {\n    message(\"Here\")\n    stop(\"This code is never run!\")\n  }\n)\n#> [1] \"There\"\ntryCatch(\n  error = function(cnd) {\n    paste0(\"--\", conditionMessage(cnd), \"--\")\n  },\n  stop(\"This is an error\")\n)\n#> [1] \"--This is an error--\"\npath <- tempfile()\ntryCatch(\n  {\n    writeLines(\"Hi!\", path)\n    # ...\n  },\n  finally = {\n    # always run\n    unlink(path)\n  }\n)"},{"path":"conditions.html","id":"calling-handlers","chapter":"8 Conditions","heading":"8.4.3 Calling handlers","text":"\nhandlers set tryCatch() called exiting handlers, cause code exit condition caught. contrast, withCallingHandlers() sets calling handlers: code execution continues normally handler returns. tends make withCallingHandlers() natural pairing non-error conditions. Exiting calling handlers use “handler” slighty different senses:exiting handler handles signal like handle problem; makes \nproblem go away.exiting handler handles signal like handle problem; makes \nproblem go away.calling handler handles signal like handle car; car still\nexists.calling handler handles signal like handle car; car still\nexists.Compare results tryCatch() withCallingHandlers() example . messages printed first case, code terminated exiting handler completes. printed second case, calling handler exit.Handlers applied order, don’t need worry getting caught infinite loop. following example, message() signalled handler doesn’t also get caught:(beware multiple handlers, handlers signal conditions captured another handler: ’ll need think order carefully.)return value calling handler ignored code continues execute handler completes; return value go? means calling handlers useful side-effects.\nOne important side-effect unique calling handlers ability muffle signal. default, condition continue propagate parent handlers, way default handler (exiting handler, provided):want prevent condition “bubbling ” still run rest code block, need explicitly muffle rlang::cnd_muffle():","code":"\ntryCatch(\n  message = function(cnd) cat(\"Caught a message!\\n\"), \n  {\n    message(\"Someone there?\")\n    message(\"Why, yes!\")\n  }\n)\n#> Caught a message!\n\nwithCallingHandlers(\n  message = function(cnd) cat(\"Caught a message!\\n\"), \n  {\n    message(\"Someone there?\")\n    message(\"Why, yes!\")\n  }\n)\n#> Caught a message!\n#> Someone there?\n#> Caught a message!\n#> Why, yes!\nwithCallingHandlers(\n  message = function(cnd) message(\"Second message\"),\n  message(\"First message\")\n)\n#> Second message\n#> First message\n# Bubbles all the way up to default handler which generates the message\nwithCallingHandlers(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n#> Level 1\n#> Level 2\n#> Hello\n\n# Bubbles up to tryCatch\ntryCatch(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n#> Level 1\n#> Level 2\n# Muffles the default handler which prints the messages\nwithCallingHandlers(\n  message = function(cnd) {\n    cat(\"Level 2\\n\")\n    cnd_muffle(cnd)\n  },\n  withCallingHandlers(\n    message = function(cnd) cat(\"Level 1\\n\"),\n    message(\"Hello\")\n  )\n)\n#> Level 1\n#> Level 2\n\n# Muffles level 2 handler and the default handler\nwithCallingHandlers(\n  message = function(cnd) cat(\"Level 2\\n\"),\n  withCallingHandlers(\n    message = function(cnd) {\n      cat(\"Level 1\\n\")\n      cnd_muffle(cnd)\n    },\n    message(\"Hello\")\n  )\n)\n#> Level 1"},{"path":"conditions.html","id":"call-stacks","chapter":"8 Conditions","heading":"8.4.4 Call stacks","text":"\ncomplete section, important differences call stacks exiting calling handlers. differences generally important ’m including ’ve occasionally found useful, don’t want forget !’s easiest see difference setting small example uses lobstr::cst():Calling handlers called context call signalled condition:Whereas exiting handlers called context call tryCatch():","code":"\nf <- function() g()\ng <- function() h()\nh <- function() message(\"!\")\nwithCallingHandlers(f(), message = function(cnd) {\n  lobstr::cst()\n  cnd_muffle(cnd)\n})\n#>      x\n#>   1. +-base::withCallingHandlers(...)\n#>   2. +-global::f()\n#>   3. | \\-global::g()\n#>   4. |   \\-global::h()\n#>   5. |     \\-base::message(\"!\")\n#>   6. |       +-base::withRestarts(...)\n#>   7. |       | \\-base:::withOneRestart(expr, restarts[[1L]])\n#>   8. |       |   \\-base:::doWithOneRestart(return(expr), restart)\n#>   9. |       \\-base::signalCondition(cond)\n#>  10. \\-(function (cnd) ...\n#>  11.   \\-lobstr::cst()\ntryCatch(f(), message = function(cnd) lobstr::cst())\n#>     x\n#>  1. \\-base::tryCatch(f(), message = function(cnd) lobstr::cst())\n#>  2.   \\-base:::tryCatchList(expr, classes, parentenv, handlers)\n#>  3.     \\-base:::tryCatchOne(expr, names, parentenv, handlers[[1L]])\n#>  4.       \\-value[[3L]](cond)\n#>  5.         \\-lobstr::cst()"},{"path":"conditions.html","id":"exercises-25","chapter":"8 Conditions","heading":"8.4.5 Exercises","text":"extra information condition generated abort() contain\ncompared condition generated stop() .e. ’s difference\ntwo objects? Read help ?abort learn .\n\ncatch_cnd(stop(\"error\"))\ncatch_cnd(abort(\"error\"))extra information condition generated abort() contain\ncompared condition generated stop() .e. ’s difference\ntwo objects? Read help ?abort learn .Predict results evaluating following code\n\nshow_condition <- function(code) {\n  tryCatch(\n    error = function(cnd) \"error\",\n    warning = function(cnd) \"warning\",\n    message = function(cnd) \"message\",\n    {\n      code\n      NULL\n    }\n  )\n}\n\nshow_condition(stop(\"!\"))\nshow_condition(10)\nshow_condition(warning(\"?!\"))\nshow_condition({\n  10\n  message(\"?\")\n  warning(\"?!\")\n})Predict results evaluating following codeExplain results running code:\n\nwithCallingHandlers(\n  message = function(cnd) message(\"b\"),\n  withCallingHandlers(\n    message = function(cnd) message(\"\"),\n    message(\"c\")\n  )\n)\n#> b\n#> \n#> b\n#> cExplain results running code:Read source code catch_cnd() explain works.Read source code catch_cnd() explain works.rewrite show_condition() use single handler?rewrite show_condition() use single handler?","code":"\ncatch_cnd(stop(\"An error\"))\ncatch_cnd(abort(\"An error\"))\nshow_condition <- function(code) {\n  tryCatch(\n    error = function(cnd) \"error\",\n    warning = function(cnd) \"warning\",\n    message = function(cnd) \"message\",\n    {\n      code\n      NULL\n    }\n  )\n}\n\nshow_condition(stop(\"!\"))\nshow_condition(10)\nshow_condition(warning(\"?!\"))\nshow_condition({\n  10\n  message(\"?\")\n  warning(\"?!\")\n})\nwithCallingHandlers(\n  message = function(cnd) message(\"b\"),\n  withCallingHandlers(\n    message = function(cnd) message(\"a\"),\n    message(\"c\")\n  )\n)\n#> b\n#> a\n#> b\n#> c"},{"path":"conditions.html","id":"custom-conditions","chapter":"8 Conditions","heading":"8.5 Custom conditions","text":"\nOne challenges error handling R functions generate one built-conditions, contain message call. means want detect specific type error, can work text error message. error prone, message might change time, also messages can translated languages.Fortunately R powerful, little used feature: ability create custom conditions can contain additional metadata. Creating custom conditions little fiddly base R, rlang::abort() makes easy can supply custom .subclass additional metadata.following example shows basic pattern. recommend using following call structure custom conditions. takes advantage R’s flexible argument matching name type error comes first, followed user-facing text, followed custom metadata.Custom conditions work just like regular conditions used interactively, allow handlers much .","code":"\nabort(\n  \"error_not_found\",\n  message = \"Path `blah.csv` not found\", \n  path = \"blah.csv\"\n)\n#> Error: Path `blah.csv` not found"},{"path":"conditions.html","id":"motivation","chapter":"8 Conditions","heading":"8.5.1 Motivation","text":"explore ideas depth, let’s take base::log(). minimum throwing errors caused invalid arguments:think can better explicit argument problem (.e. x base), saying problematic input (just isn’t).gives us:improvement interactive usage error messages likely guide user towards correct fix. However, ’re better want programmatically handle errors: useful metadata error jammed single string.","code":"\nlog(letters)\n#> Error in log(letters): non-numeric argument to mathematical function\nlog(1:10, base = letters)\n#> Error in log(1:10, base = letters): non-numeric argument to mathematical function\nmy_log <- function(x, base = exp(1)) {\n  if (!is.numeric(x)) {\n    abort(paste0(\n      \"`x` must be a numeric vector; not \", typeof(x), \".\"\n    ))\n  }\n  if (!is.numeric(base)) {\n    abort(paste0(\n      \"`base` must be a numeric vector; not \", typeof(base), \".\"\n    ))\n  }\n\n  base::log(x, base = base)\n}\nmy_log(letters)\n#> Error: `x` must be a numeric vector; not character.\nmy_log(1:10, base = letters)\n#> Error: `base` must be a numeric vector; not character."},{"path":"conditions.html","id":"signalling","chapter":"8 Conditions","heading":"8.5.2 Signalling","text":"Let’s build infrastructure improve situation, ’ll start providing custom abort() function bad arguments. little -generalised example hand, reflects common patterns ’ve seen across functions. pattern fairly simple. create nice error message user, using glue::glue(), store metadata condition call developer.want throw custom error without adding dependency rlang, can create condition object “hand” pass stop():can now rewrite my_log() use new helper:my_log() much shorter, little meangingful, ensures error messages bad arguments consistent across functions. yields interactive error messages :","code":"\nabort_bad_argument <- function(arg, must, not = NULL) {\n  msg <- glue::glue(\"`{arg}` must {must}\")\n  if (!is.null(not)) {\n    not <- typeof(not)\n    msg <- glue::glue(\"{msg}; not {not}.\")\n  }\n  \n  abort(\"error_bad_argument\", \n    message = msg, \n    arg = arg, \n    must = must, \n    not = not\n  )\n}\nstop_custom <- function(.subclass, message, call = NULL, ...) {\n  err <- structure(\n    list(\n      message = message,\n      call = call,\n      ...\n    ),\n    class = c(.subclass, \"error\", \"condition\")\n  )\n  stop(err)\n}\n\nerr <- catch_cnd(\n  stop_custom(\"error_new\", \"This is a custom error\", x = 10)\n)\nclass(err)\nerr$x\nmy_log <- function(x, base = exp(1)) {\n  if (!is.numeric(x)) {\n    abort_bad_argument(\"x\", must = \"be numeric\", not = x)\n  }\n  if (!is.numeric(base)) {\n    abort_bad_argument(\"base\", must = \"be numeric\", not = base)\n  }\n\n  base::log(x, base = base)\n}\nmy_log(letters)\n#> Error: `x` must be numeric; not character.\nmy_log(1:10, base = letters)\n#> Error: `base` must be numeric; not character."},{"path":"conditions.html","id":"handling","chapter":"8 Conditions","heading":"8.5.3 Handling","text":"structured condition objects much easier program . first place might want use capability testing function. Unit testing subject book (see R packages details), basics easy understand. following code captures error, asserts structure expect.can also use class (error_bad_argument) tryCatch() handle specific error:using tryCatch() multiple handlers custom classes, first handler match class signal’s class vector called, best match. reason, need make sure put specific handlers first. following code might hope:","code":"\nlibrary(testthat)\n#> Warning: package 'testthat' was built under R version 4.1.2\n\nerr <- catch_cnd(my_log(\"a\"))\nexpect_s3_class(err, \"error_bad_argument\")\nexpect_equal(err$arg, \"x\")\nexpect_equal(err$not, \"character\")\ntryCatch(\n  error_bad_argument = function(cnd) \"bad_argument\",\n  error = function(cnd) \"other error\",\n  my_log(\"a\")\n)\n#> [1] \"bad_argument\"\ntryCatch(\n  error = function(cnd) \"other error\",\n  error_bad_argument = function(cnd) \"bad_argument\",\n  my_log(\"a\")\n)\n#> [1] \"other error\""},{"path":"conditions.html","id":"exercises-26","chapter":"8 Conditions","heading":"8.5.4 Exercises","text":"Inside package, ’s occasionally useful check package \ninstalled using . Write function checks package \ninstalled (requireNamespace(\"pkg\", quietly = FALSE)) ,\nthrows custom condition includes package name metadata.Inside package, ’s occasionally useful check package \ninstalled using . Write function checks package \ninstalled (requireNamespace(\"pkg\", quietly = FALSE)) ,\nthrows custom condition includes package name metadata.Inside package often need stop error something\nright. packages depend package might \ntempted check errors unit tests. help\npackages avoid relying error message part \nuser interface rather API might change without notice?Inside package often need stop error something\nright. packages depend package might \ntempted check errors unit tests. help\npackages avoid relying error message part \nuser interface rather API might change without notice?","code":""},{"path":"conditions.html","id":"condition-applications","chapter":"8 Conditions","heading":"8.6 Applications","text":"Now ’ve learned basic tools R’s condition system, ’s time dive applications. goal section show every possible usage tryCatch() withCallingHandlers() illustrate common patterns frequently crop . Hopefully get creative juices flowing, encounter new problem can come useful solution.","code":""},{"path":"conditions.html","id":"failure-value","chapter":"8 Conditions","heading":"8.6.1 Failure value","text":"simple, useful, tryCatch() patterns based returning value error handler. simplest case wrapper return default value error occurs:sophisticated application base::try(). , try2() extracts essence base::try(); real function complicated order make error message look like ’d see tryCatch() wasn’t used.","code":"\nfail_with <- function(expr, value = NULL) {\n  tryCatch(\n    error = function(cnd) value,\n    expr\n  )\n}\n\nfail_with(log(10), NA_real_)\n#> [1] 2.3\nfail_with(log(\"x\"), NA_real_)\n#> [1] NA\ntry2 <- function(expr, silent = FALSE) {\n  tryCatch(\n    error = function(cnd) {\n      msg <- conditionMessage(cnd)\n      if (!silent) {\n        message(\"Error: \", msg)\n      }\n      structure(msg, class = \"try-error\")\n    },\n    expr\n  )\n}\n\ntry2(1)\n#> [1] 1\ntry2(stop(\"Hi\"))\n#> Error: Hi\n#> [1] \"Hi\"\n#> attr(,\"class\")\n#> [1] \"try-error\"\ntry2(stop(\"Hi\"), silent = TRUE)\n#> [1] \"Hi\"\n#> attr(,\"class\")\n#> [1] \"try-error\""},{"path":"conditions.html","id":"try-success-failure","chapter":"8 Conditions","heading":"8.6.2 Success and failure values","text":"can extend pattern return one value code evaluates successfully (success_val), another fails (error_val). pattern just requires one small trick: evaluating user supplied code, success_val. code throws error, ’ll never get success_val instead return error_val.can use determine expression fails:capture condition, like just rlang::catch_cnd():can also use pattern create try() variant. One challenge try() ’s slightly challenging determine code succeeded failed. Rather returning object special class, think ’s slightly nicer return list two components result error.(closely related purrr::safely(), function operator, ’ll come back Section 11.2.1.)","code":"\nfoo <- function(expr) {\n  tryCatch(\n    error = function(cnd) error_val,\n    {\n      expr\n      success_val\n    }\n  )\n}\ndoes_error <- function(expr) {\n  tryCatch(\n    error = function(cnd) TRUE,\n    {\n      expr\n      FALSE\n    }\n  )\n}\ncatch_cnd <- function(expr) {\n  tryCatch(\n    condition = function(cnd) cnd, \n    {\n      expr\n      NULL\n    }\n  )\n}\nsafety <- function(expr) {\n  tryCatch(\n    error = function(cnd) {\n      list(result = NULL, error = cnd)\n    },\n    list(result = expr, error = NULL)\n  )\n}\n\nstr(safety(1 + 10))\n#> List of 2\n#>  $ result: num 11\n#>  $ error : NULL\nstr(safety(stop(\"Error!\")))\n#> List of 2\n#>  $ result: NULL\n#>  $ error :List of 2\n#>   ..$ message: chr \"Error!\"\n#>   ..$ call   : language doTryCatch(return(expr), name, parentenv, handler)\n#>   ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\""},{"path":"conditions.html","id":"resignal","chapter":"8 Conditions","heading":"8.6.3 Resignal","text":"well returning default values condition signalled, handlers can used make informative error messages. One simple application make function works like options(warn = 2) single block code. idea simple: handle warnings throwing error:write similar function trying find source annoying message. Section 22.6.","code":"\nwarning2error <- function(expr) {\n  withCallingHandlers(\n    warning = function(cnd) abort(conditionMessage(cnd)),\n    expr\n  )\n}\nwarning2error({\n  x <- 2 ^ 4\n  warn(\"Hello\")\n})\n#> Error: Hello"},{"path":"conditions.html","id":"record","chapter":"8 Conditions","heading":"8.6.4 Record","text":"Another common pattern record conditions later investigation. new challenge calling handlers called side-effects can’t return values, instead need modify object place.also want capture errors? ’ll need wrap withCallingHandlers() tryCatch(). error occurs, last condition.key idea underlying evaluate package50 powers knitr: captures every output special data structure can later replayed. whole, evaluate package quite lot complicated code also needs handle plots text output.","code":"\ncatch_cnds <- function(expr) {\n  conds <- list()\n  add_cond <- function(cnd) {\n    conds <<- append(conds, list(cnd))\n    cnd_muffle(cnd)\n  }\n  \n  withCallingHandlers(\n    message = add_cond,\n    warning = add_cond,\n    expr\n  )\n  \n  conds\n}\n\ncatch_cnds({\n  inform(\"a\")\n  warn(\"b\")\n  inform(\"c\")\n})\n#> [[1]]\n#> <message: a\n#> >\n#> \n#> [[2]]\n#> <warning: b>\n#> \n#> [[3]]\n#> <message: c\n#> >\ncatch_cnds <- function(expr) {\n  conds <- list()\n  add_cond <- function(cnd) {\n    conds <<- append(conds, list(cnd))\n    cnd_muffle(cnd)\n  }\n  \n  tryCatch(\n    error = function(cnd) {\n      conds <<- append(conds, list(cnd))\n    },\n    withCallingHandlers(\n      message = add_cond,\n      warning = add_cond,\n      expr\n    )\n  )\n  \n  conds\n}\n\ncatch_cnds({\n  inform(\"a\")\n  warn(\"b\")\n  abort(\"C\")\n})\n#> [[1]]\n#> <message: a\n#> >\n#> \n#> [[2]]\n#> <warning: b>\n#> \n#> [[3]]\n#> <error/rlang_error>\n#> C\n#> Backtrace:\n#>  1. global::catch_cnds(...)\n#>  6. base::withCallingHandlers(...)"},{"path":"conditions.html","id":"no-default-behaviour","chapter":"8 Conditions","heading":"8.6.5 No default behaviour","text":"final useful pattern signal condition doesn’t inherit message, warning error. default behaviour, means condition effect unless user specifically requests . example, imagine logging system based conditions:call log() condition signalled, nothing happens default handler:activate logging need handler something log condition. define record_log() function record logging messages file:even imagine layering another function allows selectively suppress logging levels.create condition object hand, signal signalCondition(), cnd_muffle() work. Instead need call muffle restart defined, like :Restarts currently beyond scope book, suspect included third edition.","code":"\nlog <- function(message, level = c(\"info\", \"error\", \"fatal\")) {\n  level <- match.arg(level)\n  signal(message, \"log\", level = level)\n}\nlog(\"This code was run\")\nrecord_log <- function(expr, path = stdout()) {\n  withCallingHandlers(\n    log = function(cnd) {\n      cat(\n        \"[\", cnd$level, \"] \", cnd$message, \"\\n\", sep = \"\",\n        file = path, append = TRUE\n      )\n    },\n    expr\n  )\n}\n\nrecord_log(log(\"Hello\"))\n#> [info] Hello\nignore_log_levels <- function(expr, levels) {\n  withCallingHandlers(\n    log = function(cnd) {\n      if (cnd$level %in% levels) {\n        cnd_muffle(cnd)\n      }\n    },\n    expr\n  )\n}\n\nrecord_log(ignore_log_levels(log(\"Hello\"), \"info\"))\nwithRestarts(signalCondition(cond), muffle = function() NULL)"},{"path":"conditions.html","id":"exercises-27","chapter":"8 Conditions","heading":"8.6.6 Exercises","text":"Create suppressConditions() works like suppressMessages() \nsuppressWarnings() suppresses everything. Think carefully \nhandle errors.Create suppressConditions() works like suppressMessages() \nsuppressWarnings() suppresses everything. Think carefully \nhandle errors.Compare following two implementations message2error(). \nmain advantage withCallingHandlers() scenario? (Hint: look\ncarefully traceback.)\n\nmessage2error <- function(code) {\n  withCallingHandlers(code, message = function(e) stop(e))\n}\nmessage2error <- function(code) {\n  tryCatch(code, message = function(e) stop(e))\n}Compare following two implementations message2error(). \nmain advantage withCallingHandlers() scenario? (Hint: look\ncarefully traceback.)modify catch_cnds() definition wanted recreate\noriginal intermingling warnings messages?modify catch_cnds() definition wanted recreate\noriginal intermingling warnings messages?catching interrupts dangerous? Run code find .\n\nbottles_of_beer <- function(= 99) {\n  message(\n    \"\", , \" bottles beer wall, \", \n    , \" bottles beer.\"\n  )\n  (> 0) {\n    tryCatch(\n      Sys.sleep(1),\n      interrupt = function(err) {\n        <<- - 1\n        (> 0) {\n          message(\n            \"Take one , pass around, \", , \n            \" bottle\", (> 1) \"s\", \" beer wall.\"\n          )\n        }\n      }\n    )\n  }\n  message(\n    \"bottles beer wall, \", \n    \"bottles beer.\"\n  )\n}catching interrupts dangerous? Run code find .","code":"\nmessage2error <- function(code) {\n  withCallingHandlers(code, message = function(e) stop(e))\n}\nmessage2error <- function(code) {\n  tryCatch(code, message = function(e) stop(e))\n}\nbottles_of_beer <- function(i = 99) {\n  message(\n    \"There are \", i, \" bottles of beer on the wall, \", \n    i, \" bottles of beer.\"\n  )\n  while(i > 0) {\n    tryCatch(\n      Sys.sleep(1),\n      interrupt = function(err) {\n        i <<- i - 1\n        if (i > 0) {\n          message(\n            \"Take one down, pass it around, \", i, \n            \" bottle\", if (i > 1) \"s\", \" of beer on the wall.\"\n          )\n        }\n      }\n    )\n  }\n  message(\n    \"No more bottles of beer on the wall, \", \n    \"no more bottles of beer.\"\n  )\n}"},{"path":"conditions.html","id":"conditions-answers","chapter":"8 Conditions","heading":"8.7 Quiz answers","text":"error, warning, message.error, warning, message.use try() tryCatch().use try() tryCatch().tryCatch() creates exiting handlers terminate execution\nwrapped code; withCallingHandlers() creates calling handlers \ndon’t affect execution wrapped code.tryCatch() creates exiting handlers terminate execution\nwrapped code; withCallingHandlers() creates calling handlers \ndon’t affect execution wrapped code.can capture specific types error tryCatch(),\nrather relying comparison error strings, risky,\nespecially messages translated.can capture specific types error tryCatch(),\nrather relying comparison error strings, risky,\nespecially messages translated.","code":""},{"path":"fp.html","id":"fp","chapter":"Introduction","heading":"Introduction","text":"R, heart, functional language. means certain technical properties, importantly lends style problem solving centred functions. ’ll give brief overview technical definition functional language, book primarily focus functional style programming, think extremely good fit types problem commonly encounter data analysis.Recently, functional techniques experienced surge interest can produce efficient elegant solutions many modern problems. functional style tends create functions can easily analysed isolation (.e. using local information), hence often much easier automatically optimise parallelise. traditional weaknesses functional languages, poorer performance sometimes unpredictable memory usage, much reduced recent years. Functional programming complementary object-oriented programming, dominant programming paradigm last several decades.","code":""},{"path":"fp.html","id":"functional-programming-languages","chapter":"Introduction","heading":"Functional programming languages","text":"Every programming language functions, makes programming language functional? many definitions precisely makes language functional, two common threads.Firstly, functional languages first-class functions, functions behave like data structure. R, means can many things function can vector: can assign variables, store lists, pass arguments functions, create inside functions, even return result function.Secondly, many functional languages require functions pure. function pure satisfies two properties:output depends inputs, .e. call \ninputs, get outputs. excludes functions like runif(),\nread.csv(), Sys.time() can return different values.output depends inputs, .e. call \ninputs, get outputs. excludes functions like runif(),\nread.csv(), Sys.time() can return different values.function side-effects, like changing value global\nvariable, writing disk, displaying screen. excludes\nfunctions like print(), write.csv() <-.function side-effects, like changing value global\nvariable, writing disk, displaying screen. excludes\nfunctions like print(), write.csv() <-.Pure functions much easier reason , obviously significant downsides: imagine data analysis couldn’t generate random numbers read files disk.Strictly speaking, R isn’t functional programming language doesn’t require write pure functions. However, can certainly adopt functional style parts code: don’t write pure functions, often . experience, partitioning code functions either extremely pure extremely impure tends lead code easier understand extends new situations.","code":""},{"path":"fp.html","id":"functional-style","chapter":"Introduction","heading":"Functional style","text":"’s hard describe exactly functional style , generally think means decomposing big problem smaller pieces, solving piece function combination functions. using functional style, strive decompose components problem isolated functions operate independently. function taken simple straightforward understand; complexity handled composing functions various ways.following three chapters discuss three key functional techniques help decompose problems smaller pieces:Chapter 9 shows replace many loops \nfunctionals functions (like lapply()) take another\nfunction argument. Functionals allow take function solves\nproblem single input generalise handle number \ninputs. Functionals far away important technique \n’ll use time data analysis.Chapter 9 shows replace many loops \nfunctionals functions (like lapply()) take another\nfunction argument. Functionals allow take function solves\nproblem single input generalise handle number \ninputs. Functionals far away important technique \n’ll use time data analysis.Chapter 10 introduces function factories:\nfunctions create functions. Function factories less commonly\nused functionals, can allow elegantly partition work\ndifferent parts code.Chapter 10 introduces function factories:\nfunctions create functions. Function factories less commonly\nused functionals, can allow elegantly partition work\ndifferent parts code.Chapter 11 shows create function\noperators: functions take functions input produce functions\noutput. like adverbs, typically modify operation\nfunction.Chapter 11 shows create function\noperators: functions take functions input produce functions\noutput. like adverbs, typically modify operation\nfunction.Collectively, types function called higher-order functions fill two--two table:","code":""},{"path":"functionals.html","id":"functionals","chapter":"9 Functionals","heading":"9 Functionals","text":"","code":""},{"path":"functionals.html","id":"introduction-8","chapter":"9 Functionals","heading":"9.1 Introduction","text":"become significantly reliable, code must become transparent.\nparticular, nested conditions loops must viewed great\nsuspicion. Complicated control flows confuse programmers. Messy code often\nhides bugs.— Bjarne StroustrupA functional function takes function input returns vector output. ’s simple functional: calls function provided input 1000 random uniform numbers.chances ’ve already used functional. might used -loop replacements like base R’s lapply(), apply(), tapply(); purrr’s map(); maybe ’ve used mathematical functional like integrate() optim().\ncommon use functionals alternative loops. loops bad rap R many people believe slow51, real downside loops ’re flexible: loop conveys ’re iterating, done results. Just ’s better use repeat, ’s better use (Section 5.3.2), ’s better use functional . functional tailored specific task, recognise functional immediately know ’s used.’re experienced loop user, switching functionals typically pattern matching exercise. look loop find functional matches basic form. one doesn’t exist, don’t try torture existing functional fit form need. Instead, just leave loop! (’ve repeated loop two times, maybe think writing functional).","code":"\nrandomise <- function(f) f(runif(1e3))\nrandomise(mean)\n#> [1] 0.506\nrandomise(mean)\n#> [1] 0.501\nrandomise(sum)\n#> [1] 489"},{"path":"functionals.html","id":"outline-7","chapter":"9 Functionals","heading":"Outline","text":"Section 9.2 introduces first functional: purrr::map().Section 9.2 introduces first functional: purrr::map().Section 9.3 demonstrates can combine multiple simple\nfunctionals solve complex problem discusses purrr style\ndiffers approaches.Section 9.3 demonstrates can combine multiple simple\nfunctionals solve complex problem discusses purrr style\ndiffers approaches.Section 9.4 teaches 18 (!!) important variants \npurrr::map(). Fortunately, orthogonal design makes easy \nlearn, remember, master.Section 9.4 teaches 18 (!!) important variants \npurrr::map(). Fortunately, orthogonal design makes easy \nlearn, remember, master.Section 9.5 introduces new style functional: purrr::reduce().\nreduce() systematically reduces vector single result applying\nfunction takes two inputs.Section 9.5 introduces new style functional: purrr::reduce().\nreduce() systematically reduces vector single result applying\nfunction takes two inputs.Section 9.6 teaches predicates: functions\nreturn single TRUE FALSE, family functionals\nuse solve common problems.Section 9.6 teaches predicates: functions\nreturn single TRUE FALSE, family functionals\nuse solve common problems.Section 9.7 reviews functionals base R \nmembers map, reduce, predicate families.Section 9.7 reviews functionals base R \nmembers map, reduce, predicate families.","code":""},{"path":"functionals.html","id":"prerequisites-3","chapter":"9 Functionals","heading":"Prerequisites","text":"chapter focus functionals provided purrr package.52 functions consistent interface makes easier understand key ideas base equivalents, grown organically many years. ’ll compare contrast base R functions go, wrap chapter discussion base functionals don’t purrr equivalents.","code":"\nlibrary(purrr)"},{"path":"functionals.html","id":"map","chapter":"9 Functionals","heading":"9.2 My first functional: map()","text":"fundamental functional purrr::map()53. takes vector function, calls function element vector, returns results list. words, map(1:3, f) equivalent list(f(1), f(2), f(3))., graphically:might wonder function called map(). depicting physical features land sea 🗺? fact, meaning comes mathematics map refers “operation associates element given set one elements second set.” makes sense map() defines mapping one vector another. (“Map” also nice property short, useful fundamental building block.)implementation map() quite simple. allocate list length input, fill list loop. heart implementation handful lines code:real purrr::map() function differences: written C eke every last iota performance, preserves names, supports shortcuts ’ll learn Section 9.2.2.base equivalent map() lapply(). difference lapply() support helpers ’ll learn , ’re using map() purrr, can skip additional dependency use lapply() directly.","code":"\ntriple <- function(x) x * 3\nmap(1:3, triple)\n#> [[1]]\n#> [1] 3\n#> \n#> [[2]]\n#> [1] 6\n#> \n#> [[3]]\n#> [1] 9\nsimple_map <- function(x, f, ...) {\n  out <- vector(\"list\", length(x))\n  for (i in seq_along(x)) {\n    out[[i]] <- f(x[[i]], ...)\n  }\n  out\n}"},{"path":"functionals.html","id":"map-atomic","chapter":"9 Functionals","heading":"9.2.1 Producing atomic vectors","text":"map() returns list, makes general map family can put anything list. inconvenient return list simpler data structure , four specific variants: map_lgl(), map_int(), map_dbl(), map_chr(). returns atomic vector specified type:purrr uses convention suffixes, like _dbl(), refer output. map_*() functions can take type vector input. examples rely two facts: mtcars data frame, data frames lists containing vectors length. obvious draw data frame orientation vector:map functions always return output vector length input, implies call .f must return single value. , ’ll get error:similar error ’ll get .f returns wrong type result:either case, ’s often useful switch back map(), map() can accept type output. allows see problematic output, figure .Base R two apply functions can return atomic vectors: sapply() vapply(). recommend avoid sapply() tries simplify result, can return list, vector, matrix. makes difficult program , avoided non-interactive settings. vapply() safer allows provide template, FUN.VALUE, describes output shape. don’t want use purrr, recommend always use vapply() functions, sapply(). primary downside vapply() verbosity: example, equivalent map_dbl(x, mean, na.rm = TRUE) vapply(x, mean, na.rm = TRUE, FUN.VALUE = double(1)).","code":"\n# map_chr() always returns a character vector\nmap_chr(mtcars, typeof)\n#>      mpg      cyl     disp       hp     drat       wt     qsec       vs \n#> \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \"double\" \n#>       am     gear     carb \n#> \"double\" \"double\" \"double\"\n\n# map_lgl() always returns a logical vector\nmap_lgl(mtcars, is.double)\n#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#> TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n\n# map_int() always returns a integer vector\nn_unique <- function(x) length(unique(x))\nmap_int(mtcars, n_unique)\n#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#>   25    3   27   22   22   29   30    2    2    3    6\n\n# map_dbl() always returns a double vector\nmap_dbl(mtcars, mean)\n#>     mpg     cyl    disp      hp    drat      wt    qsec      vs      am    gear \n#>  20.091   6.188 230.722 146.688   3.597   3.217  17.849   0.438   0.406   3.688 \n#>    carb \n#>   2.812\npair <- function(x) c(x, x)\nmap_dbl(1:2, pair)\n#> Error: Result 1 must be a single double, not an integer vector of length 2\nmap_dbl(1:2, as.character)\n#> Error: Can't coerce element 1 from a character to a double\nmap(1:2, pair)\n#> [[1]]\n#> [1] 1 1\n#> \n#> [[2]]\n#> [1] 2 2\nmap(1:2, as.character)\n#> [[1]]\n#> [1] \"1\"\n#> \n#> [[2]]\n#> [1] \"2\""},{"path":"functionals.html","id":"purrr-shortcuts","chapter":"9 Functionals","heading":"9.2.2 Anonymous functions and shortcuts","text":"\nInstead using map() existing function, can create inline anonymous function (mentioned Section 6.2.3):Anonymous functions useful, syntax verbose. purrr supports special shortcut:works purrr functions translate formulas, created ~ (pronounced “twiddle”), functions. can see ’s happening behind scenes calling as_mapper():function arguments look little quirky allow refer . one argument functions, .x .y two argument functions, ..1, ..2, ..3, etc, functions arbitrary number arguments. . remains backward compatibility don’t recommend using ’s easily confused . used magrittr’s pipe.shortcut particularly useful generating random data:Reserve syntax short simple functions. good rule thumb function spans lines uses {}, ’s time give name.map functions also shortcuts extracting elements vector, powered purrr::pluck(). can use character vector select elements name, integer vector select position, list select name position. useful working deeply nested lists, often arise working JSON.base R functions, like lapply(), can provide name function string. isn’t tremendously useful lapply(x, \"f\") almost always equivalent lapply(x, f) typing.","code":"\nmap_dbl(mtcars, function(x) length(unique(x)))\n#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#>   25    3   27   22   22   29   30    2    2    3    6\nmap_dbl(mtcars, ~ length(unique(.x)))\n#>  mpg  cyl disp   hp drat   wt qsec   vs   am gear carb \n#>   25    3   27   22   22   29   30    2    2    3    6\nas_mapper(~ length(unique(.x)))\n#> <lambda>\n#> function (..., .x = ..1, .y = ..2, . = ..1) \n#> length(unique(.x))\n#> attr(,\"class\")\n#> [1] \"rlang_lambda_function\" \"function\"\nx <- map(1:3, ~ runif(2))\nstr(x)\n#> List of 3\n#>  $ : num [1:2] 0.281 0.53\n#>  $ : num [1:2] 0.433 0.917\n#>  $ : num [1:2] 0.0275 0.8249\nx <- list(\n  list(-1, x = 1, y = c(2), z = \"a\"),\n  list(-2, x = 4, y = c(5, 6), z = \"b\"),\n  list(-3, x = 8, y = c(9, 10, 11))\n)\n\n# Select by name\nmap_dbl(x, \"x\")\n#> [1] 1 4 8\n\n# Or by position\nmap_dbl(x, 1)\n#> [1] -1 -2 -3\n\n# Or by both\nmap_dbl(x, list(\"y\", 1))\n#> [1] 2 5 9\n\n# You'll get an error if a component doesn't exist:\nmap_chr(x, \"z\")\n#> Error: Result 3 must be a single string, not NULL of length 0\n\n# Unless you supply a .default value\nmap_chr(x, \"z\", .default = NA)\n#> [1] \"a\" \"b\" NA"},{"path":"functionals.html","id":"passing-arguments","chapter":"9 Functionals","heading":"9.2.3 Passing arguments with ...","text":"’s often convenient pass along additional arguments function ’re calling. example, might want pass na.rm = TRUE along mean(). One way anonymous function:map functions pass ... along, ’s simpler form available:easiest understand picture: arguments come f call map() inserted data individual calls f():’s important note arguments decomposed; said another way, map() vectorised first argument. argument f vector, passed along :(’ll learn map variants vectorised multiple arguments Sections 9.4.2 9.4.5.)Note ’s subtle difference placing extra arguments inside anonymous function compared passing map(). Putting anonymous function means evaluated every time f() executed, just call map(). easiest see make additional argument random:","code":"\nx <- list(1:5, c(1:10, NA))\nmap_dbl(x, ~ mean(.x, na.rm = TRUE))\n#> [1] 3.0 5.5\nmap_dbl(x, mean, na.rm = TRUE)\n#> [1] 3.0 5.5\nplus <- function(x, y) x + y\n\nx <- c(0, 0, 0, 0)\nmap_dbl(x, plus, runif(1))\n#> [1] 0.0625 0.0625 0.0625 0.0625\nmap_dbl(x, ~ plus(.x, runif(1)))\n#> [1] 0.903 0.132 0.629 0.945"},{"path":"functionals.html","id":"argument-names","chapter":"9 Functionals","heading":"9.2.4 Argument names","text":"diagrams, ’ve omitted argument names focus overall structure. recommend writing full names code, makes easier read. map(x, mean, 0.1) perfectly valid code, call mean(x[[1]], 0.1) relies reader remembering second argument mean() trim. avoid unnecessary burden brain reader54, kind write map(x, mean, trim = 0.1).reason arguments map() little odd: instead x f, .x .f. ’s easiest see problem leads names using simple_map() defined . simple_map() arguments x f ’ll problems whenever function calling arguments x f:error little bewildering remember call simple_map() equivalent simple_map(x = mtcars, f = mean, bootstrap_summary) named matching beats positional matching.purrr functions reduce likelihood clash using .f .x instead common f x. course technique isn’t perfect (function calling might still use .f .x), avoids 99% issues. remaining 1% time, use anonymous function.Base functions pass along ... use variety naming conventions prevent undesired argument matching:apply family mostly uses capital letters (e.g. X FUN).apply family mostly uses capital letters (e.g. X FUN).transform() uses exotic prefix _: makes name non-syntactic\nmust always surrounded `, described \nSection 2.2.1. makes undesired matches extremely\nunlikely.transform() uses exotic prefix _: makes name non-syntactic\nmust always surrounded `, described \nSection 2.2.1. makes undesired matches extremely\nunlikely.functionals like uniroot() optim() make effort avoid\nclashes tend used specially created functions \nclashes less likely.functionals like uniroot() optim() make effort avoid\nclashes tend used specially created functions \nclashes less likely.","code":"\nboostrap_summary <- function(x, f) {\n  f(sample(x, replace = TRUE))\n}\n\nsimple_map(mtcars, boostrap_summary, f = mean)\n#> Error in mean.default(x[[i]], ...): 'trim' must be numeric of length one"},{"path":"functionals.html","id":"change-argument","chapter":"9 Functionals","heading":"9.2.5 Varying another argument","text":"far first argument map() always become first argument function. happens first argument constant, want vary different argument? get result picture?turns ’s way directly, two tricks can use instead. illustrate , imagine vector contains unusual values, want explore effect different amounts trimming computing mean. case, first argument mean() constant, want vary second argument, trim.simplest technique use anonymous function rearrange \nargument order:\n\nmap_dbl(trims, ~ mean(x, trim = .x))\n#> [1] -0.3500  0.0434  0.0354  0.0502\nstill little confusing ’m using x .x.\ncan make little clearer abandoning ~ helper:\n\nmap_dbl(trims, function(trim) mean(x, trim = trim))\n#> [1] -0.3500  0.0434  0.0354  0.0502The simplest technique use anonymous function rearrange \nargument order:still little confusing ’m using x .x.\ncan make little clearer abandoning ~ helper:Sometimes, want () clever, can take advantage R’s\nflexible argument matching rules (described Section\n6.8.2). example, example can rewrite\nmean(x, trim = 0.1) mean(0.1, x = x), write \ncall map_dbl() :\n\nmap_dbl(trims, mean, x = x)\n#> [1] -0.3500  0.0434  0.0354  0.0502\ndon’t recommend technique relies reader’s familiarity argument order .f, R’s\nargument matching rules.Sometimes, want () clever, can take advantage R’s\nflexible argument matching rules (described Section\n6.8.2). example, example can rewrite\nmean(x, trim = 0.1) mean(0.1, x = x), write \ncall map_dbl() :don’t recommend technique relies reader’s familiarity argument order .f, R’s\nargument matching rules.’ll see one alternative Section 9.4.5.","code":"\ntrims <- c(0, 0.1, 0.2, 0.5)\nx <- rcauchy(1000)\nmap_dbl(trims, ~ mean(x, trim = .x))\n#> [1] -0.3500  0.0434  0.0354  0.0502\nmap_dbl(trims, function(trim) mean(x, trim = trim))\n#> [1] -0.3500  0.0434  0.0354  0.0502\nmap_dbl(trims, mean, x = x)\n#> [1] -0.3500  0.0434  0.0354  0.0502"},{"path":"functionals.html","id":"exercises-28","chapter":"9 Functionals","heading":"9.2.6 Exercises","text":"Use as_mapper() explore purrr generates anonymous functions \ninteger, character, list helpers. helper allows \nextract attributes? Read documentation find .Use as_mapper() explore purrr generates anonymous functions \ninteger, character, list helpers. helper allows \nextract attributes? Read documentation find .map(1:3, ~ runif(2)) useful pattern generating random\nnumbers, map(1:3, runif(2)) . ? Can explain \nreturns result ?map(1:3, ~ runif(2)) useful pattern generating random\nnumbers, map(1:3, runif(2)) . ? Can explain \nreturns result ?Use appropriate map() function :\nCompute standard deviation every column numeric data frame.\nCompute standard deviation every numeric column mixed data\nframe. (Hint: ’ll need two steps.)\nCompute number levels every factor data frame.\nUse appropriate map() function :Compute standard deviation every column numeric data frame.Compute standard deviation every column numeric data frame.Compute standard deviation every numeric column mixed data\nframe. (Hint: ’ll need two steps.)Compute standard deviation every numeric column mixed data\nframe. (Hint: ’ll need two steps.)Compute number levels every factor data frame.Compute number levels every factor data frame.following code simulates performance t-test non-normal\ndata. Extract p-value test, visualise.\n\ntrials <- map(1:100, ~ t.test(rpois(10, 10), rpois(7, 10)))following code simulates performance t-test non-normal\ndata. Extract p-value test, visualise.following code uses map nested inside another map apply \nfunction every element nested list. fail, \nneed make work?\n\nx <- list(\n  list(1, c(3, 9)),\n  list(c(3, 6), 7, c(4, 7, 6))\n)\n\ntriple <- function(x) x * 3\nmap(x, map, .f = triple)\n#> Error .f(.x[[]], ...): unused argument (function (.x, .f, ...) \n#> {\n#>     .f <- as_mapper(.f, ...)\n#>     .Call(map_impl, environment(), \".x\", \".f\", \"list\")\n#> })following code uses map nested inside another map apply \nfunction every element nested list. fail, \nneed make work?Use map() fit linear models mtcars dataset using formulas\nstored list:\n\nformulas <- list(\n  mpg ~ disp,\n  mpg ~ (1 / disp),\n  mpg ~ disp + wt,\n  mpg ~ (1 / disp) + wt\n)Use map() fit linear models mtcars dataset using formulas\nstored list:Fit model mpg ~ disp bootstrap replicates mtcars\nlist , extract \\(R^2\\) model fit (Hint: can\ncompute \\(R^2\\) summary().)\n\nbootstrap <- function(df) {\n  df[sample(nrow(df), replace = TRUE), , drop = FALSE]\n}\n\nbootstraps <- map(1:10, ~ bootstrap(mtcars))Fit model mpg ~ disp bootstrap replicates mtcars\nlist , extract \\(R^2\\) model fit (Hint: can\ncompute \\(R^2\\) summary().)","code":"\ntrials <- map(1:100, ~ t.test(rpois(10, 10), rpois(7, 10)))\nx <- list(\n  list(1, c(3, 9)),\n  list(c(3, 6), 7, c(4, 7, 6))\n)\n\ntriple <- function(x) x * 3\nmap(x, map, .f = triple)\n#> Error in .f(.x[[i]], ...): unused argument (function (.x, .f, ...) \n#> {\n#>     .f <- as_mapper(.f, ...)\n#>     .Call(map_impl, environment(), \".x\", \".f\", \"list\")\n#> })\nformulas <- list(\n  mpg ~ disp,\n  mpg ~ I(1 / disp),\n  mpg ~ disp + wt,\n  mpg ~ I(1 / disp) + wt\n)\nbootstrap <- function(df) {\n  df[sample(nrow(df), replace = TRUE), , drop = FALSE]\n}\n\nbootstraps <- map(1:10, ~ bootstrap(mtcars))"},{"path":"functionals.html","id":"purrr-style","chapter":"9 Functionals","heading":"9.3 Purrr style","text":"go explore map variants, let’s take quick look tend use multiple purrr functions solve moderately realistic problem: fitting model subgroup extracting coefficient model. toy example, ’m going break mtcars data set groups defined number cylinders, using base split function:creates list three data frames: cars 4, 6, 8 cylinders respectively.Now imagine want fit linear model, extract second coefficient (.e. slope). following code shows might purrr:(haven’t seen %>%, pipe, , ’s described Section 6.3.)think code easy read line encapsulates single step, can easily distinguish functional , purrr helpers allow us concisely describe step.attack problem base R? certainly replace purrr function equivalent base function:isn’t really base R since ’re using pipe. tackle purely base think ’d use intermediate variable, step:, course, use loop:’s interesting note move purrr base apply functions loops tend iteration. purrr iterate 3 times (map(), map(), map_dbl()), apply functions iterate twice (lapply(), vapply()), loop iterate . prefer , simpler, steps think makes code easier understand later modify.","code":"\nby_cyl <- split(mtcars, mtcars$cyl)\nby_cyl %>% \n  map(~ lm(mpg ~ wt, data = .x)) %>% \n  map(coef) %>% \n  map_dbl(2)\n#>     4     6     8 \n#> -5.65 -2.78 -2.19\nby_cyl %>% \n  lapply(function(data) lm(mpg ~ wt, data = data)) %>% \n  lapply(coef) %>% \n  vapply(function(x) x[[2]], double(1))\n#>     4     6     8 \n#> -5.65 -2.78 -2.19\nmodels <- lapply(by_cyl, function(data) lm(mpg ~ wt, data = data))\nvapply(models, function(x) coef(x)[[2]], double(1))\n#>     4     6     8 \n#> -5.65 -2.78 -2.19\nslopes <- double(length(by_cyl))\nfor (i in seq_along(by_cyl)) {\n  model <- lm(mpg ~ wt, data = by_cyl[[i]])\n  slopes[[i]] <- coef(model)[[2]]\n}\nslopes\n#> [1] -5.65 -2.78 -2.19"},{"path":"functionals.html","id":"map-variants","chapter":"9 Functionals","heading":"9.4 Map variants","text":"23 primary variants map(). far, ’ve learned five (map(), map_lgl(), map_int(), map_dbl() map_chr()). means ’ve got 18 (!!) learn. sounds like lot, fortunately design purrr means need learn five new ideas:Output type input modify()Iterate two inputs map2().Iterate index using imap()Return nothing walk().Iterate number inputs pmap().map family functions orthogonal input outputs, meaning can organise family matrix, inputs rows outputs columns. ’ve mastered idea row, can combine column; ’ve mastered idea column, can combine row. relationship summarised following table:","code":""},{"path":"functionals.html","id":"modify","chapter":"9 Functionals","heading":"9.4.1 Same type of output as input: modify()","text":"Imagine wanted double every column data frame. might first try using map(), map() always returns list:want keep output data frame, can use modify(), always returns type output input:Despite name, modify() doesn’t modify place, returns modified copy, wanted permanently modify df, ’d need assign :usual, basic implementation modify() simple, fact ’s even simpler map() don’t need create new output vector; can just progressively replace input. (real code little complex handle edge cases gracefully.)Section 9.6.2 ’ll learn useful variant modify(), called modify_if(). allows (e.g.) double numeric columns data frame modify_if(df, .numeric, ~ .x * 2).","code":"\ndf <- data.frame(\n  x = 1:3,\n  y = 6:4\n)\n\nmap(df, ~ .x * 2)\n#> $x\n#> [1] 2 4 6\n#> \n#> $y\n#> [1] 12 10  8\nmodify(df, ~ .x * 2)\n#>   x  y\n#> 1 2 12\n#> 2 4 10\n#> 3 6  8\ndf <- modify(df, ~ .x * 2)\nsimple_modify <- function(x, f, ...) {\n  for (i in seq_along(x)) {\n    x[[i]] <- f(x[[i]], ...)\n  }\n  x\n}"},{"path":"functionals.html","id":"map2","chapter":"9 Functionals","heading":"9.4.2 Two inputs: map2() and friends","text":"map() vectorised single argument, .x. means varies .x calling .f, arguments passed along unchanged, thus making poorly suited problems. example, find weighted mean list observations list weights? Imagine following data:can use map_dbl() compute unweighted means:passing ws additional argument doesn’t work arguments .f transformed:need new tool: map2(), vectorised two arguments. means .x .y varied call .f:arguments map2() slightly different arguments map() two vectors come function, rather one. Additional arguments still go afterwards:basic implementation map2() simple, quite similar map(). Instead iterating one vector, iterate two parallel:One big differences map2() simple function map2() recycles inputs make sure ’re length:words, map2(x, y, f) automatically behave like map(x, f, y) needed. helpful writing functions; scripts ’d generally just use simpler form directly.closest base equivalent map2() Map(), discussed Section 9.4.5.","code":"\nxs <- map(1:8, ~ runif(10))\nxs[[1]][[1]] <- NA\nws <- map(1:8, ~ rpois(10, 5) + 1)\nmap_dbl(xs, mean)\n#> [1]    NA 0.463 0.551 0.453 0.564 0.501 0.371 0.443\nmap_dbl(xs, weighted.mean, w = ws)\n#> Error in weighted.mean.default(.x[[i]], ...): 'x' and 'w' must have the same length\nmap2_dbl(xs, ws, weighted.mean)\n#> [1]    NA 0.451 0.603 0.452 0.563 0.510 0.342 0.464\nmap2_dbl(xs, ws, weighted.mean, na.rm = TRUE)\n#> [1] 0.504 0.451 0.603 0.452 0.563 0.510 0.342 0.464\nsimple_map2 <- function(x, y, f, ...) {\n  out <- vector(\"list\", length(x))\n  for (i in seq_along(x)) {\n    out[[i]] <- f(x[[i]], y[[i]], ...)\n  }\n  out\n}"},{"path":"functionals.html","id":"no-outputs-walk-and-friends","chapter":"9 Functionals","heading":"9.4.3 No outputs: walk() and friends","text":"functions called value return, makes sense capture store value map() function. functions called primarily side-effects (e.g. cat(), write.csv(), ggsave()) doesn’t make sense capture results. Take simple example displays welcome message using cat(). cat() returns NULL, map() works (sense generates desired welcomes), also returns list(NULL, NULL).avoid problem assigning results map() variable never use, muddy intent code. Instead, purrr provides walk family functions ignore return values .f instead return .x invisibly55.visual depiction walk attempts capture important difference map(): outputs ephemeral, input returned invisibly.One useful walk() variants walk2() common side-effect saving something disk, saving something disk always pair values: object path want save .example, imagine list data frames (’ve created using split()), ’d like save one separate CSV file. ’s easy walk2():walk2() equivalent write.csv(cyls[[1]], paths[[1]]), write.csv(cyls[[2]], paths[[2]]), write.csv(cyls[[3]], paths[[3]]).base equivalent walk(); either wrap result lapply() invisible() save variable never used.","code":"\nwelcome <- function(x) {\n  cat(\"Welcome \", x, \"!\\n\", sep = \"\")\n}\nnames <- c(\"Hadley\", \"Jenny\")\n\n# As well as generate the welcomes, it also shows \n# the return value of cat()\nmap(names, welcome)\n#> Welcome Hadley!\n#> Welcome Jenny!\n#> [[1]]\n#> NULL\n#> \n#> [[2]]\n#> NULL\nwalk(names, welcome)\n#> Welcome Hadley!\n#> Welcome Jenny!\ntemp <- tempfile()\ndir.create(temp)\n\ncyls <- split(mtcars, mtcars$cyl)\npaths <- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(cyls, paths, write.csv)\n\ndir(temp)\n#> [1] \"cyl-4.csv\" \"cyl-6.csv\" \"cyl-8.csv\""},{"path":"functionals.html","id":"iterating-over-values-and-indices","chapter":"9 Functionals","heading":"9.4.4 Iterating over values and indices","text":"three basic ways loop vector loop:Loop elements: (x xs)Loop numeric indices: (seq_along(xs))Loop names: (nm names(xs))first form analogous map() family. second third forms equivalent imap() family allows iterate values indices vector parallel.imap() like map2() sense .f gets called two arguments, derived vector. imap(x, f) equivalent map2(x, names(x), f) x names, map2(x, seq_along(x), f) .imap() often useful constructing labels:vector unnamed, second argument index:imap() useful helper want work values vector along positions.","code":"\nimap_chr(iris, ~ paste0(\"The first value of \", .y, \" is \", .x[[1]]))\n#>                             Sepal.Length \n#> \"The first value of Sepal.Length is 5.1\" \n#>                              Sepal.Width \n#>  \"The first value of Sepal.Width is 3.5\" \n#>                             Petal.Length \n#> \"The first value of Petal.Length is 1.4\" \n#>                              Petal.Width \n#>  \"The first value of Petal.Width is 0.2\" \n#>                                  Species \n#>   \"The first value of Species is setosa\"\nx <- map(1:6, ~ sample(1000, 10))\nimap_chr(x, ~ paste0(\"The highest value of \", .y, \" is \", max(.x)))\n#> [1] \"The highest value of 1 is 975\" \"The highest value of 2 is 915\"\n#> [3] \"The highest value of 3 is 982\" \"The highest value of 4 is 955\"\n#> [5] \"The highest value of 5 is 971\" \"The highest value of 6 is 696\""},{"path":"functionals.html","id":"pmap","chapter":"9 Functionals","heading":"9.4.5 Any number of inputs: pmap() and friends","text":"Since map() map2(), might expect map3(), map4(), map5(), … stop? Instead generalising map2() arbitrary number arguments, purrr takes slightly different tack pmap(): supply single list, contains number arguments. cases, list equal-length vectors, .e. something similar data frame. diagrams, ’ll emphasise relationship drawing input similar data frame.’s simple equivalence map2() pmap(): map2(x, y, f) pmap(list(x, y), f). pmap() equivalent map2_dbl(xs, ws, weighted.mean) used :, varying arguments come .f (although now must wrapped list), constant arguments come afterwards.big difference pmap() map functions pmap() gives much finer control argument matching can name components list. Returning example Section 9.2.5, wanted vary trim argument x, instead use pmap():think ’s good practice name components list make clear function called.’s often convenient call pmap() data frame. handy way create data frame tibble::tribble(), allows describe data frame row--row (rather column--column, usual): thinking parameters function data frame powerful pattern. following example shows might draw random uniform numbers varying parameters:\n, column names critical: ’ve carefully chosen match arguments runif(), pmap(params, runif) equivalent runif(n = 1L, min = 0, max = 1), runif(n = 2, min = 10, max = 100), runif(n = 3L, min = 100, max = 1000). (data frame hand, names don’t match, use dplyr::rename() similar.)two base equivalents pmap() family: Map() mapply(). significant drawbacks:Map() vectorises arguments supply arguments \nvary.Map() vectorises arguments supply arguments \nvary.mapply() multidimensional version sapply(); conceptually \ntakes output Map() simplifies possible. gives \nsimilar issues sapply(). multi-input equivalent \nvapply().mapply() multidimensional version sapply(); conceptually \ntakes output Map() simplifies possible. gives \nsimilar issues sapply(). multi-input equivalent \nvapply().","code":"\npmap_dbl(list(xs, ws), weighted.mean)\n#> [1]    NA 0.451 0.603 0.452 0.563 0.510 0.342 0.464\npmap_dbl(list(xs, ws), weighted.mean, na.rm = TRUE)\n#> [1] 0.504 0.451 0.603 0.452 0.563 0.510 0.342 0.464\ntrims <- c(0, 0.1, 0.2, 0.5)\nx <- rcauchy(1000)\n\npmap_dbl(list(trim = trims), mean, x = x)\n#> [1] -6.6740  0.0210  0.0235  0.0151\nparams <- tibble::tribble(\n  ~ n, ~ min, ~ max,\n   1L,     0,     1,\n   2L,    10,   100,\n   3L,   100,  1000\n)\n\npmap(params, runif)\n#> [[1]]\n#> [1] 0.332\n#> \n#> [[2]]\n#> [1] 53.5 47.6\n#> \n#> [[3]]\n#> [1] 231 715 515"},{"path":"functionals.html","id":"exercises-29","chapter":"9 Functionals","heading":"9.4.6 Exercises","text":"Explain results modify(mtcars, 1).Explain results modify(mtcars, 1).Rewrite following code use iwalk() instead walk2(). \nadvantages disadvantages?\n\ncyls <- split(mtcars, mtcars$cyl)\npaths <- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(cyls, paths, write.csv)Rewrite following code use iwalk() instead walk2(). \nadvantages disadvantages?Explain following code transforms data frame using functions\nstored list.\n\ntrans <- list(\n  disp = function(x) x * 0.0163871,\n  = function(x) factor(x, labels = c(\"auto\", \"manual\"))\n)\n\nnm <- names(trans)\nmtcars[nm] <- map2(trans, mtcars[nm], function(f, var) f(var))\nCompare contrast map2() approach map() approach:\n\nmtcars[nm] <- map(nm, ~ trans[[.x]](mtcars[[.x]]))Explain following code transforms data frame using functions\nstored list.Compare contrast map2() approach map() approach:write.csv() return, .e. happens use \nmap2() instead walk2()?write.csv() return, .e. happens use \nmap2() instead walk2()?","code":"\ncyls <- split(mtcars, mtcars$cyl)\npaths <- file.path(temp, paste0(\"cyl-\", names(cyls), \".csv\"))\nwalk2(cyls, paths, write.csv)\ntrans <- list(\n  disp = function(x) x * 0.0163871,\n  am = function(x) factor(x, labels = c(\"auto\", \"manual\"))\n)\n\nnm <- names(trans)\nmtcars[nm] <- map2(trans, mtcars[nm], function(f, var) f(var))\nmtcars[nm] <- map(nm, ~ trans[[.x]](mtcars[[.x]]))"},{"path":"functionals.html","id":"reduce","chapter":"9 Functionals","heading":"9.5 Reduce family","text":"map family, next important family functions reduce family. family much smaller, two main variants, used less commonly, ’s powerful idea, gives us opportunity discuss useful algebra, powers map-reduce framework frequently used processing large datasets.","code":""},{"path":"functionals.html","id":"basics-1","chapter":"9 Functionals","heading":"9.5.1 Basics","text":"reduce() takes vector length n produces vector length 1 calling function pair values time: reduce(1:4, f) equivalent f(f(f(1, 2), 3), 4).reduce() useful way generalise function works two inputs (binary function) work number inputs. Imagine list numeric vectors, want find values occur every element. First generate sample data:solve challenge need use intersect() repeatedly:reduce() automates solution us, can write:apply idea wanted list elements appear least one entry. switch intersect() union():Like map family, can also pass additional arguments. intersect() union() don’t take extra arguments can’t demonstrate , principle straightforward drew picture.usual, essence reduce() can reduced simple wrapper around loop:base equivalent Reduce(). Note argument order different: function comes first, followed vector, way supply additional arguments.","code":"\nl <- map(1:4, ~ sample(1:10, 15, replace = T))\nstr(l)\n#> List of 4\n#>  $ : int [1:15] 7 1 8 8 3 8 2 4 7 10 ...\n#>  $ : int [1:15] 3 1 10 2 5 2 9 8 5 4 ...\n#>  $ : int [1:15] 6 10 9 5 6 7 8 6 10 8 ...\n#>  $ : int [1:15] 9 8 6 4 4 5 2 9 9 6 ...\nout <- l[[1]]\nout <- intersect(out, l[[2]])\nout <- intersect(out, l[[3]])\nout <- intersect(out, l[[4]])\nout\n#> [1] 8 4\nreduce(l, intersect)\n#> [1] 8 4\nreduce(l, union)\n#>  [1]  7  1  8  3  2  4 10  5  9  6\nsimple_reduce <- function(x, f) {\n  out <- x[[1]]\n  for (i in seq(2, length(x))) {\n    out <- f(out, x[[i]])\n  }\n  out\n}"},{"path":"functionals.html","id":"accumulate","chapter":"9 Functionals","heading":"9.5.2 Accumulate","text":"first reduce() variant, accumulate(), useful understanding reduce works, instead returning just final result, returns intermediate results well:Another useful way understand reduce think sum(): sum(x) equivalent x[[1]] + x[[2]] + x[[3]] + ..., .e. reduce(x, `+`). accumulate(x, `+`) cumulative sum:","code":"\naccumulate(l, intersect)\n#> [[1]]\n#>  [1]  7  1  8  8  3  8  2  4  7 10 10  3  7 10 10\n#> \n#> [[2]]\n#> [1]  1  8  3  2  4 10\n#> \n#> [[3]]\n#> [1]  8  4 10\n#> \n#> [[4]]\n#> [1] 8 4\nx <- c(4, 3, 10)\nreduce(x, `+`)\n#> [1] 17\n\naccumulate(x, `+`)\n#> [1]  4  7 17"},{"path":"functionals.html","id":"output-types","chapter":"9 Functionals","heading":"9.5.3 Output types","text":"example using +, reduce() return x short, .e. length 1 0? Without additional arguments, reduce() just returns input x length 1:means reduce() way check input valid:’s length 0? get error suggests need use .init argument:.init ? figure , need see happens .init supplied:call reduce(1, `+`, init) result 1 + init. Now know result just 1, suggests .init 0:also ensures reduce() checks length 1 inputs valid function ’re calling:want get algebraic , 0 called identity real numbers operation addition: add 0 number, get number back. R applies principle determine summary function zero length input return:’re using reduce() function, always supply .init. Think carefully function return pass vector length 0 1, make sure test implementation.","code":"\nreduce(1, `+`)\n#> [1] 1\nreduce(\"a\", `+`)\n#> [1] \"a\"\nreduce(integer(), `+`)\n#> Error: `.x` is empty, and no `.init` supplied\nreduce(integer(), `+`, .init = 0)\n#> [1] 0\nreduce(\"a\", `+`, .init = 0)\n#> Error in .x + .y: argumento no-numérico para operador binario\nsum(integer())  # x + 0 = x\n#> [1] 0\nprod(integer()) # x * 1 = x\n#> [1] 1\nmin(integer())  # min(x, Inf) = x\n#> [1] Inf\nmax(integer())  # max(x, -Inf) = x\n#> [1] -Inf"},{"path":"functionals.html","id":"multiple-inputs","chapter":"9 Functionals","heading":"9.5.4 Multiple inputs","text":"occasionally need pass two arguments function ’re reducing. example, might list data frames want join together, variables use join vary element element. specialised scenario, don’t want spend much time , want know reduce2() exists.length second argument varies based whether .init supplied: four elements x, f called three times. supply init, f called four times.","code":""},{"path":"functionals.html","id":"map-reduce","chapter":"9 Functionals","heading":"9.5.5 Map-reduce","text":"might heard map-reduce, idea powers technology like Hadoop. Now can see simple powerful underlying idea : map-reduce map combined reduce. difference large data data spread multiple computers. computer performs map data , sends result back coordinator reduces individual results back single result.simple example, imagine computing mean large vector, large split multiple computers. ask computer calculate sum length, return coordinator computes overall mean dividing total sum total length.","code":""},{"path":"functionals.html","id":"predicate-functionals","chapter":"9 Functionals","heading":"9.6 Predicate functionals","text":"\npredicate function returns single TRUE FALSE, like .character(), .null(), (), say predicate matches vector returns TRUE.","code":""},{"path":"functionals.html","id":"basics-2","chapter":"9 Functionals","heading":"9.6.1 Basics","text":"predicate functional applies predicate element vector. purrr provides seven useful functions come three groups:(.x, .p) returns TRUE element matches;every(.x, .p) returns TRUE elements match;none(.x, .p) returns TRUE element matches.\nsimilar (map_lgl(.x, .p)), (map_lgl(.x, .p)) \n(map_lgl(.x, negate(.p))) terminate early: () returns\nTRUE sees first TRUE, every() none() return\nFALSE see first FALSE TRUE respectively.(.x, .p) returns TRUE element matches;every(.x, .p) returns TRUE elements match;none(.x, .p) returns TRUE element matches.similar (map_lgl(.x, .p)), (map_lgl(.x, .p)) \n(map_lgl(.x, negate(.p))) terminate early: () returns\nTRUE sees first TRUE, every() none() return\nFALSE see first FALSE TRUE respectively.detect(.x, .p) returns value first match;\ndetect_index(.x, .p) returns location first match.detect(.x, .p) returns value first match;\ndetect_index(.x, .p) returns location first match.keep(.x, .p) keeps matching elements;\ndiscard(.x, .p) drops matching elements.keep(.x, .p) keeps matching elements;\ndiscard(.x, .p) drops matching elements.following example shows might use functionals data frame:","code":"\ndf <- data.frame(x = 1:3, y = c(\"a\", \"b\", \"c\"))\ndetect(df, is.factor)\n#> NULL\ndetect_index(df, is.factor)\n#> [1] 0\n\nstr(keep(df, is.factor))\n#> 'data.frame':    3 obs. of  0 variables\nstr(discard(df, is.factor))\n#> 'data.frame':    3 obs. of  2 variables:\n#>  $ x: int  1 2 3\n#>  $ y: chr  \"a\" \"b\" \"c\""},{"path":"functionals.html","id":"predicate-map","chapter":"9 Functionals","heading":"9.6.2 Map variants","text":"map() modify() come variants also take predicate functions, transforming elements .x .p TRUE.","code":"\ndf <- data.frame(\n  num1 = c(0, 10, 20),\n  num2 = c(5, 6, 7),\n  chr1 = c(\"a\", \"b\", \"c\"),\n  stringsAsFactors = FALSE\n)\n\nstr(map_if(df, is.numeric, mean))\n#> List of 3\n#>  $ num1: num 10\n#>  $ num2: num 6\n#>  $ chr1: chr [1:3] \"a\" \"b\" \"c\"\nstr(modify_if(df, is.numeric, mean))\n#> 'data.frame':    3 obs. of  3 variables:\n#>  $ num1: num  10 10 10\n#>  $ num2: num  6 6 6\n#>  $ chr1: chr  \"a\" \"b\" \"c\"\nstr(map(keep(df, is.numeric), mean))\n#> List of 2\n#>  $ num1: num 10\n#>  $ num2: num 6"},{"path":"functionals.html","id":"exercises-30","chapter":"9 Functionals","heading":"9.6.3 Exercises","text":"isn’t .na() predicate function? base R function closest\npredicate version .na()?isn’t .na() predicate function? base R function closest\npredicate version .na()?simple_reduce() problem x length 0 length 1. Describe\nsource problem might go fixing .\n\nsimple_reduce <- function(x, f) {\n  <- x[[1]]\n  (seq(2, length(x))) {\n    <- f(, x[[]])\n  }\n  \n}simple_reduce() problem x length 0 length 1. Describe\nsource problem might go fixing .Implement span() function Haskell: given list x \npredicate function f, span(x, f) returns location longest\nsequential run elements predicate true. (Hint: \nmight find rle() helpful.)Implement span() function Haskell: given list x \npredicate function f, span(x, f) returns location longest\nsequential run elements predicate true. (Hint: \nmight find rle() helpful.)Implement arg_max(). take function vector inputs,\nreturn elements input function returns highest\nvalue. example, arg_max(-10:5, function(x) x ^ 2) return -10.\narg_max(-5:5, function(x) x ^ 2) return c(-5, 5).\nAlso implement matching arg_min() function.Implement arg_max(). take function vector inputs,\nreturn elements input function returns highest\nvalue. example, arg_max(-10:5, function(x) x ^ 2) return -10.\narg_max(-5:5, function(x) x ^ 2) return c(-5, 5).\nAlso implement matching arg_min() function.function scales vector falls range [0, 1]. \napply every column data frame? apply \nevery numeric column data frame?\n\nscale01 <- function(x) {\n  rng <- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}function scales vector falls range [0, 1]. \napply every column data frame? apply \nevery numeric column data frame?","code":"\nsimple_reduce <- function(x, f) {\n  out <- x[[1]]\n  for (i in seq(2, length(x))) {\n    out <- f(out, x[[i]])\n  }\n  out\n}\nscale01 <- function(x) {\n  rng <- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}"},{"path":"functionals.html","id":"base-functionals","chapter":"9 Functionals","heading":"9.7 Base functionals","text":"finish chapter, provide survey important base functionals members map, reduce, predicate families, hence equivalent purrr. say ’re important, mathematical statistical flavour, generally less useful data analysis.","code":""},{"path":"functionals.html","id":"matrices-and-arrays","chapter":"9 Functionals","heading":"9.7.1 Matrices and arrays","text":"map() friends specialised work one-dimensional vectors. base::apply() specialised work two-dimensional higher vectors, .e. matrices arrays. can think apply() operation summarises matrix array collapsing row column single value. four arguments:X, matrix array summarise.X, matrix array summarise.MARGIN, integer vector giving dimensions summarise ,\n1 = rows, 2 = columns, etc. (argument name comes thinking \nmargins joint distribution.)MARGIN, integer vector giving dimensions summarise ,\n1 = rows, 2 = columns, etc. (argument name comes thinking \nmargins joint distribution.)FUN, summary function.FUN, summary function.... arguments passed FUN.... arguments passed FUN.typical example apply() looks like thisYou can specify multiple dimensions MARGIN, useful high-dimensional arrays:two caveats using apply():Like base::sapply(), control output type; \nautomatically simplified list, matrix, vector. However,\nusually use apply() numeric arrays numeric summary\nfunction less likely encounter problem \nsapply().Like base::sapply(), control output type; \nautomatically simplified list, matrix, vector. However,\nusually use apply() numeric arrays numeric summary\nfunction less likely encounter problem \nsapply().apply() also idempotent sense summary\nfunction identity operator, output always \ninput.\n\na1 <- apply(a2d, 1, identity)\nidentical(a2d, a1)\n#> [1] FALSE\n\na2 <- apply(a2d, 2, identity)\nidentical(a2d, a2)\n#> [1] TRUEapply() also idempotent sense summary\nfunction identity operator, output always \ninput.Never use apply() data frame. always coerces matrix,\nlead undesirable results data frame contains anything\nnumbers.\n\ndf <- data.frame(x = 1:3, y = c(\"\", \"b\", \"c\"))\napply(df, 2, mean)\n#> Warning mean.default(newX[, ], ...): argument numeric logical:\n#> returning NA\n\n#> Warning mean.default(newX[, ], ...): argument numeric logical:\n#> returning NA\n#>  x  y \n#> NA NANever use apply() data frame. always coerces matrix,\nlead undesirable results data frame contains anything\nnumbers.","code":"\na2d <- matrix(1:20, nrow = 5)\napply(a2d, 1, mean)\n#> [1]  8.5  9.5 10.5 11.5 12.5\napply(a2d, 2, mean)\n#> [1]  3  8 13 18\na3d <- array(1:24, c(2, 3, 4))\napply(a3d, 1, mean)\n#> [1] 12 13\napply(a3d, c(1, 2), mean)\n#>      [,1] [,2] [,3]\n#> [1,]   10   12   14\n#> [2,]   11   13   15\na1 <- apply(a2d, 1, identity)\nidentical(a2d, a1)\n#> [1] FALSE\n\na2 <- apply(a2d, 2, identity)\nidentical(a2d, a2)\n#> [1] TRUE\ndf <- data.frame(x = 1:3, y = c(\"a\", \"b\", \"c\"))\napply(df, 2, mean)\n#> Warning in mean.default(newX[, i], ...): argument is not numeric or logical:\n#> returning NA\n\n#> Warning in mean.default(newX[, i], ...): argument is not numeric or logical:\n#> returning NA\n#>  x  y \n#> NA NA"},{"path":"functionals.html","id":"mathematical-concerns","chapter":"9 Functionals","heading":"9.7.2 Mathematical concerns","text":"Functionals common mathematics. limit, maximum, roots (set points f(x) = 0), definite integral functionals: given function, return single number (vector numbers). first glance, functions don’t seem fit theme eliminating loops, dig deeper ’ll find implemented using algorithm involves iteration.Base R provides useful set:integrate() finds area curve defined f()uniroot() finds f() hits zerooptimise() finds location lowest (highest) value f()following example shows functionals might used simple function, sin():","code":"\nintegrate(sin, 0, pi)\n#> 2 with absolute error < 2.2e-14\nstr(uniroot(sin, pi * c(1 / 2, 3 / 2)))\n#> List of 5\n#>  $ root      : num 3.14\n#>  $ f.root    : num 1.22e-16\n#>  $ iter      : int 2\n#>  $ init.it   : int NA\n#>  $ estim.prec: num 6.1e-05\nstr(optimise(sin, c(0, 2 * pi)))\n#> List of 2\n#>  $ minimum  : num 4.71\n#>  $ objective: num -1\nstr(optimise(sin, c(0, pi), maximum = TRUE))\n#> List of 2\n#>  $ maximum  : num 1.57\n#>  $ objective: num 1"},{"path":"functionals.html","id":"exercises-31","chapter":"9 Functionals","heading":"9.7.3 Exercises","text":"apply() arrange output? Read documentation perform\nexperiments.apply() arrange output? Read documentation perform\nexperiments.eapply() rapply() ? purrr equivalents?eapply() rapply() ? purrr equivalents?Challenge: read \nfixed point algorithm.\nComplete exercises using R.Challenge: read \nfixed point algorithm.\nComplete exercises using R.","code":""},{"path":"function-factories.html","id":"function-factories","chapter":"10 Function factories","heading":"10 Function factories","text":"","code":""},{"path":"function-factories.html","id":"introduction-9","chapter":"10 Function factories","heading":"10.1 Introduction","text":"function factory function makes functions. ’s simple example: use function factory (power1()) make two child functions (square() cube()):Don’t worry doesn’t make sense yet, end chapter!\n\n’ll call square() cube() manufactured functions, just term ease communication humans: R’s perspective different functions created way.already learned individual components make function factories possible:Section 6.2.3, learned R’s first-class\nfunctions. R, bind function name way bind\nobject name: <-.Section 6.2.3, learned R’s first-class\nfunctions. R, bind function name way bind\nobject name: <-.Section 7.4.2, learned function\ncaptures (encloses) environment created.Section 7.4.2, learned function\ncaptures (encloses) environment created.Section 7.4.4, learned function\ncreates new execution environment every time run. environment\nusually ephemeral, becomes enclosing environment \nmanufactured function.Section 7.4.4, learned function\ncreates new execution environment every time run. environment\nusually ephemeral, becomes enclosing environment \nmanufactured function.chapter, ’ll learn non-obvious combination three features leads function factory. ’ll also see examples usage visualisation statistics.three main functional programming tools (functionals, function factories, function operators), function factories least used. Generally, don’t tend reduce overall code complexity instead partition complexity easily digested chunks. Function factories also important building block useful function operators, ’ll learn Chapter 11.","code":"\npower1 <- function(exp) {\n  function(x) {\n    x ^ exp\n  }\n}\n\nsquare <- power1(2)\ncube <- power1(3)\nsquare(3)\n#> [1] 9\ncube(3)\n#> [1] 27"},{"path":"function-factories.html","id":"outline-8","chapter":"10 Function factories","heading":"Outline","text":"Section 10.2 begins chapter explanation\nfunction factories work, pulling together ideas scoping \nenvironments. ’ll also see function factories can used implement\nmemory functions, allowing data persist across calls.Section 10.2 begins chapter explanation\nfunction factories work, pulling together ideas scoping \nenvironments. ’ll also see function factories can used implement\nmemory functions, allowing data persist across calls.Section 10.3 illustrates use function factories \nexamples ggplot2. ’ll see two examples ggplot2 works\nuser supplied function factories, one example ggplot2\nuses function factory internally.Section 10.3 illustrates use function factories \nexamples ggplot2. ’ll see two examples ggplot2 works\nuser supplied function factories, one example ggplot2\nuses function factory internally.Section 10.4 uses function factories tackle three challenges \nstatistics: understanding Box-Cox transform, solving maximum likelihood\nproblems, drawing bootstrap resamples.Section 10.4 uses function factories tackle three challenges \nstatistics: understanding Box-Cox transform, solving maximum likelihood\nproblems, drawing bootstrap resamples.Section 10.5 shows can combine function\nfactories functionals rapidly generate family functions data.Section 10.5 shows can combine function\nfactories functionals rapidly generate family functions data.","code":""},{"path":"function-factories.html","id":"prerequisites-4","chapter":"10 Function factories","heading":"Prerequisites","text":"Make sure ’re familiar contents Sections 6.2.3 (first-class functions), 7.4.2 (function environment), 7.4.4 (execution environments) mentioned .Function factories need base R. ’ll use little rlang peek inside easily, ’ll use ggplot2 scales explore use function factories visualisation.","code":"\nlibrary(rlang)\nlibrary(ggplot2)\n#> Warning: package 'ggplot2' was built under R version 4.1.2\nlibrary(scales)"},{"path":"function-factories.html","id":"factory-fundamentals","chapter":"10 Function factories","heading":"10.2 Factory fundamentals","text":"key idea makes function factories work can expressed concisely:enclosing environment manufactured function execution\nenvironment function factory.takes words express big ideas, takes lot work really understand means. section help put pieces together interactive exploration diagrams.","code":""},{"path":"function-factories.html","id":"environments-1","chapter":"10 Function factories","heading":"10.2.1 Environments","text":"Let’s start taking look square() cube():’s obvious x comes , R find value associated exp? Simply printing manufactured functions revealing bodies identical; contents enclosing environment important factors. can get little insight using rlang::env_print(). shows us two different environments (originally execution environment power1()). environments parent, enclosing environment power1(), global environment.env_print() shows us environments binding exp, want see value56. can first getting environment function, extracting values:makes manufactured functions behave differently one another: names enclosing environment bound different values.","code":"\nsquare\n#> function(x) {\n#>     x ^ exp\n#>   }\n#> <environment: 0x0000000027247650>\n\ncube\n#> function(x) {\n#>     x ^ exp\n#>   }\n#> <bytecode: 0x0000000027375640>\n#> <environment: 0x0000000027296ff0>\nenv_print(square)\n#> <environment: 0000000027247650>\n#> parent: <environment: global>\n#> bindings:\n#>  * exp: <dbl>\n\nenv_print(cube)\n#> <environment: 0000000027296FF0>\n#> parent: <environment: global>\n#> bindings:\n#>  * exp: <dbl>\nfn_env(square)$exp\n#> [1] 2\n\nfn_env(cube)$exp\n#> [1] 3"},{"path":"function-factories.html","id":"diagram-conventions","chapter":"10 Function factories","heading":"10.2.2 Diagram conventions","text":"can also show relationships diagram:’s lot going diagram details aren’t important. can simplify considerably using two conventions:free floating symbol lives global environment.free floating symbol lives global environment.environment without explicit parent inherits global\nenvironment.environment without explicit parent inherits global\nenvironment.view, focuses environments, doesn’t show direct link cube() square(). ’s link body function, identical , shown diagram.finish , let’s look execution environment square(10). square() executes x ^ exp finds x execution environment exp enclosing environment.","code":"\nsquare(10)\n#> [1] 100"},{"path":"function-factories.html","id":"forcing-evaluation","chapter":"10 Function factories","heading":"10.2.3 Forcing evaluation","text":"’s subtle bug power1() caused lazy evaluation. see problem need introduce indirection:square(2) return? hope returns 4:Unfortunately doesn’t x evaluated lazily square() run, power1() run. general, problem arise whenever binding changes calling factory function calling manufactured function. likely happen rarely, , lead real head-scratcher bug.can fix problem forcing evaluation force():Whenever create function factory, make sure every argument evaluated, using force() necessary argument used manufactured function.","code":"\nx <- 2\nsquare <- power1(x)\nx <- 3\nsquare(2)\n#> [1] 8\npower2 <- function(exp) {\n  force(exp)\n  function(x) {\n    x ^ exp\n  }\n}\n\nx <- 2\nsquare <- power2(x)\nx <- 3\nsquare(2)\n#> [1] 4"},{"path":"function-factories.html","id":"stateful-funs","chapter":"10 Function factories","heading":"10.2.4 Stateful functions","text":"Function factories also allow maintain state across function invocations, generally hard fresh start principle described Section 6.4.3.two things make possible:enclosing environment manufactured function unique constant.enclosing environment manufactured function unique constant.R special assignment operator, <<-, modifies bindings \nenclosing environment.R special assignment operator, <<-, modifies bindings \nenclosing environment.usual assignment operator, <-, always creates binding current environment. super assignment operator, <<- rebinds existing name found parent environment.following example shows can combine ideas create function records many times called:manufactured function run <<- + 1 modify enclosing environment. manufactured functions independent enclosing environments, independent counts:Stateful functions best used moderation. soon function starts managing state multiple variables, ’s better switch R6, topic Chapter 14.","code":"\nnew_counter <- function() {\n  i <- 0\n  \n  function() {\n    i <<- i + 1\n    i\n  }\n}\n\ncounter_one <- new_counter()\ncounter_two <- new_counter()\ncounter_one()\n#> [1] 1\ncounter_one()\n#> [1] 2\ncounter_two()\n#> [1] 1"},{"path":"function-factories.html","id":"factory-pitfalls","chapter":"10 Function factories","heading":"10.2.5 Garbage collection","text":"functions, can rely garbage collector clean large temporary objects created inside function. However, manufactured functions hold execution environment, ’ll need explicitly unbind large temporary objects rm(). Compare sizes g1() g2() example :","code":"\nf1 <- function(n) {\n  x <- runif(n)\n  m <- mean(x)\n  function() m\n}\n\ng1 <- f1(1e6)\nlobstr::obj_size(g1)\n#> 8,013,136 B\n\nf2 <- function(n) {\n  x <- runif(n)\n  m <- mean(x)\n  rm(x)\n  function() m\n}\n\ng2 <- f2(1e6)\nlobstr::obj_size(g2)\n#> 12,976 B"},{"path":"function-factories.html","id":"exercises-32","chapter":"10 Function factories","heading":"10.2.6 Exercises","text":"definition force() simple:\n\nforce\n#> function (x) \n#> x\n#> <bytecode: 0x0000000012897478>\n#> <environment: namespace:base>\nbetter force(x) instead just x?definition force() simple:better force(x) instead just x?Base R contains two function factories, approxfun() ecdf().\nRead documentation experiment figure functions\nreturn.Base R contains two function factories, approxfun() ecdf().\nRead documentation experiment figure functions\nreturn.Create function pick() takes index, , argument \nreturns function argument x subsets x .\n\npick(1)(x)\n# equivalent \nx[[1]]\n\nlapply(mtcars, pick(5))\n# equivalent \nlapply(mtcars, function(x) x[[5]])Create function pick() takes index, , argument \nreturns function argument x subsets x .Create function creates functions compute ithcentral moment numeric\nvector. can test running following code:\n\nm1 <- moment(1)\nm2 <- moment(2)\n\nx <- runif(100)\nstopifnot(.equal(m1(x), 0))\nstopifnot(.equal(m2(x), var(x) * 99 / 100))Create function creates functions compute ithcentral moment numeric\nvector. can test running following code:happens don’t use closure? Make predictions, verify \ncode .\n\n<- 0\nnew_counter2 <- function() {\n  <<- + 1\n  \n}happens don’t use closure? Make predictions, verify \ncode .happens use <- instead <<-? Make predictions, verify\ncode .\n\nnew_counter3 <- function() {\n  <- 0\n  function() {\n    <- + 1\n    \n  }\n}happens use <- instead <<-? Make predictions, verify\ncode .","code":"\nforce\n#> function (x) \n#> x\n#> <bytecode: 0x0000000012897478>\n#> <environment: namespace:base>\npick(1)(x)\n# should be equivalent to\nx[[1]]\n\nlapply(mtcars, pick(5))\n# should be equivalent to\nlapply(mtcars, function(x) x[[5]])\nm1 <- moment(1)\nm2 <- moment(2)\n\nx <- runif(100)\nstopifnot(all.equal(m1(x), 0))\nstopifnot(all.equal(m2(x), var(x) * 99 / 100))\ni <- 0\nnew_counter2 <- function() {\n  i <<- i + 1\n  i\n}\nnew_counter3 <- function() {\n  i <- 0\n  function() {\n    i <- i + 1\n    i\n  }\n}"},{"path":"function-factories.html","id":"graph-fact","chapter":"10 Function factories","heading":"10.3 Graphical factories","text":"’ll begin exploration useful function factories examples ggplot2.","code":""},{"path":"function-factories.html","id":"labelling","chapter":"10 Function factories","heading":"10.3.1 Labelling","text":"One goals scales package make easy customise labels ggplot2. provides many functions control fine details axes legends. formatter functions57 useful class functions make easier control appearance axis breaks. design functions might initially seem little odd: return function, call order format number.words, primary interface function factory. first glance, seems add extra complexity little gain. enables nice interaction ggplot2’s scales, accept functions label argument:","code":"\ny <- c(12345, 123456, 1234567)\ncomma_format()(y)\n#> [1] \"12,345\"    \"123,456\"   \"1,234,567\"\n\nnumber_format(scale = 1e-3, suffix = \" K\")(y)\n#> [1] \"12 K\"    \"123 K\"   \"1 235 K\"\ndf <- data.frame(x = 1, y = y)\ncore <- ggplot(df, aes(x, y)) + \n  geom_point() + \n  scale_x_continuous(breaks = 1, labels = NULL) +\n  labs(x = NULL, y = NULL)\n  \ncore\ncore + scale_y_continuous(\n  labels = comma_format()\n)\ncore + scale_y_continuous(\n  labels = number_format(scale = 1e-3, suffix = \" K\")\n)\ncore + scale_y_continuous(\n  labels = scientific_format()\n)"},{"path":"function-factories.html","id":"histogram-bins","chapter":"10 Function factories","heading":"10.3.2 Histogram bins","text":"little known feature geom_histogram() binwidth argument can function. particularly useful function executed group, means can different binwidths different facets, otherwise possible.illustrate idea, see variable binwidth might useful, ’m going construct example fixed binwidth isn’t great.facet number observations, variability different. nice request binwidths vary get approximately number observations bin. One way function factory inputs desired number bins (n), outputs function takes numeric vector returns binwidth:use pattern wrap around base R functions automatically find -called optimal58 binwidth, nclass.Sturges(), nclass.scott(), nclass.FD():","code":"\n# construct some sample data with very different numbers in each cell\nsd <- c(1, 5, 15)\nn <- 100\n\ndf <- data.frame(x = rnorm(3 * n, sd = sd), sd = rep(sd, n))\n\nggplot(df, aes(x)) + \n  geom_histogram(binwidth = 2) + \n  facet_wrap(~ sd, scales = \"free_x\") + \n  labs(x = NULL)\nbinwidth_bins <- function(n) {\n  force(n)\n  \n  function(x) {\n    (max(x) - min(x)) / n\n  }\n}\n\nggplot(df, aes(x)) + \n  geom_histogram(binwidth = binwidth_bins(20)) + \n  facet_wrap(~ sd, scales = \"free_x\") + \n  labs(x = NULL)\nbase_bins <- function(type) {\n  fun <- switch(type,\n    Sturges = nclass.Sturges,\n    scott = nclass.scott,\n    FD = nclass.FD,\n    stop(\"Unknown type\", call. = FALSE)\n  )\n  \n  function(x) {\n    (max(x) - min(x)) / fun(x)\n  }\n}\n\nggplot(df, aes(x)) + \n  geom_histogram(binwidth = base_bins(\"FD\")) + \n  facet_wrap(~ sd, scales = \"free_x\") + \n  labs(x = NULL)"},{"path":"function-factories.html","id":"ggsave","chapter":"10 Function factories","heading":"10.3.3 ggsave()","text":"Finally, want show function factory used internally ggplot2. ggplot2:::plot_dev() used ggsave() go file extension (e.g. png, jpeg etc) graphics device function (e.g. png(), jpeg()). challenge arises base graphics devices minor inconsistencies need paper :filename first argument file.filename first argument file.width height raster graphic devices use pixels units\ndefault, vector graphics use inches.width height raster graphic devices use pixels units\ndefault, vector graphics use inches.mildly simplified version plot_dev() shown :","code":"\nplot_dev <- function(ext, dpi = 96) {\n  force(dpi)\n  \n  switch(ext,\n    eps =  ,\n    ps  =  function(path, ...) {\n      grDevices::postscript(\n        file = filename, ..., onefile = FALSE, \n        horizontal = FALSE, paper = \"special\"\n      )\n    },\n    pdf = function(filename, ...) grDevices::pdf(file = filename, ...),\n    svg = function(filename, ...) svglite::svglite(file = filename, ...),\n    emf = ,\n    wmf = function(...) grDevices::win.metafile(...),\n    png = function(...) grDevices::png(..., res = dpi, units = \"in\"),\n    jpg = ,\n    jpeg = function(...) grDevices::jpeg(..., res = dpi, units = \"in\"),\n    bmp = function(...) grDevices::bmp(..., res = dpi, units = \"in\"),\n    tiff = function(...) grDevices::tiff(..., res = dpi, units = \"in\"),\n    stop(\"Unknown graphics extension: \", ext, call. = FALSE)\n  )\n}\n\nplot_dev(\"pdf\")\n#> function(filename, ...) grDevices::pdf(file = filename, ...)\n#> <bytecode: 0x000000002d5fde38>\n#> <environment: 0x000000002d331d60>\nplot_dev(\"png\")\n#> function(...) grDevices::png(..., res = dpi, units = \"in\")\n#> <bytecode: 0x000000002808f230>\n#> <environment: 0x0000000027e28380>"},{"path":"function-factories.html","id":"exercises-33","chapter":"10 Function factories","heading":"10.3.4 Exercises","text":"Compare contrast ggplot2::label_bquote() \nscales::number_format()","code":""},{"path":"function-factories.html","id":"stat-fact","chapter":"10 Function factories","heading":"10.4 Statistical factories","text":"motivating examples function factories come statistics:Box-Cox transformation.Bootstrap resampling.Maximum likelihood estimation.examples can tackled without function factories, think function factories good fit problems provide elegant solutions. examples expect statistical background, feel free skip don’t make much sense .","code":""},{"path":"function-factories.html","id":"box-cox-transformation","chapter":"10 Function factories","heading":"10.4.1 Box-Cox transformation","text":"Box-Cox transformation (type power transformation) flexible transformation often used transform data towards normality. single parameter, \\(\\lambda\\), controls strength transformation. express transformation simple two argument function:re-formulating function factory makes easy explore behaviour stat_function():general, allows use Box-Cox transformation function accepts unary transformation function: don’t worry function providing ... pass along additional arguments. also think partitioning lambda x two different function arguments natural since lambda plays quite different role x.","code":"\nboxcox1 <- function(x, lambda) {\n  stopifnot(length(lambda) == 1)\n  \n  if (lambda == 0) {\n    log(x)\n  } else {\n    (x ^ lambda - 1) / lambda\n  }\n}\nboxcox2 <- function(lambda) {\n  if (lambda == 0) {\n    function(x) log(x)\n  } else {\n    function(x) (x ^ lambda - 1) / lambda\n  }\n}\n\nstat_boxcox <- function(lambda) {\n  stat_function(aes(colour = lambda), fun = boxcox2(lambda), size = 1)\n}\n\nggplot(data.frame(x = c(0, 5)), aes(x)) + \n  lapply(c(0.5, 1, 1.5), stat_boxcox) + \n  scale_colour_viridis_c(limits = c(0, 1.5))\n\n# visually, log() does seem to make sense as the transformation\n# for lambda = 0; as values get smaller and smaller, the function\n# gets close and closer to a log transformation\nggplot(data.frame(x = c(0.01, 1)), aes(x)) + \n  lapply(c(0.5, 0.25, 0.1, 0), stat_boxcox) + \n  scale_colour_viridis_c(limits = c(0, 1.5))"},{"path":"function-factories.html","id":"bootstrap-generators","chapter":"10 Function factories","heading":"10.4.2 Bootstrap generators","text":"Function factories useful approach bootstrapping. Instead thinking single bootstrap (always need one!), can think bootstrap generator, function yields fresh bootstrap every time called:advantage function factory clear parametric bootstrap first fit model. can setup step , factory called, rather every time generate bootstrap:use rm(mod) linear model objects quite large (include complete copies model matrix input data) want keep manufactured function small possible.","code":"\nboot_permute <- function(df, var) {\n  n <- nrow(df)\n  force(var)\n  \n  function() {\n    col <- df[[var]]\n    col[sample(n, replace = TRUE)]\n  }\n}\n\nboot_mtcars1 <- boot_permute(mtcars, \"mpg\")\nhead(boot_mtcars1())\n#> [1] 16.4 22.8 22.8 22.8 16.4 19.2\nhead(boot_mtcars1())\n#> [1] 17.8 18.7 30.4 30.4 16.4 21.0\nboot_model <- function(df, formula) {\n  mod <- lm(formula, data = df)\n  fitted <- unname(fitted(mod))\n  resid <- unname(resid(mod))\n  rm(mod)\n\n  function() {\n    fitted + sample(resid)\n  }\n} \n\nboot_mtcars2 <- boot_model(mtcars, mpg ~ wt)\nhead(boot_mtcars2())\n#> [1] 25.0 24.0 21.7 19.2 24.9 16.0\nhead(boot_mtcars2())\n#> [1] 27.4 21.0 20.3 19.4 16.3 21.3"},{"path":"function-factories.html","id":"MLE","chapter":"10 Function factories","heading":"10.4.3 Maximum likelihood estimation","text":"\n\ngoal maximum likelihood estimation (MLE) find parameter values distribution make observed data likely. MLE, start probability function. example, take Poisson distribution. know \\(\\lambda\\), can compute probability getting vector \\(\\mathbf{x}\\) values (\\(x_1\\), \\(x_2\\), …, \\(x_n\\)) multiplying Poisson probability function follows:\\[ P(\\lambda, \\mathbf{x}) = \\prod_{=1}^{n} \\frac{\\lambda ^ {x_i} e^{-\\lambda}}{x_i!} \\]statistics, almost always work log function. log monotonic transformation preserves important properties (.e. extrema occur place), specific advantages:log turns product sum, easier work .log turns product sum, easier work .Multiplying small numbers yields even smaller numbers, makes \nfloating point approximation used computer less accurate.Multiplying small numbers yields even smaller numbers, makes \nfloating point approximation used computer less accurate.Let’s apply log transformation probability function simplify much possible:\\[ \\log(P(\\lambda, \\mathbf{x})) = \\sum_{=1}^{n} \\log(\\frac{\\lambda ^ {x_i} e^{-\\lambda}}{x_i!}) \\]\\[ \\log(P(\\lambda, \\mathbf{x})) = \\sum_{=1}^{n} \\left( x_i \\log(\\lambda) - \\lambda - \\log(x_i!) \\right) \\]\\[ \\log(P(\\lambda, \\mathbf{x})) = \n     \\sum_{=1}^{n} x_i \\log(\\lambda)\n   - \\sum_{=1}^{n} \\lambda \n   - \\sum_{=1}^{n} \\log(x_i!) \\]\\[ \\log(P(\\lambda, \\mathbf{x})) = \n   \\log(\\lambda) \\sum_{=1}^{n} x_i - n \\lambda - \\sum_{=1}^{n} \\log(x_i!) \\]can now turn function R function. R function quite elegant R vectorised , ’s statistical programming language, R comes built-functions like log-factorial (lfactorial()).Consider vector observations:can use lprob_poisson() compute (logged) probability x1 different values lambda.far ’ve thinking lambda fixed known function told us probability getting different values x. real-life, observe x lambda unknown. likelihood probability function seen lens: want find lambda makes observed x likely. , given x, value lambda gives us highest value lprob_poisson()?statistics, highlight change perspective writing \\(f_{\\mathbf{x}}(\\lambda)\\) instead \\(f(\\lambda, \\mathbf{x})\\). R, can use function factory. provide x generate function single parameter, lambda:(don’t need force() length() implicitly forces evaluation x.)One nice thing approach can precomputation: term involves x can computed factory. useful ’re going need call function many times find best lambda.Now can use function find value lambda maximizes (log) likelihood:Rather trial error, can automate process finding best value optimise(). evaluate ll1() many times, using mathematical tricks narrow largest value quickly possible. results tell us highest value -30.27 occurs lambda = 32.1:Now, solved problem without using function factory optimise() passes ... function optimised. means use log-probability function directly:advantage using function factory fairly small, two niceties:can precompute values factory, saving computation time\niteration.can precompute values factory, saving computation time\niteration.two-level design better reflects mathematical structure \nunderlying problem.two-level design better reflects mathematical structure \nunderlying problem.advantages get bigger complex MLE problems, multiple parameters multiple data vectors.","code":"\nlprob_poisson <- function(lambda, x) {\n  n <- length(x)\n  (log(lambda) * sum(x)) - (n * lambda) - sum(lfactorial(x))\n}\nx1 <- c(41, 30, 31, 38, 29, 24, 30, 29, 31, 38)\nlprob_poisson(10, x1)\n#> [1] -184\nlprob_poisson(20, x1)\n#> [1] -61.1\nlprob_poisson(30, x1)\n#> [1] -31\nll_poisson1 <- function(x) {\n  n <- length(x)\n\n  function(lambda) {\n    log(lambda) * sum(x) - n * lambda - sum(lfactorial(x))\n  }\n}\nll_poisson2 <- function(x) {\n  n <- length(x)\n  sum_x <- sum(x)\n  c <- sum(lfactorial(x))\n\n  function(lambda) {\n    log(lambda) * sum_x - n * lambda - c\n  }\n}\nll1 <- ll_poisson2(x1)\n\nll1(10)\n#> [1] -184\nll1(20)\n#> [1] -61.1\nll1(30)\n#> [1] -31\noptimise(ll1, c(0, 100), maximum = TRUE)\n#> $maximum\n#> [1] 32.1\n#> \n#> $objective\n#> [1] -30.3\noptimise(lprob_poisson, c(0, 100), x = x1, maximum = TRUE)\n#> $maximum\n#> [1] 32.1\n#> \n#> $objective\n#> [1] -30.3"},{"path":"function-factories.html","id":"exercises-34","chapter":"10 Function factories","heading":"10.4.4 Exercises","text":"boot_model(), don’t need force evaluation df\nmodel?boot_model(), don’t need force evaluation df\nmodel?might formulate Box-Cox transformation like ?\n\nboxcox3 <- function(x) {\n  function(lambda) {\n    (lambda == 0) {\n      log(x)\n    } else {\n      (x ^ lambda - 1) / lambda\n    }\n  }  \n}might formulate Box-Cox transformation like ?don’t need worry boot_permute() stores copy \ndata inside function generates?don’t need worry boot_permute() stores copy \ndata inside function generates?much time ll_poisson2() save compared ll_poisson1()?\nUse bench::mark() see much faster optimisation occurs.\nchanging length x change results?much time ll_poisson2() save compared ll_poisson1()?\nUse bench::mark() see much faster optimisation occurs.\nchanging length x change results?","code":"\nboxcox3 <- function(x) {\n  function(lambda) {\n    if (lambda == 0) {\n      log(x)\n    } else {\n      (x ^ lambda - 1) / lambda\n    }\n  }  \n}"},{"path":"function-factories.html","id":"functional-factories","chapter":"10 Function factories","heading":"10.5 Function factories + functionals","text":"finish chapter, ’ll show might combine functionals function factories turn data many functions. following code creates many specially named power functions iterating list arguments:idea extends straightforward way function factory takes two (replace map() map2()) (replace pmap()) arguments.One downside current construction prefix every function call funs$. three ways eliminate additional syntax:temporary effect, can use ():\n\n(funs, root(100))\n#> [1] 10\nrecommend makes clear code \nexecuted special context context .temporary effect, can use ():recommend makes clear code \nexecuted special context context .longer effect, can attach() functions search path,\ndetach() ’re done:\n\nattach(funs)\n#> following objects masked _by_ .GlobalEnv:\n#> \n#>     cube, square\nroot(100)\n#> [1] 10\ndetach(funs)\n’ve probably told avoid using attach(), ’s generally\ngood advice. However, situation little different usual\n’re attaching list functions, data frame. ’s less\nlikely ’ll modify function column data frame, \nworst problems attach() don’t apply.longer effect, can attach() functions search path,\ndetach() ’re done:’ve probably told avoid using attach(), ’s generally\ngood advice. However, situation little different usual\n’re attaching list functions, data frame. ’s less\nlikely ’ll modify function column data frame, \nworst problems attach() don’t apply.Finally, copy functions global environment \nenv_bind() (’ll learn !!! Section 19.6).\nmostly permanent:\n\nrlang::env_bind(globalenv(), !!!funs)\nroot(100)\n#> [1] 10\ncan later unbind names, ’s guarantee \nhaven’t rebound meantime, might deleting \nobject someone else created.\n\nrlang::env_unbind(globalenv(), names(funs))Finally, copy functions global environment \nenv_bind() (’ll learn !!! Section 19.6).\nmostly permanent:can later unbind names, ’s guarantee \nhaven’t rebound meantime, might deleting \nobject someone else created.’ll learn alternative approach problem Section 19.7.4. Instead using function factory, construct function quasiquotation. requires additional knowledge, generates functions readable bodies, avoids accidentally capturing large objects enclosing scope. use idea Section 21.2.4 work tools generating HTML R.","code":"\nnames <- list(\n  square = 2, \n  cube = 3, \n  root = 1/2, \n  cuberoot = 1/3, \n  reciprocal = -1\n)\nfuns <- purrr::map(names, power1)\n\nfuns$root(64)\n#> [1] 8\nfuns$root\n#> function(x) {\n#>     x ^ exp\n#>   }\n#> <bytecode: 0x0000000027375640>\n#> <environment: 0x000000002ba6a780>\nwith(funs, root(100))\n#> [1] 10\nattach(funs)\n#> The following objects are masked _by_ .GlobalEnv:\n#> \n#>     cube, square\nroot(100)\n#> [1] 10\ndetach(funs)\nrlang::env_bind(globalenv(), !!!funs)\nroot(100)\n#> [1] 10\nrlang::env_unbind(globalenv(), names(funs))"},{"path":"function-factories.html","id":"exercises-35","chapter":"10 Function factories","heading":"10.5.1 Exercises","text":"following commands equivalent (x, f(z))?\nx$f(x$z).\nf(x$z).\nx$f(z).\nf(z).\ndepends.\nfollowing commands equivalent (x, f(z))?x$f(x$z).f(x$z).x$f(z).f(z).depends.Compare contrast effects env_bind() vs. attach() \nfollowing code.\n\nfuns <- list(\n  mean = function(x) mean(x, na.rm = TRUE),\n  sum = function(x) sum(x, na.rm = TRUE)\n)\n\nattach(funs)\n#> following objects masked package:base:\n#> \n#>     mean, sum\nmean <- function(x) stop(\"Hi!\")\ndetach(funs)\n\nenv_bind(globalenv(), !!!funs)\nmean <- function(x) stop(\"Hi!\") \nenv_unbind(globalenv(), names(funs))Compare contrast effects env_bind() vs. attach() \nfollowing code.","code":"\nfuns <- list(\n  mean = function(x) mean(x, na.rm = TRUE),\n  sum = function(x) sum(x, na.rm = TRUE)\n)\n\nattach(funs)\n#> The following objects are masked from package:base:\n#> \n#>     mean, sum\nmean <- function(x) stop(\"Hi!\")\ndetach(funs)\n\nenv_bind(globalenv(), !!!funs)\nmean <- function(x) stop(\"Hi!\") \nenv_unbind(globalenv(), names(funs))"},{"path":"function-operators.html","id":"function-operators","chapter":"11 Function operators","heading":"11 Function operators","text":"","code":""},{"path":"function-operators.html","id":"introduction-10","chapter":"11 Function operators","heading":"11.1 Introduction","text":"chapter, ’ll learn function operators. function operator function takes one () functions input returns function output. following code shows simple function operator, chatty(). wraps function, making new function prints first argument. might create function like gives window see functionals, like map_int(), work.Function operators closely related function factories; indeed ’re just function factory takes function input. Like factories, ’s nothing can’t without , often allow factor complexity order make code readable reusable.Function operators typically paired functionals. ’re using -loop, ’s rarely reason use function operator, make code complex little gain.’re familiar Python, decorators just another name function operators.","code":"\nchatty <- function(f) {\n  force(f)\n  \n  function(x, ...) {\n    res <- f(x, ...)\n    cat(\"Processing \", x, \"\\n\", sep = \"\")\n    res\n  }\n}\nf <- function(x) x ^ 2\ns <- c(3, 2, 1)\n\npurrr::map_dbl(s, chatty(f))\n#> Processing 3\n#> Processing 2\n#> Processing 1\n#> [1] 9 4 1"},{"path":"function-operators.html","id":"outline-9","chapter":"11 Function operators","heading":"Outline","text":"Section 11.2 introduces two extremely useful existing\nfunction operators, shows use solve real problems.Section 11.2 introduces two extremely useful existing\nfunction operators, shows use solve real problems.Section 11.3 works problem amenable solution\nfunction operators: downloading many web pages.Section 11.3 works problem amenable solution\nfunction operators: downloading many web pages.","code":""},{"path":"function-operators.html","id":"prerequisites-5","chapter":"11 Function operators","heading":"Prerequisites","text":"Function operators type function factory, make sure ’re familiar least Section 6.2 go .’ll use purrr couple functionals learned Chapter 9, function operators ’ll learn . ’ll also use memoise package59 memoise() operator.","code":"\nlibrary(purrr)\nlibrary(memoise)"},{"path":"function-operators.html","id":"existing-fos","chapter":"11 Function operators","heading":"11.2 Existing function operators","text":"two useful function operators help solve common recurring problems, give sense function operators can : purrr::safely() memoise::memoise().","code":""},{"path":"function-operators.html","id":"safely","chapter":"11 Function operators","heading":"11.2.1 Capturing errors with purrr::safely()","text":"One advantage -loops one iterations fails, can still access results failure:thing functional, get output, making hard figure problem lies:purrr::safely() provides tool help problem. safely() function operator transforms function turn errors data. (can learn basic idea makes work Section 8.6.2.) Let’s start taking look outside map_dbl():Like function operators, safely() takes function returns wrapped function can call usual:can see function transformed safely() always returns list two elements, result error. function runs successfully, error NULL result contains result; function fails, result NULL error contains error.Now lets use safely() functional:output slightly inconvenient form, since four lists, list containing result error. can make output easier use turning “inside-” purrr::transpose(), get list results list errors:Now can easily find results worked, inputs failed:can use technique many different situations. example, imagine ’re fitting generalised linear model (GLM) list data frames. GLMs can sometimes fail optimisation problems, still want able try fit models, later look back failed:think great example power combining functionals function operators: safely() lets succinctly express need solve common data analysis problem.purrr comes three function operators similar vein:possibly(): returns default value ’s error.\nprovides way tell error occured , ’s best\nreserved cases ’s obvious sentinel value (like NA).possibly(): returns default value ’s error.\nprovides way tell error occured , ’s best\nreserved cases ’s obvious sentinel value (like NA).quietly(): turns output, messages, warning side-effects \noutput, message, warning components output.quietly(): turns output, messages, warning side-effects \noutput, message, warning components output.auto_browser(): automatically executes browser() inside \nfunction ’s error.auto_browser(): automatically executes browser() inside \nfunction ’s error.See documentation details.","code":"\nx <- list(\n  c(0.512, 0.165, 0.717),\n  c(0.064, 0.781, 0.427),\n  c(0.890, 0.785, 0.495),\n  \"oops\"\n)\n\nout <- rep(NA_real_, length(x))\nfor (i in seq_along(x)) {\n  out[[i]] <- sum(x[[i]])\n}\n#> Error in sum(x[[i]]): 'type' (character) de argumento no válido\nout\n#> [1] 1.39 1.27 2.17   NA\nmap_dbl(x, sum)\n#> Error in .Primitive(\"sum\")(..., na.rm = na.rm): 'type' (character) de argumento no válido\nsafe_sum <- safely(sum)\nsafe_sum\n#> function (...) \n#> capture_error(.f(...), otherwise, quiet)\n#> <bytecode: 0x00000000159e83c0>\n#> <environment: 0x00000000159e8bd8>\nstr(safe_sum(x[[1]]))\n#> List of 2\n#>  $ result: num 1.39\n#>  $ error : NULL\nstr(safe_sum(x[[4]]))\n#> List of 2\n#>  $ result: NULL\n#>  $ error :List of 2\n#>   ..$ message: chr \"'type' (character) de argumento no válido\"\n#>   ..$ call   : language .Primitive(\"sum\")(..., na.rm = na.rm)\n#>   ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\nout <- map(x, safely(sum))\nstr(out)\n#> List of 4\n#>  $ :List of 2\n#>   ..$ result: num 1.39\n#>   ..$ error : NULL\n#>  $ :List of 2\n#>   ..$ result: num 1.27\n#>   ..$ error : NULL\n#>  $ :List of 2\n#>   ..$ result: num 2.17\n#>   ..$ error : NULL\n#>  $ :List of 2\n#>   ..$ result: NULL\n#>   ..$ error :List of 2\n#>   .. ..$ message: chr \"'type' (character) de argumento no válido\"\n#>   .. ..$ call   : language .Primitive(\"sum\")(..., na.rm = na.rm)\n#>   .. ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\nout <- transpose(map(x, safely(sum)))\nstr(out)\n#> List of 2\n#>  $ result:List of 4\n#>   ..$ : num 1.39\n#>   ..$ : num 1.27\n#>   ..$ : num 2.17\n#>   ..$ : NULL\n#>  $ error :List of 4\n#>   ..$ : NULL\n#>   ..$ : NULL\n#>   ..$ : NULL\n#>   ..$ :List of 2\n#>   .. ..$ message: chr \"'type' (character) de argumento no válido\"\n#>   .. ..$ call   : language .Primitive(\"sum\")(..., na.rm = na.rm)\n#>   .. ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\nok <- map_lgl(out$error, is.null)\nok\n#> [1]  TRUE  TRUE  TRUE FALSE\n\nx[!ok]\n#> [[1]]\n#> [1] \"oops\"\n\nout$result[ok]\n#> [[1]]\n#> [1] 1.39\n#> \n#> [[2]]\n#> [1] 1.27\n#> \n#> [[3]]\n#> [1] 2.17\nfit_model <- function(df) {\n  glm(y ~ x1 + x2 * x3, data = df)\n}\n\nmodels <- transpose(map(datasets, safely(fit_model)))\nok <- map_lgl(models$error, is.null)\n\n# which data failed to converge?\ndatasets[!ok]\n\n# which models were successful?\nmodels[ok]"},{"path":"function-operators.html","id":"memoise","chapter":"11 Function operators","heading":"11.2.2 Caching computations with memoise::memoise()","text":"\nAnother handy function operator memoise::memoise(). memoises function, meaning function remember previous inputs return cached results. Memoisation example classic computer science tradeoff memory versus speed. memoised function can run much faster, stores previous inputs outputs, uses memory.Let’s explore idea toy function simulates expensive operation:memoise function, ’s slow call new arguments. call arguments ’s seen ’s instantaneous: retrieves previous value computation.relatively realistic use memoisation computing Fibonacci series. Fibonacci series defined recursively: first two values defined convention, \\(f(0) = 0\\), \\(f(1) = 1\\), \\(f(n) = f(n - 1) + f(n - 2)\\) (positive integer). naive version slow , example, fib(10) computes fib(9) fib(8), fib(9) computes fib(8) fib(7), .Memoising fib() makes implementation much faster value computed :future calls can rely previous computations:example dynamic programming, complex problem can broken many overlapping subproblems, remembering results subproblem considerably improves performance.Think carefully memoising function. function pure, .e. output depend input, get misleading confusing results. created subtle bug devtools memoised results available.packages(), rather slow download large file CRAN. available packages don’t change frequently, R process ’s running days, changes can become important, problem arose long-running R processes, bug painful find.","code":"\nslow_function <- function(x) {\n  Sys.sleep(1)\n  x * 10 * runif(1)\n}\nsystem.time(print(slow_function(1)))\n#> [1] 0.808\n#>    user  system elapsed \n#>    0.00    0.00    1.02\n\nsystem.time(print(slow_function(1)))\n#> [1] 8.34\n#>    user  system elapsed \n#>    0.00    0.00    1.02\nfast_function <- memoise::memoise(slow_function)\nsystem.time(print(fast_function(1)))\n#> [1] 6.01\n#>    user  system elapsed \n#>    0.00    0.00    1.02\n\nsystem.time(print(fast_function(1)))\n#> [1] 6.01\n#>    user  system elapsed \n#>    0.03    0.00    0.03\nfib <- function(n) {\n  if (n < 2) return(1)\n  fib(n - 2) + fib(n - 1)\n}\nsystem.time(fib(23))\n#>    user  system elapsed \n#>    0.09    0.00    0.10\nsystem.time(fib(24))\n#>    user  system elapsed \n#>    0.13    0.00    0.12\nfib2 <- memoise::memoise(function(n) {\n  if (n < 2) return(1)\n  fib2(n - 2) + fib2(n - 1)\n})\nsystem.time(fib2(23))\n#>    user  system elapsed \n#>    0.03    0.00    0.04\nsystem.time(fib2(24))\n#>    user  system elapsed \n#>       0       0       0"},{"path":"function-operators.html","id":"exercises-36","chapter":"11 Function operators","heading":"11.2.3 Exercises","text":"Base R provides function operator form Vectorize().\n? might use ?Base R provides function operator form Vectorize().\n? might use ?Read source code possibly(). work?Read source code possibly(). work?Read source code safely(). work?Read source code safely(). work?","code":""},{"path":"function-operators.html","id":"fo-case-study","chapter":"11 Function operators","heading":"11.3 Case study: Creating your own function operators","text":"meomoise() safely() useful also quite complex. case study ’ll learn create simpler function operators. Imagine named vector URLs ’d like download one disk. ’s pretty simple walk2() file.download():approach fine handful URLs, vector gets longer, might want add couple features:Add small delay request avoid hammering server.Add small delay request avoid hammering server.Display . every URLs know function still\nworking.Display . every URLs know function still\nworking.’s relatively easy add extra features ’re using loop:think loop suboptimal interleaves different concerns: pausing, showing progress, downloading. makes code harder read, makes harder reuse components new situations. Instead, let’s see can use function operators extract pausing showing progress make reusable.First, let’s write function operator adds small delay. ’m going call delay_by() reasons clear shortly, two arguments: function wrap, amount delay add. actual implementation quite simple. main trick forcing evaluation arguments described Section 10.2.5, function operators special type function factory:can use original walk2():Creating function display occasional dot little harder, can longer rely index loop. pass index along another argument, breaks encapsulation: concern progress function now becomes problem higher level wrapper needs handle. Instead, ’ll use another function factory trick (Section 10.2.4), progress wrapper can manage internal counter:Now can express original loop :starting get little hard read composing many function calls, arguments getting spread . One way resolve use pipe:pipe works well ’ve carefully chosen function names yield (almost) readable sentence: take download.file (add) dot every 10 iterations, delay 0.1s. clearly can express intent code function names, easily others (including future !) can read understand code.","code":"\nurls <- c(\n  \"adv-r\" = \"https://adv-r.hadley.nz\", \n  \"r4ds\" = \"http://r4ds.had.co.nz/\"\n  # and many many more\n)\npath <- paste(tempdir(), names(urls), \".html\")\n\nwalk2(urls, path, download.file, quiet = TRUE)\nfor(i in seq_along(urls)) {\n  Sys.sleep(0.1)\n  if (i %% 10 == 0) cat(\".\")\n  download.file(urls[[i]], paths[[i]])\n}\ndelay_by <- function(f, amount) {\n  force(f)\n  force(amount)\n  \n  function(...) {\n    Sys.sleep(amount)\n    f(...)\n  }\n}\nsystem.time(runif(100))\n#>    user  system elapsed \n#>       0       0       0\nsystem.time(delay_by(runif, 0.1)(100))\n#>    user  system elapsed \n#>     0.0     0.0     0.1\nwalk2(urls, path, delay_by(download.file, 0.1), quiet = TRUE)\ndot_every <- function(f, n) {\n  force(f)\n  force(n)\n  \n  i <- 0\n  function(...) {\n    i <<- i + 1\n    if (i %% n == 0) cat(\".\")\n    f(...)\n  }\n}\nwalk(1:100, runif)\nwalk(1:100, dot_every(runif, 10))\n#> ..........\nwalk2(\n  urls, path, \n  dot_every(delay_by(download.file, 0.1), 10), \n  quiet = TRUE\n)\nwalk2(\n  urls, path, \n  download.file %>% dot_every(10) %>% delay_by(0.1), \n  quiet = TRUE\n)"},{"path":"function-operators.html","id":"exercises-37","chapter":"11 Function operators","heading":"11.3.1 Exercises","text":"Weigh pros cons \ndownload.file %>% dot_every(10) %>% delay_by(0.1) versus\ndownload.file %>% delay_by(0.1) %>% dot_every(10).Weigh pros cons \ndownload.file %>% dot_every(10) %>% delay_by(0.1) versus\ndownload.file %>% delay_by(0.1) %>% dot_every(10).memoise file.download()? ?memoise file.download()? ?Create function operator reports whenever file created \ndeleted working directory, using dir() setdiff(). \nglobal function effects might want track?Create function operator reports whenever file created \ndeleted working directory, using dir() setdiff(). \nglobal function effects might want track?Write function operator logs timestamp message file\nevery time function run.Write function operator logs timestamp message file\nevery time function run.Modify delay_by() instead delaying fixed amount time,\nensures certain amount time elapsed since function\nlast called. , called\ng <- delay_by(1, f); g(); Sys.sleep(2); g() shouldn’t \nextra delay.Modify delay_by() instead delaying fixed amount time,\nensures certain amount time elapsed since function\nlast called. , called\ng <- delay_by(1, f); g(); Sys.sleep(2); g() shouldn’t \nextra delay.","code":""},{"path":"oo.html","id":"oo","chapter":"Introduction","heading":"Introduction","text":"following five chapters ’ll learn object-oriented programming (OOP). OOP little challenging R languages :multiple OOP systems choose . book, ’ll focus\nthree believe important: S3, R6, S4.\nS3 S4 provided base R. R6 provided R6 package, \nsimilar Reference Classes, RC short, base R.multiple OOP systems choose . book, ’ll focus\nthree believe important: S3, R6, S4.\nS3 S4 provided base R. R6 provided R6 package, \nsimilar Reference Classes, RC short, base R.disagreement relative importance OOP systems.\nthink S3 important, followed R6, S4. Others believe \nS4 important, followed RC, S3 avoided. \nmeans different R communities use different systems.disagreement relative importance OOP systems.\nthink S3 important, followed R6, S4. Others believe \nS4 important, followed RC, S3 avoided. \nmeans different R communities use different systems.S3 S4 use generic function OOP rather different \nencapsulated OOP used languages popular today60. ’ll come\nback precisely terms mean shortly, basically, \nunderlying ideas OOP across languages, expressions \nrather different. means can’t immediately transfer \nexisting OOP skills R.S3 S4 use generic function OOP rather different \nencapsulated OOP used languages popular today60. ’ll come\nback precisely terms mean shortly, basically, \nunderlying ideas OOP across languages, expressions \nrather different. means can’t immediately transfer \nexisting OOP skills R.Generally R, functional programming much important object-oriented programming, typically solve complex problems decomposing simple functions, simple objects. Nevertheless, important reasons learn three systems:S3 allows functions return rich results user-friendly display\nprogrammer-friendly internals. S3 used throughout base R, ’s\nimportant master want extend base R functions work new\ntypes input.S3 allows functions return rich results user-friendly display\nprogrammer-friendly internals. S3 used throughout base R, ’s\nimportant master want extend base R functions work new\ntypes input.R6 provides standardised way escape R’s copy--modify semantics.\nparticularly important want model objects exist\nindependently R. Today, common need R6 model data comes\nweb API, changes come inside outside R.R6 provides standardised way escape R’s copy--modify semantics.\nparticularly important want model objects exist\nindependently R. Today, common need R6 model data comes\nweb API, changes come inside outside R.S4 rigorous system forces think carefully program\ndesign. ’s particularly well-suited building large systems evolve\ntime receive contributions many programmers. \nused Bioconductor project, another reason learn S4\nequip contribute project.S4 rigorous system forces think carefully program\ndesign. ’s particularly well-suited building large systems evolve\ntime receive contributions many programmers. \nused Bioconductor project, another reason learn S4\nequip contribute project.goal brief introductory chapter give important vocabulary tools identify OOP systems wild. following chapters dive details R’s OOP systems:Chapter 12 details base types form foundation\nunderlying OO system.Chapter 12 details base types form foundation\nunderlying OO system.Chapter 13 introduces S3, simplest commonly used\nOO system.Chapter 13 introduces S3, simplest commonly used\nOO system.Chapter 14 discusses R6, encapsulated OO system built \ntop environments.Chapter 14 discusses R6, encapsulated OO system built \ntop environments.Chapter 15 introduces S4, similar S3 formal \nstrict.Chapter 15 introduces S4, similar S3 formal \nstrict.Chapter 16 compares three main OO systems. \nunderstanding trade-offs system can appreciate use\none .Chapter 16 compares three main OO systems. \nunderstanding trade-offs system can appreciate use\none .book focusses mechanics OOP, effective use, may challenging fully understand done object-oriented programming . might wonder chose provide immediately useful coverage. focused mechanics need well described somewhere (writing chapters required considerable amount reading, exploration, synthesis behalf), using OOP effectively sufficiently complex require book-length treatment; ’s simply enough room Advanced R cover depth required.","code":""},{"path":"oo.html","id":"oop-systems","chapter":"Introduction","heading":"OOP systems","text":"Different people use OOP terms different ways, section provides quick overview important vocabulary. explanations necessarily compressed, come back ideas multiple times.main reason use OOP polymorphism (literally: many shapes). Polymorphism means developer can consider function’s interface separately implementation, making possible use function form different types input. closely related idea encapsulation: user doesn’t need worry details object encapsulated behind standard interface.concrete, polymorphism allows summary() produce different outputs numeric factor variables:imagine summary() containing series -else statements, mean original author add new implementations. OOP system makes possible developer extend interface implementations new types input.precise, OO systems call type object class, implementation specific class called method. Roughly speaking, class defines object methods describe object can .\nclass defines fields, data possessed every instance class. Classes organised hierarchy method exist one class, parent’s method used, child said inherit behaviour. example, R, ordered factor inherits regular factor, generalised linear model inherits linear model. process finding correct method given class called method dispatch.two main paradigms object-oriented programming differ methods classes related. book, ’ll borrow terminology Extending R61 call paradigms encapsulated functional:encapsulated OOP, methods belong objects classes, method\ncalls typically look like object.method(arg1, arg2). called\nencapsulated object encapsulates data (fields) \nbehaviour (methods), paradigm found popular\nlanguages.encapsulated OOP, methods belong objects classes, method\ncalls typically look like object.method(arg1, arg2). called\nencapsulated object encapsulates data (fields) \nbehaviour (methods), paradigm found popular\nlanguages.functional OOP, methods belong generic functions, method\ncalls look like ordinary function calls: generic(object, arg2, arg3).\ncalled functional outside looks like regular\nfunction call, internally components also functions.functional OOP, methods belong generic functions, method\ncalls look like ordinary function calls: generic(object, arg2, arg3).\ncalled functional outside looks like regular\nfunction call, internally components also functions.terminology hand, can now talk precisely different OO systems available R.","code":"\ndiamonds <- ggplot2::diamonds\n\nsummary(diamonds$carat)\n#>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#>    0.20    0.40    0.70    0.80    1.04    5.01\n\nsummary(diamonds$cut)\n#>      Fair      Good Very Good   Premium     Ideal \n#>      1610      4906     12082     13791     21551"},{"path":"oo.html","id":"oop-in-r","chapter":"Introduction","heading":"OOP in R","text":"Base R provides three OOP systems: S3, S4, reference classes (RC):S3 R’s first OOP system, described Statistical Models\nS.62 S3 informal implementation functional OOP\nrelies common conventions rather ironclad guarantees.\nmakes easy get started , providing low cost way \nsolving many simple problems.S3 R’s first OOP system, described Statistical Models\nS.62 S3 informal implementation functional OOP\nrelies common conventions rather ironclad guarantees.\nmakes easy get started , providing low cost way \nsolving many simple problems.S4 formal rigorous rewrite S3, introduced \nProgramming Data.63 requires upfront\nwork S3, return provides guarantees greater\nencapsulation. S4 implemented base methods package, \nalways installed R.\n(might wonder S1 S2 exist. don’t: S3 S4 named\naccording versions S accompanied. first two\nversions S didn’t OOP framework.)S4 formal rigorous rewrite S3, introduced \nProgramming Data.63 requires upfront\nwork S3, return provides guarantees greater\nencapsulation. S4 implemented base methods package, \nalways installed R.(might wonder S1 S2 exist. don’t: S3 S4 named\naccording versions S accompanied. first two\nversions S didn’t OOP framework.)RC implements encapsulated OO. RC objects special type S4\nobjects also mutable, .e., instead using R’s usual\ncopy--modify semantics, can modified place. makes \nharder reason , allows solve problems difficult\nsolve functional OOP style S3 S4.RC implements encapsulated OO. RC objects special type S4\nobjects also mutable, .e., instead using R’s usual\ncopy--modify semantics, can modified place. makes \nharder reason , allows solve problems difficult\nsolve functional OOP style S3 S4.number OOP systems provided CRAN packages:R664 implements encapsulated OOP like RC, resolves \nimportant issues. book, ’ll learn R6 instead RC, \nreasons described Section 14.5.R664 implements encapsulated OOP like RC, resolves \nimportant issues. book, ’ll learn R6 instead RC, \nreasons described Section 14.5.R.oo65 provides formalism top S3, makes \npossible mutable S3 objects.R.oo65 provides formalism top S3, makes \npossible mutable S3 objects.proto66 implements another style OOP based idea \nprototypes, blur distinctions classes instances\nclasses (objects). briefly enamoured prototype based\nprogramming67 used ggplot2, now think ’s better \nstick standard forms.proto66 implements another style OOP based idea \nprototypes, blur distinctions classes instances\nclasses (objects). briefly enamoured prototype based\nprogramming67 used ggplot2, now think ’s better \nstick standard forms.Apart R6, widely used, systems primarily theoretical interest. strengths, R users know understand , hard others read contribute code.","code":""},{"path":"oo.html","id":"sloop","chapter":"Introduction","heading":"sloop","text":"go want introduce sloop package:sloop package (think “sail seas OOP”) provides number helpers fill missing pieces base R. first sloop::otype(). makes easy figure OOP system used wild-caught object:Use function figure chapter read understand work existing object.","code":"\nlibrary(sloop)\notype(1:10)\n#> [1] \"base\"\n\notype(mtcars)\n#> [1] \"S3\"\n\nmle_obj <- stats4::mle(function(x = 1) (x - 2) ^ 2)\notype(mle_obj)\n#> [1] \"S4\""},{"path":"base-types.html","id":"base-types","chapter":"12 Base types","heading":"12 Base types","text":"","code":""},{"path":"base-types.html","id":"introduction-11","chapter":"12 Base types","heading":"12.1 Introduction","text":"\ntalk objects OOP R first need clear fundamental confusion two uses word “object.” far book, ’ve used word general sense captured John Chambers’ pithy quote: “Everything exists R object.” However, everything object, everything object-oriented. confusion arises base objects come S, developed anyone thought S might need OOP system. tools nomenclature evolved organically many years without single guiding principle.time, distinction objects object-oriented objects important. need get nitty gritty details ’ll use terms base objects OO objects distinguish .","code":""},{"path":"base-types.html","id":"outline-10","chapter":"12 Base types","heading":"Outline","text":"Section 12.2 shows identify base OO objects.Section 12.2 shows identify base OO objects.Section 12.3 gives complete set base types used build objects.Section 12.3 gives complete set base types used build objects.","code":""},{"path":"base-types.html","id":"base-vs-oo","chapter":"12 Base types","heading":"12.2 Base versus OO objects","text":"\ntell difference base OO object, use .object() sloop::otype():Technically, difference base OO objects OO objects “class” attribute:may already familiar class() function. function safe apply S3 S4 objects, returns misleading results applied base objects. ’s safer use sloop::s3_class(), returns implicit class S3 S4 systems use pick methods. ’ll learn s3_class() Section 13.7.1.","code":"\n# A base object:\nis.object(1:10)\n#> [1] FALSE\nsloop::otype(1:10)\n#> [1] \"base\"\n\n# An OO object\nis.object(mtcars)\n#> [1] TRUE\nsloop::otype(mtcars)\n#> [1] \"S3\"\nattr(1:10, \"class\")\n#> NULL\n\nattr(mtcars, \"class\")\n#> [1] \"data.frame\"\nx <- matrix(1:4, nrow = 2)\nclass(x)\n#> [1] \"matrix\" \"array\"\nsloop::s3_class(x)\n#> [1] \"matrix\"  \"integer\" \"numeric\""},{"path":"base-types.html","id":"base-types-2","chapter":"12 Base types","heading":"12.3 Base types","text":"OO objects class attribute, every object base type:Base types form OOP system functions behave differently different base types primarily written C code uses switch statements. means R-core can create new types, creating new type lot work every switch statement needs modified handle new case. consequence, new base types rarely added. recent change, 2011, added two exotic types never see R , needed diagnosing memory problems. Prior , last type added special base type S4 objects added 2005.total, 25 different base types. listed , loosely grouped according ’re discussed book. types important C code, ’ll often see called C type names. ’ve included parentheses.Vectors, Chapter 3, include types NULL (NILSXP),\nlogical (LGLSXP), integer (INTSXP), double (REALSXP), complex\n(CPLXSXP), character (STRSXP), list (VECSXP), raw (RAWSXP).\n\ntypeof(NULL)\n#> [1] \"NULL\"\ntypeof(1L)\n#> [1] \"integer\"\ntypeof(1i)\n#> [1] \"complex\"Vectors, Chapter 3, include types NULL (NILSXP),\nlogical (LGLSXP), integer (INTSXP), double (REALSXP), complex\n(CPLXSXP), character (STRSXP), list (VECSXP), raw (RAWSXP).Functions, Chapter 6, include types closure (regular R\nfunctions, CLOSXP), special (internal functions, SPECIALSXP), \nbuiltin (primitive functions, BUILTINSXP).\n\ntypeof(mean)\n#> [1] \"closure\"\ntypeof(`[`)\n#> [1] \"special\"\ntypeof(sum)    \n#> [1] \"builtin\"\nInternal primitive functions described Section\n6.2.2.Functions, Chapter 6, include types closure (regular R\nfunctions, CLOSXP), special (internal functions, SPECIALSXP), \nbuiltin (primitive functions, BUILTINSXP).Internal primitive functions described Section\n6.2.2.Environments, Chapter 7, type environment\n(ENVSXP).\n\ntypeof(globalenv())\n#> [1] \"environment\"Environments, Chapter 7, type environment\n(ENVSXP).S4 type (S4SXP), Chapter 15, used S4 classes \ndon’t inherit existing base type.\n\nmle_obj <- stats4::mle(function(x = 1) (x - 2) ^ 2)\ntypeof(mle_obj)\n#> [1] \"S4\"S4 type (S4SXP), Chapter 15, used S4 classes \ndon’t inherit existing base type.Language components, Chapter 18, include symbol (aka\nname, SYMSXP), language (usually called calls, LANGSXP), \npairlist (used function arguments, LISTSXP) types.\n\ntypeof(quote())\n#> [1] \"symbol\"\ntypeof(quote(+ 1))\n#> [1] \"language\"\ntypeof(formals(mean))\n#> [1] \"pairlist\"\nexpression (EXPRSXP) special purpose type ’s returned \nparse() expression(). Expressions generally needed user\ncode.Language components, Chapter 18, include symbol (aka\nname, SYMSXP), language (usually called calls, LANGSXP), \npairlist (used function arguments, LISTSXP) types.expression (EXPRSXP) special purpose type ’s returned \nparse() expression(). Expressions generally needed user\ncode.remaining types esoteric rarely seen R. important\nprimarily C code: externalptr (EXTPTRSXP), weakref (WEAKREFSXP),\nbytecode (BCODESXP), promise (PROMSXP), ... (DOTSXP), \n(ANYSXP).remaining types esoteric rarely seen R. important\nprimarily C code: externalptr (EXTPTRSXP), weakref (WEAKREFSXP),\nbytecode (BCODESXP), promise (PROMSXP), ... (DOTSXP), \n(ANYSXP).may heard mode() storage.mode(). use functions: exist provide type names compatible S.","code":"\ntypeof(1:10)\n#> [1] \"integer\"\n\ntypeof(mtcars)\n#> [1] \"list\"\ntypeof(NULL)\n#> [1] \"NULL\"\ntypeof(1L)\n#> [1] \"integer\"\ntypeof(1i)\n#> [1] \"complex\"\ntypeof(mean)\n#> [1] \"closure\"\ntypeof(`[`)\n#> [1] \"special\"\ntypeof(sum)    \n#> [1] \"builtin\"\ntypeof(globalenv())\n#> [1] \"environment\"\nmle_obj <- stats4::mle(function(x = 1) (x - 2) ^ 2)\ntypeof(mle_obj)\n#> [1] \"S4\"\ntypeof(quote(a))\n#> [1] \"symbol\"\ntypeof(quote(a + 1))\n#> [1] \"language\"\ntypeof(formals(mean))\n#> [1] \"pairlist\""},{"path":"base-types.html","id":"numeric-type","chapter":"12 Base types","heading":"12.3.1 Numeric type","text":"\ncareful talking numeric type, R uses “numeric” mean three slightly different things:places numeric used alias double type. \nexample .numeric() identical .double(), numeric() \nidentical double().\n(R also occasionally uses real instead double; NA_real_ one\nplace ’re likely encounter practice.)places numeric used alias double type. \nexample .numeric() identical .double(), numeric() \nidentical double().(R also occasionally uses real instead double; NA_real_ one\nplace ’re likely encounter practice.)S3 S4 systems, numeric used shorthand either\ninteger double type, used picking methods:\n\nsloop::s3_class(1)\n#> [1] \"double\"  \"numeric\"\nsloop::s3_class(1L)\n#> [1] \"integer\" \"numeric\"S3 S4 systems, numeric used shorthand either\ninteger double type, used picking methods:.numeric() tests objects behave like numbers. example,\nfactors type “integer” don’t behave like numbers (.e. doesn’t\nmake sense take mean factor).\n\ntypeof(factor(\"x\"))\n#> [1] \"integer\"\n.numeric(factor(\"x\"))\n#> [1] FALSEis.numeric() tests objects behave like numbers. example,\nfactors type “integer” don’t behave like numbers (.e. doesn’t\nmake sense take mean factor).book, consistently use numeric mean object type integer double.","code":"\nsloop::s3_class(1)\n#> [1] \"double\"  \"numeric\"\nsloop::s3_class(1L)\n#> [1] \"integer\" \"numeric\"\ntypeof(factor(\"x\"))\n#> [1] \"integer\"\nis.numeric(factor(\"x\"))\n#> [1] FALSE"},{"path":"s3.html","id":"s3","chapter":"13 S3","heading":"13 S3","text":"","code":""},{"path":"s3.html","id":"introduction-12","chapter":"13 S3","heading":"13.1 Introduction","text":"S3 R’s first simplest OO system. S3 informal ad hoc, certain elegance minimalism: can’t take away part still useful OO system. reasons, use , unless compelling reason otherwise. S3 OO system used base stats packages, ’s commonly used system CRAN packages.S3 flexible, means allows things quite ill-advised. ’re coming strict environment like Java seem pretty frightening, gives R programmers tremendous amount freedom. may difficult prevent people something don’t want , users never held back something haven’t implemented yet. Since S3 built-constraints, key successful use applying constraints . chapter therefore teach conventions (almost) always follow.goal chapter show S3 system works, use effectively create new classes generics. ’d recommend coupling theoretical knowledge chapter practical knowledge encoded vctrs package.","code":""},{"path":"s3.html","id":"outline-11","chapter":"13 S3","heading":"Outline","text":"Section 13.2 gives rapid overview main components\nS3: classes, generics, methods. ’ll also learn \nsloop::s3_dispatch(), ’ll use throughout chapter explore\nS3 works.Section 13.2 gives rapid overview main components\nS3: classes, generics, methods. ’ll also learn \nsloop::s3_dispatch(), ’ll use throughout chapter explore\nS3 works.Section 13.3 goes details creating new S3 class,\nincluding three functions accompany classes:\nconstructor, helper, validator.Section 13.3 goes details creating new S3 class,\nincluding three functions accompany classes:\nconstructor, helper, validator.Section 13.4 describes S3 generics methods work,\nincluding basics method dispatch.Section 13.4 describes S3 generics methods work,\nincluding basics method dispatch.Section 13.5 discusses four main styles S3 objects:\nvector, record, data frame, scalar.Section 13.5 discusses four main styles S3 objects:\nvector, record, data frame, scalar.Section 13.6 demonstrates inheritance works S3,\nshows need make class “subclassable.”Section 13.6 demonstrates inheritance works S3,\nshows need make class “subclassable.”Section 13.7 concludes chapter discussion \nfiner details method dispatch including base types, internal generics,\ngroup generics, double dispatch.Section 13.7 concludes chapter discussion \nfiner details method dispatch including base types, internal generics,\ngroup generics, double dispatch.","code":""},{"path":"s3.html","id":"prerequisites-6","chapter":"13 S3","heading":"Prerequisites","text":"S3 classes implemented using attributes, make sure ’re familiar details described Section 3.3. ’ll use existing base S3 vectors examples exploration, make sure ’re familiar factor, Date, difftime, POSIXct, POSIXlt classes described Section 3.4.’ll use sloop package interactive helpers.","code":"\nlibrary(sloop)\n#> Warning: package 'sloop' was built under R version 4.1.2"},{"path":"s3.html","id":"s3-basics","chapter":"13 S3","heading":"13.2 Basics","text":"\n\nS3 object base type least class attribute (attributes may used store data). example, take factor. base type integer vector, class attribute “factor,” levels attribute stores possible levels:can get underlying base type unclass()ing , strips class attribute, causing lose special behaviour:\nS3 object behaves differently underlying base type whenever ’s passed generic (short generic function). easiest way tell function generic use sloop::ftype() look “generic” output:generic function defines interface, uses different implementation depending class argument (almost always first argument). Many base R functions generic, including important print():Beware str() generic, S3 classes use generic hide internal details. example, POSIXlt class used represent date-time data actually built top list, fact hidden str() method:generic middleman: job define interface (.e. arguments) find right implementation job. implementation specific class called method, generic finds method performing method dispatch.can use sloop::s3_dispatch() see process method dispatch:\n’ll come back details dispatch Section 13.4.1, now note S3 methods functions special naming scheme, generic.class(). example, factor method print() generic called print.factor(). never call method directly, instead rely generic find .Generally, can identify method presence . function name, number important functions base R written S3, hence use . join words. ’re unsure, check sloop::ftype():\nUnlike functions, can’t see source code S3 methods68 just typing names. ’s S3 methods usually exported: live inside package, available global environment. Instead, can use sloop::s3_get_method(), work regardless method lives:","code":"\nf <- factor(c(\"a\", \"b\", \"c\"))\n\ntypeof(f)\n#> [1] \"integer\"\nattributes(f)\n#> $levels\n#> [1] \"a\" \"b\" \"c\"\n#> \n#> $class\n#> [1] \"factor\"\nunclass(f)\n#> [1] 1 2 3\n#> attr(,\"levels\")\n#> [1] \"a\" \"b\" \"c\"\nftype(print)\n#> [1] \"S3\"      \"generic\"\nftype(str)\n#> [1] \"S3\"      \"generic\"\nftype(unclass)\n#> [1] \"primitive\"\nprint(f)\n#> [1] a b c\n#> Levels: a b c\n\n# stripping class reverts to integer behaviour\nprint(unclass(f))\n#> [1] 1 2 3\n#> attr(,\"levels\")\n#> [1] \"a\" \"b\" \"c\"\ntime <- strptime(c(\"2017-01-01\", \"2020-05-04 03:21\"), \"%Y-%m-%d\")\nstr(time)\n#>  POSIXlt[1:2], format: \"2017-01-01\" \"2020-05-04\"\n\nstr(unclass(time))\n#> List of 11\n#>  $ sec   : num [1:2] 0 0\n#>  $ min   : int [1:2] 0 0\n#>  $ hour  : int [1:2] 0 0\n#>  $ mday  : int [1:2] 1 4\n#>  $ mon   : int [1:2] 0 4\n#>  $ year  : int [1:2] 117 120\n#>  $ wday  : int [1:2] 0 1\n#>  $ yday  : int [1:2] 0 124\n#>  $ isdst : int [1:2] 0 1\n#>  $ zone  : chr [1:2] \"CST\" \"CDT\"\n#>  $ gmtoff: int [1:2] NA NA\ns3_dispatch(print(f))\n#> => print.factor\n#>  * print.default\nftype(t.test)\n#> [1] \"S3\"      \"generic\"\nftype(t.data.frame)\n#> [1] \"S3\"     \"method\"\nweighted.mean.Date\n#> Error in eval(expr, envir, enclos): objeto 'weighted.mean.Date' no encontrado\n\ns3_get_method(weighted.mean.Date)\n#> function (x, w, ...) \n#> .Date(weighted.mean(unclass(x), w, ...))\n#> <bytecode: 0x0000000026b26358>\n#> <environment: namespace:stats>"},{"path":"s3.html","id":"exercises-38","chapter":"13 S3","heading":"13.2.1 Exercises","text":"Describe difference t.test() t.data.frame().\nfunction called?Describe difference t.test() t.data.frame().\nfunction called?Make list commonly used base R functions contain . \nname S3 methods.Make list commonly used base R functions contain . \nname S3 methods..data.frame.data.frame() method ? \nconfusing? avoid confusion \ncode?.data.frame.data.frame() method ? \nconfusing? avoid confusion \ncode?Describe difference behaviour two calls.\n\nset.seed(1014)\nsome_days <- .Date(\"2017-01-31\") + sample(10, 5)\n\nmean(some_days)\n#> [1] \"2017-02-06\"\nmean(unclass(some_days))\n#> [1] 17203Describe difference behaviour two calls.class object following code return? base type \nbuilt ? attributes use?\n\nx <- ecdf(rpois(100, 10))\nx\n#> Empirical CDF \n#> Call: ecdf(rpois(100, 10))\n#>  x[1:18] =  2,  3,  4,  ..., 2e+01, 2e+01What class object following code return? base type \nbuilt ? attributes use?class object following code return? base type \nbuilt ? attributes use?\n\nx <- table(rpois(100, 5))\nx\n#> \n#>  1  2  3  4  5  6  7  8  9 10 \n#>  7  5 18 14 15 15 14  4  5  3What class object following code return? base type \nbuilt ? attributes use?","code":"\nset.seed(1014)\nsome_days <- as.Date(\"2017-01-31\") + sample(10, 5)\n\nmean(some_days)\n#> [1] \"2017-02-06\"\nmean(unclass(some_days))\n#> [1] 17203\nx <- ecdf(rpois(100, 10))\nx\n#> Empirical CDF \n#> Call: ecdf(rpois(100, 10))\n#>  x[1:18] =  2,  3,  4,  ..., 2e+01, 2e+01\nx <- table(rpois(100, 5))\nx\n#> \n#>  1  2  3  4  5  6  7  8  9 10 \n#>  7  5 18 14 15 15 14  4  5  3"},{"path":"s3.html","id":"s3-classes","chapter":"13 S3","heading":"13.3 Classes","text":"\n\ndone object-oriented programming languages, may surprised learn S3 formal definition class: make object instance class, simply set class attribute. can creation structure(), fact class<-():can determine class S3 object class(x), see object instance class using inherits(x, \"classname\").class name can string, recommend using letters _. Avoid . (mentioned earlier) can confused . separator generic name class name. using class package, recommend including package name class name. ensures won’t accidentally clash class defined another package.S3 checks correctness means can change class existing objects:’ve used OO languages, might make feel queasy, practice flexibility causes problems. R doesn’t stop shooting foot, long don’t aim gun toes pull trigger, won’t problem.avoid foot-bullet intersections creating class, recommend usually provide three functions:low-level constructor, new_myclass(), efficiently creates new\nobjects correct structure.low-level constructor, new_myclass(), efficiently creates new\nobjects correct structure.validator, validate_myclass(), performs computationally\nexpensive checks ensure object correct values.validator, validate_myclass(), performs computationally\nexpensive checks ensure object correct values.user-friendly helper, myclass(), provides convenient way \nothers create objects class.user-friendly helper, myclass(), provides convenient way \nothers create objects class.don’t need validator simple classes, can skip helper class internal use , always provide constructor.","code":"\n# Create and assign class in one step\nx <- structure(list(), class = \"my_class\")\n\n# Create, then set class\nx <- list()\nclass(x) <- \"my_class\"\nclass(x)\n#> [1] \"my_class\"\ninherits(x, \"my_class\")\n#> [1] TRUE\ninherits(x, \"your_class\")\n#> [1] FALSE\n# Create a linear model\nmod <- lm(log(mpg) ~ log(disp), data = mtcars)\nclass(mod)\n#> [1] \"lm\"\nprint(mod)\n#> \n#> Call:\n#> lm(formula = log(mpg) ~ log(disp), data = mtcars)\n#> \n#> Coefficients:\n#> (Intercept)    log(disp)  \n#>       5.381       -0.459\n\n# Turn it into a date (?!)\nclass(mod) <- \"Date\"\n\n# Unsurprisingly this doesn't work very well\nprint(mod)\n#> Error in as.POSIXlt.Date(x): 'list' object cannot be coerced to type 'double'"},{"path":"s3.html","id":"s3-constructor","chapter":"13 S3","heading":"13.3.1 Constructors","text":"\nS3 doesn’t provide formal definition class, built-way ensure objects given class structure (.e. base type attributes types). Instead, must enforce consistent structure using constructor.constructor follow three principles:called new_myclass().called new_myclass().one argument base object, one attribute.one argument base object, one attribute.Check type base object types attribute.Check type base object types attribute.’ll illustrate ideas creating constructors base classes69 ’re already familiar . start, lets make constructor simplest S3 class: Date. Date just double single attribute: class “Date.” makes simple constructor:purpose constructors help , developer. means can keep simple, don’t need optimise error messages public consumption. expect users also create objects, create friendly helper function, called class_name(), ’ll describe shortly.slightly complicated constructor difftime, used represent time differences. built double, units attribute must take one small set values:constructor developer function: called many places, experienced user. means ’s OK trade little safety return performance, avoid potentially time-consuming checks constructor.","code":"\nnew_Date <- function(x = double()) {\n  stopifnot(is.double(x))\n  structure(x, class = \"Date\")\n}\n\nnew_Date(c(-1, 0, 1))\n#> [1] \"1969-12-31\" \"1970-01-01\" \"1970-01-02\"\nnew_difftime <- function(x = double(), units = \"secs\") {\n  stopifnot(is.double(x))\n  units <- match.arg(units, c(\"secs\", \"mins\", \"hours\", \"days\", \"weeks\"))\n\n  structure(x,\n    class = \"difftime\",\n    units = units\n  )\n}\n\nnew_difftime(c(1, 10, 3600), \"secs\")\n#> Time differences in secs\n#> [1]    1   10 3600\nnew_difftime(52, \"weeks\")\n#> Time difference of 52 weeks"},{"path":"s3.html","id":"validators","chapter":"13 S3","heading":"13.3.2 Validators","text":"\ncomplicated classes require complicated checks validity. Take factors, example. constructor checks types correct, making possible create malformed factors:Rather encumbering constructor complicated checks, ’s better put separate function. allows cheaply create new objects know values correct, easily re-use checks places.validator function called primarily side-effects (throwing error object invalid) ’d expect invisibly return primary input (described Section 6.7.2). However, ’s useful validation methods return visibly, ’ll see next.","code":"\nnew_factor <- function(x = integer(), levels = character()) {\n  stopifnot(is.integer(x))\n  stopifnot(is.character(levels))\n\n  structure(\n    x,\n    levels = levels,\n    class = \"factor\"\n  )\n}\n\nnew_factor(1:5, \"a\")\n#> Error in as.character.factor(x): malformed factor\nnew_factor(0:1, \"a\")\n#> Error in as.character.factor(x): malformed factor\nvalidate_factor <- function(x) {\n  values <- unclass(x)\n  levels <- attr(x, \"levels\")\n\n  if (!all(!is.na(values) & values > 0)) {\n    stop(\n      \"All `x` values must be non-missing and greater than zero\",\n      call. = FALSE\n    )\n  }\n\n  if (length(levels) < max(values)) {\n    stop(\n      \"There must be at least as many `levels` as possible values in `x`\",\n      call. = FALSE\n    )\n  }\n\n  x\n}\n\nvalidate_factor(new_factor(1:5, \"a\"))\n#> Error: There must be at least as many `levels` as possible values in `x`\nvalidate_factor(new_factor(0:1, \"a\"))\n#> Error: All `x` values must be non-missing and greater than zero"},{"path":"s3.html","id":"helpers","chapter":"13 S3","heading":"13.3.3 Helpers","text":"\nwant users construct objects class, also provide helper method makes life easy possible. helper always:name class, e.g. myclass().name class, e.g. myclass().Finish calling constructor, validator, exists.Finish calling constructor, validator, exists.Create carefully crafted error messages tailored towards end-user.Create carefully crafted error messages tailored towards end-user.thoughtfully crafted user interface carefully chosen default\nvalues useful conversions.thoughtfully crafted user interface carefully chosen default\nvalues useful conversions.last bullet trickiest, ’s hard give general advice. However, three common patterns:Sometimes helper needs coerce inputs desired\ntype. example, new_difftime() strict, violates usual\nconvention can use integer vector wherever can use \ndouble vector:\n\nnew_difftime(1:10)\n#> Error new_difftime(1:10): .double(x) TRUE\n’s job constructor flexible, create\nhelper just coerces input double.\n\ndifftime <- function(x = double(), units = \"secs\") {\n  x <- .double(x)\n  new_difftime(x, units = units)\n}\n\ndifftime(1:10)\n#> Time differences secs\n#>  [1]  1  2  3  4  5  6  7  8  9 10Sometimes helper needs coerce inputs desired\ntype. example, new_difftime() strict, violates usual\nconvention can use integer vector wherever can use \ndouble vector:’s job constructor flexible, create\nhelper just coerces input double.Often, natural representation complex object string.\nexample, ’s convenient specify factors character\nvector. code shows simple version factor(): takes \ncharacter vector, guesses levels unique values.\nalways correct (since levels might seen \ndata), ’s useful default.\n\nfactor <- function(x = character(), levels = unique(x)) {\n  ind <- match(x, levels)\n  validate_factor(new_factor(ind, levels))\n}\n\nfactor(c(\"\", \"\", \"b\"))\n#> [1] b\n#> Levels: bOften, natural representation complex object string.\nexample, ’s convenient specify factors character\nvector. code shows simple version factor(): takes \ncharacter vector, guesses levels unique values.\nalways correct (since levels might seen \ndata), ’s useful default.complex objects naturally specified multiple simple\ncomponents. example, think ’s natural construct date-time\nsupplying individual components (year, month, day etc). leads\nPOSIXct() helper resembles existing ISODatetime()\nfunction70:\n\nPOSIXct <- function(year = integer(), \n                    month = integer(), \n                    day = integer(), \n                    hour = 0L, \n                    minute = 0L, \n                    sec = 0, \n                    tzone = \"\") {\n  ISOdatetime(year, month, day, hour, minute, sec, tz = tzone)\n}\n\nPOSIXct(2020, 1, 1, tzone = \"America/New_York\")\n#> [1] \"2020-01-01 EST\"complex objects naturally specified multiple simple\ncomponents. example, think ’s natural construct date-time\nsupplying individual components (year, month, day etc). leads\nPOSIXct() helper resembles existing ISODatetime()\nfunction70:complicated classes, feel free go beyond patterns make life easy possible users.","code":"\nnew_difftime(1:10)\n#> Error in new_difftime(1:10): is.double(x) is not TRUE\ndifftime <- function(x = double(), units = \"secs\") {\n  x <- as.double(x)\n  new_difftime(x, units = units)\n}\n\ndifftime(1:10)\n#> Time differences in secs\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nfactor <- function(x = character(), levels = unique(x)) {\n  ind <- match(x, levels)\n  validate_factor(new_factor(ind, levels))\n}\n\nfactor(c(\"a\", \"a\", \"b\"))\n#> [1] a a b\n#> Levels: a b\nPOSIXct <- function(year = integer(), \n                    month = integer(), \n                    day = integer(), \n                    hour = 0L, \n                    minute = 0L, \n                    sec = 0, \n                    tzone = \"\") {\n  ISOdatetime(year, month, day, hour, minute, sec, tz = tzone)\n}\n\nPOSIXct(2020, 1, 1, tzone = \"America/New_York\")\n#> [1] \"2020-01-01 EST\""},{"path":"s3.html","id":"exercises-39","chapter":"13 S3","heading":"13.3.4 Exercises","text":"Write constructor data.frame objects. base type data\nframe built ? attributes use? restrictions\nplaced individual elements? names?Write constructor data.frame objects. base type data\nframe built ? attributes use? restrictions\nplaced individual elements? names?Enhance factor() helper better behaviour one \nvalues found levels. base::factor() \nsituation?Enhance factor() helper better behaviour one \nvalues found levels. base::factor() \nsituation?Carefully read source code factor(). \nconstructor ?Carefully read source code factor(). \nconstructor ?Factors optional “contrasts” attribute. Read help C(),\nbriefly describe purpose attribute. type \n? Rewrite new_factor() constructor include attribute.Factors optional “contrasts” attribute. Read help C(),\nbriefly describe purpose attribute. type \n? Rewrite new_factor() constructor include attribute.Read documentation utils::.roman(). write \nconstructor class? need validator? might helper\n?Read documentation utils::.roman(). write \nconstructor class? need validator? might helper\n?","code":""},{"path":"s3.html","id":"s3-methods","chapter":"13 S3","heading":"13.4 Generics and methods","text":"\njob S3 generic perform method dispatch, .e. find specific implementation class. Method dispatch performed UseMethod(), every generic calls71. UseMethod() takes two arguments: name generic function (required), argument use method dispatch (optional). omit second argument, dispatch based first argument, almost always desired.generics simple, consist call UseMethod(). Take mean() example:Creating generic similarly simple:(wonder repeat my_new_generic twice, think back Section 6.2.3.)don’t pass arguments generic UseMethod(); uses deep magic pass method automatically. precise process complicated frequently surprising, avoid computation generic. learn full details, carefully read Technical Details section ?UseMethod.","code":"\nmean\n#> function (x, ...) \n#> UseMethod(\"mean\")\n#> <bytecode: 0x0000000015dbbf60>\n#> <environment: namespace:base>\nmy_new_generic <- function(x) {\n  UseMethod(\"my_new_generic\")\n}"},{"path":"s3.html","id":"method-dispatch","chapter":"13 S3","heading":"13.4.1 Method dispatch","text":"\nUseMethod() work? basically creates vector method names, paste0(\"generic\", \".\", c(class(x), \"default\")), looks potential method turn. can see action sloop::s3_dispatch(). give call S3 generic, lists possible methods. example, method called print Date object?output simple:=> indicates method called, print.Date()* indicates method defined, called, print.default().“default” class special pseudo-class. real class, included make possible define standard fallback found whenever class-specific method available.essence method dispatch quite simple, chapter proceeds ’ll see get progressively complicated encompass inheritance, base types, internal generics, group generics. code shows couple complicated cases ’ll come back Sections 14.2.4 13.7.","code":"\nx <- Sys.Date()\ns3_dispatch(print(x))\n#> => print.Date\n#>  * print.default\nx <- matrix(1:10, nrow = 2)\ns3_dispatch(mean(x))\n#>    mean.matrix\n#>    mean.integer\n#>    mean.numeric\n#> => mean.default\n\ns3_dispatch(sum(Sys.time()))\n#>    sum.POSIXct\n#>    sum.POSIXt\n#>    sum.default\n#> => Summary.POSIXct\n#>    Summary.POSIXt\n#>    Summary.default\n#> -> sum (internal)"},{"path":"s3.html","id":"finding-methods","chapter":"13 S3","heading":"13.4.2 Finding methods","text":"sloop::s3_dispatch() lets find specific method used single call. want find methods defined generic associated class? ’s job sloop::s3_methods_generic() sloop::s3_methods_class():","code":"\ns3_methods_generic(\"mean\")\n#> # A tibble: 7 x 4\n#>   generic class      visible source             \n#>   <chr>   <chr>      <lgl>   <chr>              \n#> 1 mean    Date       TRUE    base               \n#> 2 mean    default    TRUE    base               \n#> 3 mean    difftime   TRUE    base               \n#> 4 mean    POSIXct    TRUE    base               \n#> 5 mean    POSIXlt    TRUE    base               \n#> 6 mean    quosure    FALSE   registered S3method\n#> 7 mean    vctrs_vctr FALSE   registered S3method\n\ns3_methods_class(\"ordered\")\n#> # A tibble: 4 x 4\n#>   generic       class   visible source             \n#>   <chr>         <chr>   <lgl>   <chr>              \n#> 1 as.data.frame ordered TRUE    base               \n#> 2 Ops           ordered TRUE    base               \n#> 3 relevel       ordered FALSE   registered S3method\n#> 4 Summary       ordered TRUE    base"},{"path":"s3.html","id":"s3-arguments","chapter":"13 S3","heading":"13.4.3 Creating methods","text":"\ntwo wrinkles aware create new method:First, ever write method generic \nclass. R allow define method even don’t, \nexceedingly bad manners. Instead, work author either \ngeneric class add method code.First, ever write method generic \nclass. R allow define method even don’t, \nexceedingly bad manners. Instead, work author either \ngeneric class add method code.method must arguments generic. enforced \npackages R CMD check, ’s good practice even ’re \ncreating package.\none exception rule: generic ..., method\ncan contain superset arguments. allows methods take\narbitrary additional arguments. downside using ..., however, \nmisspelled arguments silently swallowed72,\nmentioned Section 6.6.method must arguments generic. enforced \npackages R CMD check, ’s good practice even ’re \ncreating package.one exception rule: generic ..., method\ncan contain superset arguments. allows methods take\narbitrary additional arguments. downside using ..., however, \nmisspelled arguments silently swallowed72,\nmentioned Section 6.6.","code":""},{"path":"s3.html","id":"exercises-40","chapter":"13 S3","heading":"13.4.4 Exercises","text":"Read source code t() t.test() confirm \nt.test() S3 generic S3 method. happens \ncreate object class test call t() ? ?\n\nx <- structure(1:10, class = \"test\")\nt(x)Read source code t() t.test() confirm \nt.test() S3 generic S3 method. happens \ncreate object class test call t() ? ?generics table class methods ?generics table class methods ?generics ecdf class methods ?generics ecdf class methods ?base generic greatest number defined methods?base generic greatest number defined methods?Carefully read documentation UseMethod() explain \nfollowing code returns results . two usual rules\nfunction evaluation UseMethod() violate?\n\ng <- function(x) {\n  x <- 10\n  y <- 10\n  UseMethod(\"g\")\n}\ng.default <- function(x) c(x = x, y = y)\n\nx <- 1\ny <- 1\ng(x)\n#>  x  y \n#>  1 10Carefully read documentation UseMethod() explain \nfollowing code returns results . two usual rules\nfunction evaluation UseMethod() violate?arguments [? hard question answer?arguments [? hard question answer?","code":"\nx <- structure(1:10, class = \"test\")\nt(x)\ng <- function(x) {\n  x <- 10\n  y <- 10\n  UseMethod(\"g\")\n}\ng.default <- function(x) c(x = x, y = y)\n\nx <- 1\ny <- 1\ng(x)\n#>  x  y \n#>  1 10"},{"path":"s3.html","id":"object-styles","chapter":"13 S3","heading":"13.5 Object styles","text":"far ’ve focussed vector style classes like Date factor. key property length(x) represents number observations vector. three variants property:Record style objects use list equal-length vectors represent\nindividual components object. best example POSIXlt,\nunderneath hood list 11 date-time components like year,\nmonth, day. Record style classes override length() subsetting\nmethods conceal implementation detail.\n\nx <- .POSIXlt(ISOdatetime(2020, 1, 1, 0, 0, 1:3))\nx\n#> [1] \"2020-01-01 00:00:01 CST\" \"2020-01-01 00:00:02 CST\"\n#> [3] \"2020-01-01 00:00:03 CST\"\n\nlength(x)\n#> [1] 3\nlength(unclass(x))\n#> [1] 11\n\nx[[1]] # first date time\n#> [1] \"2020-01-01 00:00:01 CST\"\nunclass(x)[[1]] # first component, number seconds\n#> [1] 1 2 3Record style objects use list equal-length vectors represent\nindividual components object. best example POSIXlt,\nunderneath hood list 11 date-time components like year,\nmonth, day. Record style classes override length() subsetting\nmethods conceal implementation detail.Data frames similar record style objects use lists \nequal length vectors. However, data frames conceptually two dimensional,\nindividual components readily exposed user. number \nobservations number rows, length:\n\nx <- data.frame(x = 1:100, y = 1:100)\nlength(x)\n#> [1] 2\nnrow(x)\n#> [1] 100Data frames similar record style objects use lists \nequal length vectors. However, data frames conceptually two dimensional,\nindividual components readily exposed user. number \nobservations number rows, length:Scalar objects typically use list represent single thing.\nexample, lm object list length 12 represents one\nmodel.\n\nmod <- lm(mpg ~ wt, data = mtcars)\nlength(mod)\n#> [1] 12\nScalar objects can also built top functions, calls, \nenvironments73. less generally useful, can see\napplications stats::ecdf(), R6 (Chapter 14), \nrlang::quo() (Chapter 19).\nScalar objects typically use list represent single thing.\nexample, lm object list length 12 represents one\nmodel.Scalar objects can also built top functions, calls, \nenvironments73. less generally useful, can see\napplications stats::ecdf(), R6 (Chapter 14), \nrlang::quo() (Chapter 19).\nUnfortunately, describing appropriate use object styles beyond scope book. However, can learn documentation vctrs package (https://vctrs.r-lib.org); package also provides constructors helpers make implementation different styles easier.","code":"\nx <- as.POSIXlt(ISOdatetime(2020, 1, 1, 0, 0, 1:3))\nx\n#> [1] \"2020-01-01 00:00:01 CST\" \"2020-01-01 00:00:02 CST\"\n#> [3] \"2020-01-01 00:00:03 CST\"\n\nlength(x)\n#> [1] 3\nlength(unclass(x))\n#> [1] 11\n\nx[[1]] # the first date time\n#> [1] \"2020-01-01 00:00:01 CST\"\nunclass(x)[[1]] # the first component, the number of seconds\n#> [1] 1 2 3\nx <- data.frame(x = 1:100, y = 1:100)\nlength(x)\n#> [1] 2\nnrow(x)\n#> [1] 100\nmod <- lm(mpg ~ wt, data = mtcars)\nlength(mod)\n#> [1] 12"},{"path":"s3.html","id":"exercises-41","chapter":"13 S3","heading":"13.5.1 Exercises","text":"Categorise objects returned lm(), factor(), table(),\n.Date(), .POSIXct() ecdf(), ordered(), () \nstyles described .Categorise objects returned lm(), factor(), table(),\n.Date(), .POSIXct() ecdf(), ordered(), () \nstyles described .constructor function lm objects, new_lm(), look like?\nUse ?lm experimentation figure required fields \ntypes.constructor function lm objects, new_lm(), look like?\nUse ?lm experimentation figure required fields \ntypes.","code":""},{"path":"s3.html","id":"s3-inheritance","chapter":"13 S3","heading":"13.6 Inheritance","text":"\n\nS3 classes can share behaviour mechanism called inheritance. Inheritance powered three ideas:class can character vector. example, ordered \nPOSIXct classes two components class:\n\nclass(ordered(\"x\"))\n#> [1] \"ordered\" \"factor\"\nclass(Sys.time())\n#> [1] \"POSIXct\" \"POSIXt\"class can character vector. example, ordered \nPOSIXct classes two components class:method found class first element \nvector, R looks method second class ():\n\ns3_dispatch(print(ordered(\"x\")))\n#>    print.ordered\n#> => print.factor\n#>  * print.default\ns3_dispatch(print(Sys.time()))\n#> => print.POSIXct\n#>    print.POSIXt\n#>  * print.defaultIf method found class first element \nvector, R looks method second class ():method can delegate work calling NextMethod(). ’ll come back \nshortly; now, note s3_dispatch() reports delegation\n->.\n\ns3_dispatch(ordered(\"x\")[1])\n#>    [.ordered\n#> => [.factor\n#>    [.default\n#> -> [ (internal)\ns3_dispatch(Sys.time()[1])\n#> => [.POSIXct\n#>    [.POSIXt\n#>    [.default\n#> -> [ (internal)method can delegate work calling NextMethod(). ’ll come back \nshortly; now, note s3_dispatch() reports delegation\n->.continue need bit vocabulary describe relationship classes appear together class vector. ’ll say ordered subclass factor always appears class vector, , conversely, ’ll say factor superclass ordered.S3 imposes restrictions relationship sub- superclasses life easier impose . recommend adhere two simple principles creating subclass:base type subclass superclass.base type subclass superclass.attributes subclass superset attributes\nsuperclass.attributes subclass superset attributes\nsuperclass.POSIXt adhere principles POSIXct type double, POSIXlt type list. means POSIXt superclass, illustrates ’s quite possible use S3 inheritance system implement styles code sharing (POSIXt plays role like interface), ’ll need figure safe conventions .\n","code":"\nclass(ordered(\"x\"))\n#> [1] \"ordered\" \"factor\"\nclass(Sys.time())\n#> [1] \"POSIXct\" \"POSIXt\"\ns3_dispatch(print(ordered(\"x\")))\n#>    print.ordered\n#> => print.factor\n#>  * print.default\ns3_dispatch(print(Sys.time()))\n#> => print.POSIXct\n#>    print.POSIXt\n#>  * print.default\ns3_dispatch(ordered(\"x\")[1])\n#>    [.ordered\n#> => [.factor\n#>    [.default\n#> -> [ (internal)\ns3_dispatch(Sys.time()[1])\n#> => [.POSIXct\n#>    [.POSIXt\n#>    [.default\n#> -> [ (internal)"},{"path":"s3.html","id":"nextmethod","chapter":"13 S3","heading":"13.6.1 NextMethod()","text":"NextMethod() hardest part inheritance understand, ’ll start concrete example common use case: [. ’ll start creating simple toy class: secret class hides output printed:works, default [ method doesn’t preserve class:fix , need provide [.secret method. implement method? naive approach won’t work ’ll get stuck infinite loop:Instead, need way call underlying [ code, .e. implementation get called didn’t [.secret method. One approach unclass() object:works, inefficient creates copy x. better approach use NextMethod(), concisely solves problem delegating method called [.secret didn’t exist:can see ’s going sloop::s3_dispatch():=> indicates [.secret called, NextMethod() delegates work underlying internal [ method, shown ->.UseMethod(), precise semantics NextMethod() complex. particular, tracks list potential next methods special variable, means modifying object ’s dispatched upon impact method gets called next.","code":"\nnew_secret <- function(x = double()) {\n  stopifnot(is.double(x))\n  structure(x, class = \"secret\")\n}\n\nprint.secret <- function(x, ...) {\n  print(strrep(\"x\", nchar(x)))\n  invisible(x)\n}\n\nx <- new_secret(c(15, 1, 456))\nx\n#> [1] \"xx\"  \"x\"   \"xxx\"\ns3_dispatch(x[1])\n#>    [.secret\n#>    [.default\n#> => [ (internal)\nx[1]\n#> [1] 15\n`[.secret` <- function(x, i) {\n  new_secret(x[i])\n}\n`[.secret` <- function(x, i) {\n  x <- unclass(x)\n  new_secret(x[i])\n}\nx[1]\n#> [1] \"xx\"\n`[.secret` <- function(x, i) {\n  new_secret(NextMethod())\n}\nx[1]\n#> [1] \"xx\"\ns3_dispatch(x[1])\n#> => [.secret\n#>    [.default\n#> -> [ (internal)"},{"path":"s3.html","id":"s3-subclassing","chapter":"13 S3","heading":"13.6.2 Allowing subclassing","text":"create class, need decide want allow subclasses, requires changes constructor careful thought methods.allow subclasses, parent constructor needs ... class arguments:subclass constructor can just call parent class constructor additional arguments needed. example, imagine want create supersecret class also hides number characters:allow inheritance, also need think carefully methods, can longer use constructor. , method always return class, regardless input. forces whoever makes subclass lot extra work.Concretely, means need revise [.secret method. Currently always returns secret(), even given supersecret:want make sure [.secret returns class x even ’s subclass. far can tell, way solve problem using base R alone. Instead, ’ll need use vctrs package, provides solution form vctrs::vec_restore() generic. generic takes two inputs: object lost subclass information, template object use restoration.Typically vec_restore() methods quite simple: just call constructor appropriate arguments:(class attributes, ’ll need pass constructor.)Now can use vec_restore() [.secret method:(fully understood issue quite recently, time writing used tidyverse. Hopefully time ’re reading , rolled , making much easier (e.g.) subclass tibbles.)build class using tools provided vctrs package, [ gain behaviour automatically. need provide [ method use attributes depend data want non-standard subsetting behaviour. See ?vctrs::new_vctr details.","code":"\nnew_secret <- function(x, ..., class = character()) {\n  stopifnot(is.double(x))\n\n  structure(\n    x,\n    ...,\n    class = c(class, \"secret\")\n  )\n}\nnew_supersecret <- function(x) {\n  new_secret(x, class = \"supersecret\")\n}\n\nprint.supersecret <- function(x, ...) {\n  print(rep(\"xxxxx\", length(x)))\n  invisible(x)\n}\n\nx2 <- new_supersecret(c(15, 1, 456))\nx2\n#> [1] \"xxxxx\" \"xxxxx\" \"xxxxx\"\n`[.secret` <- function(x, ...) {\n  new_secret(NextMethod())\n}\n\nx2[1:3]\n#> [1] \"xx\"  \"x\"   \"xxx\"\nvec_restore.secret <- function(x, to, ...) new_secret(x)\nvec_restore.supersecret <- function(x, to, ...) new_supersecret(x)\n`[.secret` <- function(x, ...) {\n  vctrs::vec_restore(NextMethod(), x)\n}\nx2[1:3]\n#> [1] \"xxxxx\" \"xxxxx\" \"xxxxx\""},{"path":"s3.html","id":"exercises-42","chapter":"13 S3","heading":"13.6.3 Exercises","text":"[.Date support subclasses? fail support\nsubclasses?[.Date support subclasses? fail support\nsubclasses?R two classes representing date time data, POSIXct \nPOSIXlt, inherit POSIXt. generics \ndifferent behaviours two classes? generics share \nbehaviour?R two classes representing date time data, POSIXct \nPOSIXlt, inherit POSIXt. generics \ndifferent behaviours two classes? generics share \nbehaviour?expect code return? actually return?\n?\n\ngeneric2 <- function(x) UseMethod(\"generic2\")\ngeneric2.a1 <- function(x) \"a1\"\ngeneric2.a2 <- function(x) \"a2\"\ngeneric2.b <- function(x) {\n  class(x) <- \"a1\"\n  NextMethod()\n}\n\ngeneric2(structure(list(), class = c(\"b\", \"a2\")))expect code return? actually return?\n?","code":"\ngeneric2 <- function(x) UseMethod(\"generic2\")\ngeneric2.a1 <- function(x) \"a1\"\ngeneric2.a2 <- function(x) \"a2\"\ngeneric2.b <- function(x) {\n  class(x) <- \"a1\"\n  NextMethod()\n}\n\ngeneric2(structure(list(), class = c(\"b\", \"a2\")))"},{"path":"s3.html","id":"s3-dispatch","chapter":"13 S3","heading":"13.7 Dispatch details","text":"chapter concludes additional details method dispatch. safe skip details ’re new S3.","code":""},{"path":"s3.html","id":"implicit-class","chapter":"13 S3","heading":"13.7.1 S3 and base types","text":"\nhappens call S3 generic base object, .e. object class? might think dispatch class() returns:unfortunately dispatch actually occurs implicit class, three components:string “array” “matrix” object dimensionsThe result typeof() minor tweaksThe string “numeric” object “integer” “double”base function compute implicit class, can use sloop::s3_class()used s3_dispatch():means class() object uniquely determine dispatch:","code":"\nclass(matrix(1:5))\n#> [1] \"matrix\" \"array\"\ns3_class(matrix(1:5))\n#> [1] \"matrix\"  \"integer\" \"numeric\"\ns3_dispatch(print(matrix(1:5)))\n#>    print.matrix\n#>    print.integer\n#>    print.numeric\n#> => print.default\nx1 <- 1:5\nclass(x1)\n#> [1] \"integer\"\ns3_dispatch(mean(x1))\n#>    mean.integer\n#>    mean.numeric\n#> => mean.default\n\nx2 <- structure(x1, class = \"integer\")\nclass(x2)\n#> [1] \"integer\"\ns3_dispatch(mean(x2))\n#>    mean.integer\n#> => mean.default"},{"path":"s3.html","id":"internal-generics","chapter":"13 S3","heading":"13.7.2 Internal generics","text":"base functions, like [, sum(), cbind(), called internal generics don’t call UseMethod() instead call C functions DispatchGroup() DispatchOrEval(). s3_dispatch() shows internal generics including name generic followed (internal):performance reasons, internal generics dispatch methods unless class attribute set, means internal generics use implicit class. , ’re ever confused method dispatch, can rely s3_dispatch().","code":"\ns3_dispatch(Sys.time()[1])\n#> => [.POSIXct\n#>    [.POSIXt\n#>    [.default\n#> -> [ (internal)"},{"path":"s3.html","id":"group-generics","chapter":"13 S3","heading":"13.7.3 Group generics","text":"\nGroup generics complicated part S3 method dispatch involve NextMethod() internal generics. Like internal generics, exist base R, define group generic.four group generics:Math: abs(), sign(), sqrt(), floor(), cos(), sin(), log(),\n(see ?Math complete list).Math: abs(), sign(), sqrt(), floor(), cos(), sin(), log(),\n(see ?Math complete list).Ops: +, -, *, /, ^, %%, %/%, &, |, !, ==, !=, <,\n<=, >=, >.Ops: +, -, *, /, ^, %%, %/%, &, |, !, ==, !=, <,\n<=, >=, >.Summary: (), (), sum(), prod(), min(), max(), \nrange().Summary: (), (), sum(), prod(), min(), max(), \nrange().Complex: Arg(), Conj(), Im(), Mod(), Re().Complex: Arg(), Conj(), Im(), Mod(), Re().Defining single group generic class overrides default behaviour members group. Methods group generics looked methods specific generic exist:group generics involve call NextMethod(). example, take difftime() objects. look method dispatch abs(), ’ll see ’s Math group generic defined.Math.difftime basically looks like :dispatches next method, internal default, perform actual computation, restore class attributes. (better support subclasses difftime need call vec_restore(), described Section 13.6.2.)Inside group generic function special variable .Generic provides actual generic function called. can useful producing error messages, can sometimes useful need manually re-call generic different arguments.","code":"\ns3_dispatch(sum(Sys.time()))\n#>    sum.POSIXct\n#>    sum.POSIXt\n#>    sum.default\n#> => Summary.POSIXct\n#>    Summary.POSIXt\n#>    Summary.default\n#> -> sum (internal)\ny <- as.difftime(10, units = \"mins\")\ns3_dispatch(abs(y))\n#>    abs.difftime\n#>    abs.default\n#> => Math.difftime\n#>    Math.default\n#> -> abs (internal)\nMath.difftime <- function(x, ...) {\n  new_difftime(NextMethod(), units = attr(x, \"units\"))\n}"},{"path":"s3.html","id":"double-dispatch","chapter":"13 S3","heading":"13.7.4 Double dispatch","text":"\nGenerics Ops group, includes two-argument arithmetic Boolean operators like - &, implement special type method dispatch. dispatch type arguments, called double dispatch. necessary preserve commutative property many operators, .e. + b equal b + . Take following simple example:+ dispatched first argument, return different values two cases. overcome problem, generics Ops group use slightly different strategy usual. Rather single method dispatch, two, one input. three possible outcomes lookup:methods , doesn’t matter method used.methods , doesn’t matter method used.methods different, R falls back internal method \nwarning.methods different, R falls back internal method \nwarning.One method internal, case R calls method.One method internal, case R calls method.approach error prone want implement robust double dispatch algebraic operators, recommend using vctrs package. See ?vctrs::vec_arith details.","code":"\ndate <- as.Date(\"2017-01-01\")\ninteger <- 1L\n\ndate + integer\n#> [1] \"2017-01-02\"\ninteger + date\n#> [1] \"2017-01-02\""},{"path":"s3.html","id":"exercises-43","chapter":"13 S3","heading":"13.7.5 Exercises","text":"Explain differences dispatch :\n\nlength.integer <- function(x) 10\n\nx1 <- 1:5\nclass(x1)\n#> [1] \"integer\"\ns3_dispatch(length(x1))\n#>  * length.integer\n#>    length.numeric\n#>    length.default\n#> => length (internal)\n\nx2 <- structure(x1, class = \"integer\")\nclass(x2)\n#> [1] \"integer\"\ns3_dispatch(length(x2))\n#> => length.integer\n#>    length.default\n#>  * length (internal)Explain differences dispatch :classes method Math group generic base R? Read\nsource code. methods work?classes method Math group generic base R? Read\nsource code. methods work?Math.difftime() complicated described. ?Math.difftime() complicated described. ?","code":"\nlength.integer <- function(x) 10\n\nx1 <- 1:5\nclass(x1)\n#> [1] \"integer\"\ns3_dispatch(length(x1))\n#>  * length.integer\n#>    length.numeric\n#>    length.default\n#> => length (internal)\n\nx2 <- structure(x1, class = \"integer\")\nclass(x2)\n#> [1] \"integer\"\ns3_dispatch(length(x2))\n#> => length.integer\n#>    length.default\n#>  * length (internal)"},{"path":"r6.html","id":"r6","chapter":"14 R6","heading":"14 R6","text":"","code":""},{"path":"r6.html","id":"introduction-13","chapter":"14 R6","heading":"14.1 Introduction","text":"chapter describes R6 OOP system. R6 two special properties:uses encapsulated OOP paradigm, means methods belong \nobjects, generics, call like object$method().uses encapsulated OOP paradigm, means methods belong \nobjects, generics, call like object$method().R6 objects mutable, means modified place, \nhence reference semantics.R6 objects mutable, means modified place, \nhence reference semantics.’ve learned OOP another programming language, ’s likely R6 feel natural, ’ll inclined prefer S3. Resist temptation follow path least resistance: cases R6 lead non-idiomatic R code. ’ll come back theme Section 16.3.R6 similar base OOP system called reference classes, RC short. describe teach R6 RC Section 14.5.","code":""},{"path":"r6.html","id":"outline-12","chapter":"14 R6","heading":"Outline","text":"Section 14.2 introduces R6::R6Class(), one function \nneed know create R6 classes. ’ll learn constructor\nmethod, $new(), allows create R6 objects, well \nimportant methods like $initialize() $print().Section 14.2 introduces R6::R6Class(), one function \nneed know create R6 classes. ’ll learn constructor\nmethod, $new(), allows create R6 objects, well \nimportant methods like $initialize() $print().Section 14.3 discusses access mechanisms R6: private \nactive fields. Together, allow hide data user, \nexpose private data reading writing.Section 14.3 discusses access mechanisms R6: private \nactive fields. Together, allow hide data user, \nexpose private data reading writing.Section 14.4 explores consequences R6’s reference\nsemantics. ’ll learn use finalizers automatically\nclean operations performed initializer, common gotcha\nuse R6 object field another R6 object.Section 14.4 explores consequences R6’s reference\nsemantics. ’ll learn use finalizers automatically\nclean operations performed initializer, common gotcha\nuse R6 object field another R6 object.Section 14.5 describes cover R6, rather base RC\nsystem.Section 14.5 describes cover R6, rather base RC\nsystem.","code":""},{"path":"r6.html","id":"prerequisites-7","chapter":"14 R6","heading":"Prerequisites","text":"R6 built base R, ’ll need install load R6 package use :R6 objects reference semantics means modified -place, copied--modify. ’re familiar terms, brush vocab reading Section 2.5.","code":"\n# install.packages(\"R6\")\nlibrary(R6)\n#> Warning: package 'R6' was built under R version 4.1.2"},{"path":"r6.html","id":"r6-classes","chapter":"14 R6","heading":"14.2 Classes and methods","text":"\n\n\nR6 needs single function call create class methods: R6::R6Class(). function package ’ll ever use!74The following example shows two important arguments R6Class():first argument classname. ’s strictly needed, \nimproves error messages makes possible use R6 objects S3\ngenerics. convention, R6 classes UpperCamelCase names.first argument classname. ’s strictly needed, \nimproves error messages makes possible use R6 objects S3\ngenerics. convention, R6 classes UpperCamelCase names.second argument, public, supplies list methods (functions) \nfields (anything else) make public interface object.\nconvention, methods fields use snake_case. Methods can access\nmethods fields current object via self$.75\nsecond argument, public, supplies list methods (functions) \nfields (anything else) make public interface object.\nconvention, methods fields use snake_case. Methods can access\nmethods fields current object via self$.75\nalways assign result R6Class() variable name class, R6Class() returns R6 object defines class:\nconstruct new object class calling new() method. R6, methods belong objects, use $ access new():can call methods access fields $:class, fields methods public, means can get set value field. Later, ’ll see use private fields methods prevent casual access internals class.make clear ’re talking fields methods opposed variables functions, ’ll prefix names $. example, Accumulate class field $sum method $add().","code":"\nAccumulator <- R6Class(\"Accumulator\", list(\n  sum = 0,\n  add = function(x = 1) {\n    self$sum <- self$sum + x \n    invisible(self)\n  })\n)\nAccumulator\n#> <Accumulator> object generator\n#>   Public:\n#>     sum: 0\n#>     add: function (x = 1) \n#>     clone: function (deep = FALSE) \n#>   Parent env: <environment: R_GlobalEnv>\n#>   Locked objects: TRUE\n#>   Locked class: FALSE\n#>   Portable: TRUE\nx <- Accumulator$new() \nx$add(4) \nx$sum\n#> [1] 4"},{"path":"r6.html","id":"method-chaining","chapter":"14 R6","heading":"14.2.1 Method chaining","text":"$add() called primarily side-effect updating $sum.Side-effect R6 methods always return self invisibly. returns “current” object makes possible chain together multiple method calls:, readability, might put one method call line:technique called method chaining commonly used languages like Python JavaScript. Method chaining deeply related pipe, ’ll discuss pros cons approach Section 16.3.3.","code":"\nAccumulator <- R6Class(\"Accumulator\", list(\n  sum = 0,\n  add = function(x = 1) {\n    self$sum <- self$sum + x \n    invisible(self)\n  })\n)\nx$add(10)$add(10)$sum\n#> [1] 24\nx$\n  add(10)$\n  add(10)$\n  sum\n#> [1] 44"},{"path":"r6.html","id":"r6-important-methods","chapter":"14 R6","heading":"14.2.2 Important methods","text":"\ntwo important methods defined classes: $initialize() $print(). ’re required, providing make class easier use.$initialize() overrides default behaviour $new(). example, following code defines Person class fields $name $age. ensure $name always single string, $age always single number, placed checks $initialize().expensive validation requirements, implement separate $validate() call needed.Defining $print() allows override default printing behaviour. R6 method called side effects, $print() return invisible(self).code illustrates important aspect R6. methods bound individual objects, previously created hadley object get new method:perspective R6, relationship hadley hadley2; just coincidentally share class name. doesn’t cause problems using already developed R6 objects can make interactive experimentation confusing. ’re changing code can’t figure results method calls aren’t different, make sure ’ve re-constructed R6 objects new class.","code":"\nPerson <- R6Class(\"Person\", list(\n  name = NULL,\n  age = NA,\n  initialize = function(name, age = NA) {\n    stopifnot(is.character(name), length(name) == 1)\n    stopifnot(is.numeric(age), length(age) == 1)\n    \n    self$name <- name\n    self$age <- age\n  }\n))\n\nhadley <- Person$new(\"Hadley\", age = \"thirty-eight\")\n#> Error in initialize(...): is.numeric(age) is not TRUE\n\nhadley <- Person$new(\"Hadley\", age = 38)\nPerson <- R6Class(\"Person\", list(\n  name = NULL,\n  age = NA,\n  initialize = function(name, age = NA) {\n    self$name <- name\n    self$age <- age\n  },\n  print = function(...) {\n    cat(\"Person: \\n\")\n    cat(\"  Name: \", self$name, \"\\n\", sep = \"\")\n    cat(\"  Age:  \", self$age, \"\\n\", sep = \"\")\n    invisible(self)\n  }\n))\n\nhadley2 <- Person$new(\"Hadley\")\nhadley2\n#> Person: \n#>   Name: Hadley\n#>   Age:  NA\nhadley\n#> <Person>\n#>   Public:\n#>     age: 38\n#>     clone: function (deep = FALSE) \n#>     initialize: function (name, age = NA) \n#>     name: Hadley\n\nhadley$print\n#> NULL"},{"path":"r6.html","id":"adding-methods-after-creation","chapter":"14 R6","heading":"14.2.3 Adding methods after creation","text":"Instead continuously creating new classes, ’s also possible modify fields methods existing class. useful exploring interactively, class many functions ’d like break pieces. Add new elements existing class $set(), supplying visibility (Section 14.3), name, component., new methods fields available new objects; retrospectively added existing objects.","code":"\nAccumulator <- R6Class(\"Accumulator\")\nAccumulator$set(\"public\", \"sum\", 0)\nAccumulator$set(\"public\", \"add\", function(x = 1) {\n  self$sum <- self$sum + x \n  invisible(self)\n})"},{"path":"r6.html","id":"inheritance","chapter":"14 R6","heading":"14.2.4 Inheritance","text":"\ninherit behaviour existing class, provide class object inherit argument:$add() overrides superclass implementation, can still delegate superclass implementation using super$. (analogous NextMethod() S3, discussed Section 13.6.) methods overridden use implementation parent class.","code":"\nAccumulatorChatty <- R6Class(\"AccumulatorChatty\", \n  inherit = Accumulator,\n  public = list(\n    add = function(x = 1) {\n      cat(\"Adding \", x, \"\\n\", sep = \"\")\n      super$add(x = x)\n    }\n  )\n)\n\nx2 <- AccumulatorChatty$new()\nx2$add(10)$add(1)$sum\n#> Adding 10\n#> Adding 1\n#> [1] 11"},{"path":"r6.html","id":"introspection","chapter":"14 R6","heading":"14.2.5 Introspection","text":"Every R6 object S3 class reflects hierarchy R6 classes. means easiest way determine class (classes inherits ) use class():S3 hierarchy includes base “R6” class. provides common behaviour, including print.R6() method calls $print(), described .\ncan list methods fields names():defined $name, $age, $print, $initialize. suggested name, .__enclos_env__ internal implementation detail shouldn’t touch; ’ll come back $clone() Section 14.4.","code":"\nclass(hadley2)\n#> [1] \"Person\" \"R6\"\nnames(hadley2)\n#> [1] \".__enclos_env__\" \"age\"             \"name\"            \"clone\"          \n#> [5] \"print\"           \"initialize\""},{"path":"r6.html","id":"exercises-44","chapter":"14 R6","heading":"14.2.6 Exercises","text":"Create bank account R6 class stores balance allows \ndeposit withdraw money. Create subclass throws error\nattempt go overdraft. Create another subclass allows\ngo overdraft, charges fee.Create bank account R6 class stores balance allows \ndeposit withdraw money. Create subclass throws error\nattempt go overdraft. Create another subclass allows\ngo overdraft, charges fee.Create R6 class represents shuffled deck cards. \nable draw cards deck $draw(n), return cards \ndeck reshuffle $reshuffle(). Use following code make\nvector cards.\n\nsuit <- c(\"♠\", \"♥\", \"♦\", \"♣\")\nvalue <- c(\"\", 2:10, \"J\", \"Q\", \"K\")\ncards <- paste0(rep(value, 4), suit)Create R6 class represents shuffled deck cards. \nable draw cards deck $draw(n), return cards \ndeck reshuffle $reshuffle(). Use following code make\nvector cards.can’t model bank account deck cards S3 class?can’t model bank account deck cards S3 class?Create R6 class allows get set current time zone.\ncan access current time zone Sys.timezone() set \nSys.setenv(TZ = \"newtimezone\"). setting time zone, make\nsure new time zone list provided OlsonNames().Create R6 class allows get set current time zone.\ncan access current time zone Sys.timezone() set \nSys.setenv(TZ = \"newtimezone\"). setting time zone, make\nsure new time zone list provided OlsonNames().Create R6 class manages current working directory.\n$get() $set() methods.Create R6 class manages current working directory.\n$get() $set() methods.can’t model time zone current working directory S3\nclass?can’t model time zone current working directory S3\nclass?base type R6 objects built top ? attributes \n?base type R6 objects built top ? attributes \n?","code":"\nsuit <- c(\"♠\", \"♥\", \"♦\", \"♣\")\nvalue <- c(\"A\", 2:10, \"J\", \"Q\", \"K\")\ncards <- paste0(rep(value, 4), suit)"},{"path":"r6.html","id":"r6-access","chapter":"14 R6","heading":"14.3 Controlling access","text":"R6Class() two arguments work similarly public:private allows create fields methods available\nwithin class, outside .private allows create fields methods available\nwithin class, outside .active allows use accessor functions define dynamic, \nactive, fields.active allows use accessor functions define dynamic, \nactive, fields.described following sections.","code":""},{"path":"r6.html","id":"privacy","chapter":"14 R6","heading":"14.3.1 Privacy","text":"R6 can define private fields methods, elements can accessed within class, outside76. two things need know take advantage private elements:private argument R6Class works way public\nargument: give named list methods (functions) fields\n(everything else).private argument R6Class works way public\nargument: give named list methods (functions) fields\n(everything else).Fields methods defined private available within methods\nusing private$ instead self$. access private fields \nmethods outside class.Fields methods defined private available within methods\nusing private$ instead self$. access private fields \nmethods outside class.make concrete, make $age $name fields Person class private. definition Person can set $age $name object creation, access values outside class.distinction public private fields important create complex networks classes, want make clear possible ok others access. Anything ’s private can easily refactored know others aren’t relying . Private methods tend less important R compared programming languages object hierarchies R tend simpler.","code":"\nPerson <- R6Class(\"Person\", \n  public = list(\n    initialize = function(name, age = NA) {\n      private$name <- name\n      private$age <- age\n    },\n    print = function(...) {\n      cat(\"Person: \\n\")\n      cat(\"  Name: \", private$name, \"\\n\", sep = \"\")\n      cat(\"  Age:  \", private$age, \"\\n\", sep = \"\")\n    }\n  ),\n  private = list(\n    age = NA,\n    name = NULL\n  )\n)\n\nhadley3 <- Person$new(\"Hadley\")\nhadley3\n#> Person: \n#>   Name: Hadley\n#>   Age:  NA\nhadley3$name\n#> NULL"},{"path":"r6.html","id":"active-fields","chapter":"14 R6","heading":"14.3.2 Active fields","text":"\nActive fields allow define components look like fields outside, defined functions, like methods. Active fields implemented using active bindings (Section 7.2.6). active binding function takes single argument: value. argument missing(), value retrieved; otherwise ’s modified.example, make active field random returns different value every time access :\nActive fields particularly useful conjunction private fields, make possible implement components look like fields outside provide additional checks. example, can use make read-age field, ensure name length 1 character vector.","code":"\nRando <- R6::R6Class(\"Rando\", active = list(\n  random = function(value) {\n    if (missing(value)) {\n      runif(1)  \n    } else {\n      stop(\"Can't set `$random`\", call. = FALSE)\n    }\n  }\n))\nx <- Rando$new()\nx$random\n#> [1] 0.0808\nx$random\n#> [1] 0.834\nx$random\n#> [1] 0.601\nPerson <- R6Class(\"Person\", \n  private = list(\n    .age = NA,\n    .name = NULL\n  ),\n  active = list(\n    age = function(value) {\n      if (missing(value)) {\n        private$.age\n      } else {\n        stop(\"`$age` is read only\", call. = FALSE)\n      }\n    },\n    name = function(value) {\n      if (missing(value)) {\n        private$.name\n      } else {\n        stopifnot(is.character(value), length(value) == 1)\n        private$.name <- value\n        self\n      }\n    }\n  ),\n  public = list(\n    initialize = function(name, age = NA) {\n      private$.name <- name\n      private$.age <- age\n    }\n  )\n)\n\nhadley4 <- Person$new(\"Hadley\", age = 38)\nhadley4$name\n#> [1] \"Hadley\"\nhadley4$name <- 10\n#> Error in (function (value) : is.character(value) is not TRUE\nhadley4$age <- 20\n#> Error: `$age` is read only"},{"path":"r6.html","id":"exercises-45","chapter":"14 R6","heading":"14.3.3 Exercises","text":"Create bank account class prevents directly setting \naccount balance, can still withdraw deposit . Throw\nerror attempt go overdraft.Create bank account class prevents directly setting \naccount balance, can still withdraw deposit . Throw\nerror attempt go overdraft.Create class write-$password field. \n$check_password(password) method returns TRUE FALSE, \nway view complete password.Create class write-$password field. \n$check_password(password) method returns TRUE FALSE, \nway view complete password.Extend Rando class another active binding allows \naccess previous random value. Ensure active binding \nway access value.Extend Rando class another active binding allows \naccess previous random value. Ensure active binding \nway access value.Can subclasses access private fields/methods parent? Perform\nexperiment find .Can subclasses access private fields/methods parent? Perform\nexperiment find .","code":""},{"path":"r6.html","id":"r6-semantics","chapter":"14 R6","heading":"14.4 Reference semantics","text":"One big differences R6 objects reference semantics. primary consequence reference semantics objects copied modified:Instead, want copy, ’ll need explicitly $clone() object:($clone() recursively clone nested R6 objects. want , ’ll need use $clone(deep = TRUE).)three less obvious consequences:harder reason code uses R6 objects need \nunderstand context.harder reason code uses R6 objects need \nunderstand context.makes sense think R6 object deleted, \ncan write $finalize() complement $initialize().makes sense think R6 object deleted, \ncan write $finalize() complement $initialize().one fields R6 object, must create inside\n$initialize(), R6Class().one fields R6 object, must create inside\n$initialize(), R6Class().consequences described detail .","code":"\ny1 <- Accumulator$new() \ny2 <- y1\n\ny1$add(10)\nc(y1 = y1$sum, y2 = y2$sum)\n#> y1 y2 \n#> 10 10\ny1 <- Accumulator$new() \ny2 <- y1$clone()\n\ny1$add(10)\nc(y1 = y1$sum, y2 = y2$sum)\n#> y1 y2 \n#> 10  0"},{"path":"r6.html","id":"reasoning","chapter":"14 R6","heading":"14.4.1 Reasoning","text":"Generally, reference semantics makes code harder reason . Take simple example:vast majority functions, know final line modifies z.Take similar example uses imaginary List reference class:final line much harder reason : f() calls methods x y, might modify well z. biggest potential downside R6 take care avoid writing functions either return value, modify R6 inputs, . said, can lead substantially simpler code cases, ’ll discuss Section 16.3.2.","code":"\nx <- list(a = 1)\ny <- list(b = 2)\n\nz <- f(x, y)\nx <- List$new(a = 1)\ny <- List$new(b = 2)\n\nz <- f(x, y)"},{"path":"r6.html","id":"finalizer","chapter":"14 R6","heading":"14.4.2 Finalizer","text":"\nOne useful property reference semantics makes sense think R6 object finalized, .e. ’s deleted. doesn’t make sense objects copy--modify semantics mean may many transient versions object, alluded Section 2.6. example, following creates two factor objects: second created levels modified, leaving first destroyed garbage collector.Since R6 objects copied--modify deleted , makes sense think $finalize() complement $initialize(). Finalizers usually play similar role .exit() (described Section 6.7.4), cleaning resources created initializer. example, following class wraps temporary file, automatically deleting class finalized.finalize method run object deleted (precisely, first garbage collection object unbound names) R exits. means finalizer can called effectively anywhere R code, therefore ’s almost impossible reason finalizer code touches shared data structures. Avoid potential problems using finalizer clean private resources allocated initializer.","code":"\nx <- factor(c(\"a\", \"b\", \"c\"))\nlevels(x) <- c(\"c\", \"b\", \"a\")\nTemporaryFile <- R6Class(\"TemporaryFile\", list(\n  path = NULL,\n  initialize = function() {\n    self$path <- tempfile()\n  },\n  finalize = function() {\n    message(\"Cleaning up \", self$path)\n    unlink(self$path)\n  }\n))\ntf <- TemporaryFile$new()\nrm(tf)\n#> Cleaning up /tmp/Rtmpk73JdI/file155f31d8424bd"},{"path":"r6.html","id":"r6-fields","chapter":"14 R6","heading":"14.4.3 R6 fields","text":"final consequence reference semantics can crop don’t expect . use R6 class default value field, shared across instances object! Take following code: want create temporary database every time call TemporaryDatabase$new(), current code always uses path.(’re familiar Python, similar “mutable default argument” problem.)problem arises TemporaryFile$new() called TemporaryDatabase class defined. fix problem, need make sure ’s called every time TemporaryDatabase$new() called, .e. need put $initialize():","code":"\nTemporaryDatabase <- R6Class(\"TemporaryDatabase\", list(\n  con = NULL,\n  file = TemporaryFile$new(),\n  initialize = function() {\n    self$con <- DBI::dbConnect(RSQLite::SQLite(), path = file$path)\n  },\n  finalize = function() {\n    DBI::dbDisconnect(self$con)\n  }\n))\n\ndb_a <- TemporaryDatabase$new()\ndb_b <- TemporaryDatabase$new()\n\ndb_a$file$path == db_b$file$path\n#> [1] TRUE\nTemporaryDatabase <- R6Class(\"TemporaryDatabase\", list(\n  con = NULL,\n  file = NULL,\n  initialize = function() {\n    self$file <- TemporaryFile$new()\n    self$con <- DBI::dbConnect(RSQLite::SQLite(), path = file$path)\n  },\n  finalize = function() {\n    DBI::dbDisconnect(self$con)\n  }\n))\n\ndb_a <- TemporaryDatabase$new()\ndb_b <- TemporaryDatabase$new()\n\ndb_a$file$path == db_b$file$path\n#> [1] FALSE"},{"path":"r6.html","id":"exercises-46","chapter":"14 R6","heading":"14.4.4 Exercises","text":"Create class allows write line specified file.\nopen connection file $initialize(), append \nline using cat() $append_line(), close connection \n$finalize().","code":""},{"path":"r6.html","id":"why-r6","chapter":"14 R6","heading":"14.5 Why R6?","text":"\nR6 similar built-OO system called reference classes, RC short. prefer R6 RC :R6 much simpler. R6 RC built top environments, \nR6 uses S3, RC uses S4. means fully understand RC, need\nunderstand complicated S4 works.R6 much simpler. R6 RC built top environments, \nR6 uses S3, RC uses S4. means fully understand RC, need\nunderstand complicated S4 works.R6 comprehensive online documentation https://r6.r-lib.org.R6 comprehensive online documentation https://r6.r-lib.org.R6 simpler mechanism cross-package subclassing, just\nworks without think . RC, read details \n“External Methods; Inter-Package Superclasses” section ?setRefClass.R6 simpler mechanism cross-package subclassing, just\nworks without think . RC, read details \n“External Methods; Inter-Package Superclasses” section ?setRefClass.RC mingles variables fields stack environments \nget (field) set (field <<- value) fields like regular values. R6 puts\nfields separate environment get (self$field) set\n(self$field <- value) prefix. R6 approach verbose \nlike explicit.RC mingles variables fields stack environments \nget (field) set (field <<- value) fields like regular values. R6 puts\nfields separate environment get (self$field) set\n(self$field <- value) prefix. R6 approach verbose \nlike explicit.R6 much faster RC. Generally, speed method dispatch \nimportant outside microbenchmarks. However, RC quite slow, switching\nRC R6 led substantial performance improvement shiny package.\ndetails, see vignette(\"Performance\", \"R6\").R6 much faster RC. Generally, speed method dispatch \nimportant outside microbenchmarks. However, RC quite slow, switching\nRC R6 led substantial performance improvement shiny package.\ndetails, see vignette(\"Performance\", \"R6\").RC tied R. means bugs fixed, can take\nadvantage fixes requiring newer version R. makes \ndifficult packages (like tidyverse) need work across\nmany R versions.RC tied R. means bugs fixed, can take\nadvantage fixes requiring newer version R. makes \ndifficult packages (like tidyverse) need work across\nmany R versions.Finally, ideas underlie R6 RC similar, \nrequire small amount additional effort learn RC need .Finally, ideas underlie R6 RC similar, \nrequire small amount additional effort learn RC need .","code":""},{"path":"s4.html","id":"s4","chapter":"15 S4","heading":"15 S4","text":"","code":""},{"path":"s4.html","id":"introduction-14","chapter":"15 S4","heading":"15.1 Introduction","text":"S4 provides formal approach functional OOP. underlying ideas similar S3 (topic Chapter 13), implementation much stricter makes use specialised functions creating classes (setClass()), generics (setGeneric()), methods (setMethod()). Additionally, S4 provides multiple inheritance (.e. class can multiple parents) multiple dispatch (.e. method dispatch can use class multiple arguments).important new component S4 slot, named component object accessed using specialised subsetting operator @ (pronounced ). set slots, classes, forms important part definition S4 class.","code":""},{"path":"s4.html","id":"outline-13","chapter":"15 S4","heading":"Outline","text":"Section 15.2 gives quick overview main components S4:\nclasses, generics, methods.Section 15.2 gives quick overview main components S4:\nclasses, generics, methods.Section 15.3 dives details S4 classes, including\nprototypes, constructors, helpers, validators.Section 15.3 dives details S4 classes, including\nprototypes, constructors, helpers, validators.Section 15.4 shows create new S4 generics, \nsupply generics methods. ’ll also learn \naccessor functions designed allow users safely inspect \nmodify object slots.Section 15.4 shows create new S4 generics, \nsupply generics methods. ’ll also learn \naccessor functions designed allow users safely inspect \nmodify object slots.Section 15.5 dives full details method dispatch\nS4. basic idea simple, rapidly gets complex \nmultiple inheritance multiple dispatch combined.Section 15.5 dives full details method dispatch\nS4. basic idea simple, rapidly gets complex \nmultiple inheritance multiple dispatch combined.Section 15.6 discusses interaction S4 S3, showing\nuse together.Section 15.6 discusses interaction S4 S3, showing\nuse together.","code":""},{"path":"s4.html","id":"learning-more","chapter":"15 S4","heading":"Learning more","text":"Like OO chapters, focus S4 works, deploy effectively. want use practice, two main challenges:one reference answer questions S4.one reference answer questions S4.R’s built-documentation sometimes clashes community best practices.R’s built-documentation sometimes clashes community best practices.move towards advanced usage, need piece together needed information carefully reading documentation, asking questions StackOverflow, performing experiments. recommendations:Bioconductor community long-term user S4 produced much \nbest material effective use. Start S4 classes \nmethods taught Martin Morgan Hervé Pagès, \ncheck newer version Bioconductor course materials.\nMartin Morgan member R-core project lead Bioconductor.\n’s world expert practical use S4, recommend reading\nanything written , starting questions \nanswered stackoverflow.Bioconductor community long-term user S4 produced much \nbest material effective use. Start S4 classes \nmethods taught Martin Morgan Hervé Pagès, \ncheck newer version Bioconductor course materials.Martin Morgan member R-core project lead Bioconductor.\n’s world expert practical use S4, recommend reading\nanything written , starting questions \nanswered stackoverflow.John Chambers author S4 system, provides overview\nmotivation historical context Object-oriented programming,\nfunctional programming R.77 fuller exploration\nS4, see book Software Data Analysis.78John Chambers author S4 system, provides overview\nmotivation historical context Object-oriented programming,\nfunctional programming R.77 fuller exploration\nS4, see book Software Data Analysis.78","code":""},{"path":"s4.html","id":"prerequisites-8","chapter":"15 S4","heading":"Prerequisites","text":"functions related S4 live methods package. package always available ’re running R interactively, may available running R batch mode, .e. Rscript79. reason, ’s good idea call library(methods) whenever use S4. also signals reader ’ll using S4 object system.","code":"\nlibrary(methods)"},{"path":"s4.html","id":"s4-basics","chapter":"15 S4","heading":"15.2 Basics","text":"’ll start quick overview main components S4. define S4 class calling setClass() class name definition slots, names classes class data:class defined, can construct new objects calling new() name class value slot:\nGiven S4 object can see class () access slots @ (equivalent $) slot() (equivalent [[):Generally, use @ methods. ’re working someone else’s class, look accessor functions allow safely set get slot values. developer class, also provide accessor functions. Accessors typically S4 generics allowing multiple classes share external interface.’ll create setter getter age slot first creating generics setGeneric():defining methods setMethod():’re using S4 class defined package, can get help class?Person. get help method, put ? front call (e.g. ?age(john)) ? use class arguments figure help file need.Finally, can use sloop functions identify S4 objects generics found wild:","code":"\nsetClass(\"Person\", \n  slots = c(\n    name = \"character\", \n    age = \"numeric\"\n  )\n)\njohn <- new(\"Person\", name = \"John Smith\", age = NA_real_)\nis(john)\n#> [1] \"Person\"\njohn@name\n#> [1] \"John Smith\"\nslot(john, \"age\")\n#> [1] NA\nsetGeneric(\"age\", function(x) standardGeneric(\"age\"))\nsetGeneric(\"age<-\", function(x, value) standardGeneric(\"age<-\"))\nsetMethod(\"age\", \"Person\", function(x) x@age)\nsetMethod(\"age<-\", \"Person\", function(x, value) {\n  x@age <- value\n  x\n})\n\nage(john) <- 50\nage(john)\n#> [1] 50\nsloop::otype(john)\n#> [1] \"S4\"\nsloop::ftype(age)\n#> [1] \"S4\"      \"generic\""},{"path":"s4.html","id":"exercises-47","chapter":"15 S4","heading":"15.2.1 Exercises","text":"lubridate::period() returns S4 class. slots ?\nclass slot? accessors provide?lubridate::period() returns S4 class. slots ?\nclass slot? accessors provide?ways can find help method? Read ?\"?\" \nsummarise details.ways can find help method? Read ?\"?\" \nsummarise details.","code":""},{"path":"s4.html","id":"s4-classes","chapter":"15 S4","heading":"15.3 Classes","text":"\n\ndefine S4 class, call setClass() three arguments:class name. convention, S4 class names use UpperCamelCase.class name. convention, S4 class names use UpperCamelCase.named character vector describes names classes \nslots (fields). example, person might represented character\nname numeric age: c(name = \"character\", age = \"numeric\"). \npseudo-class allows slot accept objects type.named character vector describes names classes \nslots (fields). example, person might represented character\nname numeric age: c(name = \"character\", age = \"numeric\"). \npseudo-class allows slot accept objects type.prototype, list default values slot. Technically,\nprototype optional80, always provide .prototype, list default values slot. Technically,\nprototype optional80, always provide .code illustrates three arguments creating Person class character name numeric age slots.","code":"\nsetClass(\"Person\", \n  slots = c(\n    name = \"character\", \n    age = \"numeric\"\n  ), \n  prototype = list(\n    name = NA_character_,\n    age = NA_real_\n  )\n)\n\nme <- new(\"Person\", name = \"Hadley\")\nstr(me)\n#> Formal class 'Person' [package \".GlobalEnv\"] with 2 slots\n#>   ..@ name: chr \"Hadley\"\n#>   ..@ age : num NA"},{"path":"s4.html","id":"inheritance-1","chapter":"15 S4","heading":"15.3.1 Inheritance","text":"\none important argument setClass(): contains. specifies class (classes) inherit slots behaviour . example, can create Employee class inherits Person class, adding extra slot describes boss.setClass() 9 arguments either deprecated recommended.","code":"\nsetClass(\"Employee\", \n  contains = \"Person\", \n  slots = c(\n    boss = \"Person\"\n  ),\n  prototype = list(\n    boss = new(\"Person\")\n  )\n)\n\nstr(new(\"Employee\"))\n#> Formal class 'Employee' [package \".GlobalEnv\"] with 3 slots\n#>   ..@ boss:Formal class 'Person' [package \".GlobalEnv\"] with 2 slots\n#>   .. .. ..@ name: chr NA\n#>   .. .. ..@ age : num NA\n#>   ..@ name: chr NA\n#>   ..@ age : num NA"},{"path":"s4.html","id":"introspection-1","chapter":"15 S4","heading":"15.3.2 Introspection","text":"\ndetermine classes object inherits , use ():test object inherits specific class, use second argument ():","code":"\nis(new(\"Person\"))\n#> [1] \"Person\"\nis(new(\"Employee\"))\n#> [1] \"Employee\" \"Person\"\nis(john, \"Person\")\n#> [1] TRUE"},{"path":"s4.html","id":"redefinition","chapter":"15 S4","heading":"15.3.3 Redefinition","text":"programming languages, class definition occurs compile-time object construction occurs later, run-time. R, however, definition construction occur run time. call setClass(), registering class definition (hidden) global variable. state-modifying functions need use setClass() care. ’s possible create invalid objects redefine class already instantiated object:can cause confusion interactive creation new classes. (R6 classes problem, described Section 14.2.2.)","code":"\nsetClass(\"A\", slots = c(x = \"numeric\"))\na <- new(\"A\", x = 10)\n\nsetClass(\"A\", slots = c(a_different_slot = \"numeric\"))\na\n#> An object of class \"A\"\n#> Slot \"a_different_slot\":\n#> Error in slot(object, what): no hay un slot de nombre \"a_different_slot\" para ese objeto de clase \"A\""},{"path":"s4.html","id":"helper","chapter":"15 S4","heading":"15.3.4 Helper","text":"\n\n\nnew() low-level constructor suitable use , developer. User-facing classes always paired user-friendly helper. helper always:name class, e.g. myclass().name class, e.g. myclass().thoughtfully crafted user interface carefully chosen default\nvalues useful conversions.thoughtfully crafted user interface carefully chosen default\nvalues useful conversions.Create carefully crafted error messages tailored towards end-user.Create carefully crafted error messages tailored towards end-user.Finish calling methods::new().Finish calling methods::new().Person class simple helper almost superfluous, can use clearly define contract: age optional name required. ’ll also coerce age double helper also works passed integer.","code":"\nPerson <- function(name, age = NA) {\n  age <- as.double(age)\n  \n  new(\"Person\", name = name, age = age)\n}\n\nPerson(\"Hadley\")\n#> An object of class \"Person\"\n#> Slot \"name\":\n#> [1] \"Hadley\"\n#> \n#> Slot \"age\":\n#> [1] NA"},{"path":"s4.html","id":"validator","chapter":"15 S4","heading":"15.3.5 Validator","text":"\n\nconstructor automatically checks slots correct classes:need implement complicated checks (.e. checks involve lengths, multiple slots) . example, might want make clear Person class vector class, can store data multiple people. ’s currently clear @name @age can different lengths:enforce additional constraints write validator setValidity(). takes class function returns TRUE input valid, otherwise returns character vector describing problem(s):Now can longer create invalid object:NB: validity method called automatically new(), can still create invalid object modifying :can explicitly check validity calling validObject():Section 15.4.4, ’ll use validObject() create accessors can create invalid objects.","code":"\nPerson(mtcars)\n#> Error in validObject(.Object): invalid class \"Person\" object: invalid object for slot \"name\" in class \"Person\": got class \"data.frame\", should be or extend class \"character\"\nPerson(\"Hadley\", age = c(30, 37))\n#> An object of class \"Person\"\n#> Slot \"name\":\n#> [1] \"Hadley\"\n#> \n#> Slot \"age\":\n#> [1] 30 37\nsetValidity(\"Person\", function(object) {\n  if (length(object@name) != length(object@age)) {\n    \"@name and @age must be same length\"\n  } else {\n    TRUE\n  }\n})\nPerson(\"Hadley\", age = c(30, 37))\n#> Error in validObject(.Object): invalid class \"Person\" object: @name and @age must be same length\nalex <- Person(\"Alex\", age = 30)\nalex@age <- 1:10\nvalidObject(alex)\n#> Error in validObject(alex): invalid class \"Person\" object: @name and @age must be same length"},{"path":"s4.html","id":"exercises-48","chapter":"15 S4","heading":"15.3.6 Exercises","text":"Extend Person class fields match utils::person().\nThink slots need, class slot ,\n’ll need check validity method.Extend Person class fields match utils::person().\nThink slots need, class slot ,\n’ll need check validity method.happens define new S4 class doesn’t slots?\n(Hint: read virtual classes ?setClass.)happens define new S4 class doesn’t slots?\n(Hint: read virtual classes ?setClass.)Imagine going reimplement factors, dates, data frames \nS4. Sketch setClass() calls use define \nclasses. Think appropriate slots prototype.Imagine going reimplement factors, dates, data frames \nS4. Sketch setClass() calls use define \nclasses. Think appropriate slots prototype.","code":""},{"path":"s4.html","id":"s4-generics","chapter":"15 S4","heading":"15.4 Generics and methods","text":"\n\n\njob generic perform method dispatch, .e. find specific implementation combination classes passed generic. ’ll learn define S4 generics methods, next section ’ll explore precisely S4 method dispatch works.create new S4 generic, call setGeneric() function calls standardGeneric():convention, new S4 generics use lowerCamelCase.bad practice use {} generic triggers special case expensive, generally best avoided.","code":"\nsetGeneric(\"myGeneric\", function(x) standardGeneric(\"myGeneric\"))\n# Don't do this!\nsetGeneric(\"myGeneric\", function(x) {\n  standardGeneric(\"myGeneric\")\n})"},{"path":"s4.html","id":"signature","chapter":"15 S4","heading":"15.4.1 Signature","text":"Like setClass(), setGeneric() many arguments. one need know : signature. allows control arguments used method dispatch. signature supplied, arguments (apart ...) used. occasionally useful remove arguments dispatch. allows require methods provide arguments like verbose = TRUE quiet = FALSE, don’t take part dispatch.","code":"\nsetGeneric(\"myGeneric\", \n  function(x, ..., verbose = TRUE) standardGeneric(\"myGeneric\"),\n  signature = \"x\"\n)"},{"path":"s4.html","id":"methods","chapter":"15 S4","heading":"15.4.2 Methods","text":"\ngeneric isn’t useful without methods, S4 define methods setMethod(). three important arguments: name generic, name class, method .formally, second argument setMethod() called signature. S4, unlike S3, signature can include multiple arguments. makes method dispatch S4 substantially complicated, avoids implement double-dispatch special case. ’ll talk multiple dispatch next section. setMethod() arguments, never use .list methods belong generic, associated class, use methods(\"generic\") methods(class = \"class\"); find implementation specific method, use selectMethod(\"generic\", \"class\").","code":"\nsetMethod(\"myGeneric\", \"Person\", function(x) {\n  # method implementation\n})"},{"path":"s4.html","id":"show-method","chapter":"15 S4","heading":"15.4.3 Show method","text":"commonly defined S4 method controls printing show(), controls object appears printed. define method existing generic, must first determine arguments. can get documentation looking args() generic:show method needs single argument object:","code":"\nargs(getGeneric(\"show\"))\n#> function (object) \n#> NULL\nsetMethod(\"show\", \"Person\", function(object) {\n  cat(is(object)[[1]], \"\\n\",\n      \"  Name: \", object@name, \"\\n\",\n      \"  Age:  \", object@age, \"\\n\",\n      sep = \"\"\n  )\n})\njohn\n#> Person\n#>   Name: John Smith\n#>   Age:  50"},{"path":"s4.html","id":"accessors","chapter":"15 S4","heading":"15.4.4 Accessors","text":"Slots considered internal implementation detail: can change without warning user code avoid accessing directly. Instead, user-accessible slots accompanied pair accessors. slot unique class, can just function:Typically, however, ’ll define generic multiple classes can use interface:slot also writeable, provide setter function. always include validObject() setter prevent user creating invalid objects.(name<- notation unfamiliar, review Section 6.8.)","code":"\nperson_name <- function(x) x@name\nsetGeneric(\"name\", function(x) standardGeneric(\"name\"))\nsetMethod(\"name\", \"Person\", function(x) x@name)\n\nname(john)\n#> [1] \"John Smith\"\nsetGeneric(\"name<-\", function(x, value) standardGeneric(\"name<-\"))\nsetMethod(\"name<-\", \"Person\", function(x, value) {\n  x@name <- value\n  validObject(x)\n  x\n})\n\nname(john) <- \"Jon Smythe\"\nname(john)\n#> [1] \"Jon Smythe\"\n\nname(john) <- letters\n#> Error in validObject(x): invalid class \"Person\" object: @name and @age must be same length"},{"path":"s4.html","id":"exercises-49","chapter":"15 S4","heading":"15.4.5 Exercises","text":"Add age() accessors Person class.Add age() accessors Person class.definition generic, necessary repeat \nname generic twice?definition generic, necessary repeat \nname generic twice?show() method defined Section 15.4.3 use\n(object)[[1]]? (Hint: try printing employee subclass.)show() method defined Section 15.4.3 use\n(object)[[1]]? (Hint: try printing employee subclass.)happens define method different argument names \ngeneric?happens define method different argument names \ngeneric?","code":""},{"path":"s4.html","id":"s4-dispatch","chapter":"15 S4","heading":"15.5 Method dispatch","text":"\nS4 dispatch complicated S4 two important features:Multiple inheritance, .e. class can multiple parents,Multiple dispatch, .e. generic can use multiple arguments pick method.features make S4 powerful, can also make hard understand method get selected given combination inputs. practice, keep method dispatch simple possible avoiding multiple inheritance, reserving multiple dispatch absolutely necessary.’s important describe full details, ’ll start simple single inheritance single dispatch, work way complicated cases. illustrate ideas without getting bogged details, ’ll use imaginary class graph based emoji:Emoji give us compact class names evoke relationships classes. straightforward remember 😜 inherits 😉 inherits 😶, 😎 inherits 🕶 🙂.","code":""},{"path":"s4.html","id":"single-dispatch","chapter":"15 S4","heading":"15.5.1 Single dispatch","text":"Let’s start simplest case: generic function dispatches single class single parent. method dispatch simple ’s good place define graphical conventions ’ll use complex cases.two parts diagram:top part, f(...), defines scope diagram. \ngeneric one argument, class hierarchy three levels\ndeep.top part, f(...), defines scope diagram. \ngeneric one argument, class hierarchy three levels\ndeep.bottom part method graph displays possible methods\ndefined. Methods exist, .e. defined \nsetMethod(), grey background.bottom part method graph displays possible methods\ndefined. Methods exist, .e. defined \nsetMethod(), grey background.find method gets called, start specific class actual arguments, follow arrows find method exists. example, called function object class 😉 follow arrow right find method defined general 😶 class. method found, method dispatch failed error thrown. practice, means alway define methods defined terminal nodes, .e. far right.\n\ntwo pseudo-classes can define methods . called pseudo-classes don’t actually exist, allow define useful behaviours. first pseudo-class matches class81. technical reasons ’ll get later, link method longer links classes:second pseudo-class MISSING. define method pseudo-class, match whenever argument missing. ’s useful single dispatch, important functions like + - use double dispatch behave differently depending whether one two arguments.","code":""},{"path":"s4.html","id":"multiple-inheritance","chapter":"15 S4","heading":"15.5.2 Multiple inheritance","text":"\nThings get complicated class multiple parents.basic process remains : start actual class supplied generic, follow arrows find defined method. wrinkle now multiple arrows follow, might find multiple methods. happens, pick method closest, .e. requires travelling fewest arrows.NB: method graph powerful metaphor understanding method dispatch, implementing way rather inefficient, actual approach S4 uses somewhat different. can read details ?Methods_Details.happens methods distance? example, imagine ’ve defined methods 🕶 🙂, call generic 😎. Note method can found 😶 class, ’ll highlight red double outline.called ambiguous method, diagrams ’ll illustrate thick dotted border. happens R, ’ll get warning, method class comes earlier alphabet picked (effectively random relied upon). discover ambiguity always resolve providing precise method:fallback method still exists rules little complex. indicated wavy dotted lines, method always considered away method real class. means never contribute ambiguity.multiple inheritances hard simultaneously prevent ambiguity, ensure every terminal method implementation, minimise number defined methods (order benefit OOP). example, six ways define two methods call, one free problems. reason, recommend using multiple inheritance extreme care: need carefully think method graph plan accordingly.","code":""},{"path":"s4.html","id":"multiple-dispatch","chapter":"15 S4","heading":"15.5.3 Multiple dispatch","text":"\nunderstand multiple inheritance, understanding multiple dispatch straightforward. follow multiple arrows way previously, now method specified two classes (separated comma).’m going show examples dispatching two arguments, can follow basic principles generate method graphs.main difference multiple inheritance multiple dispatch many arrows follow. following diagram shows four defined methods produce two ambiguous cases:Multiple dispatch tends less tricky work multiple inheritance usually fewer terminal class combinations. example, ’s one. means, minimum, can define single method default behaviour inputs.","code":""},{"path":"s4.html","id":"multiple-dispatch-and-multiple-inheritance","chapter":"15 S4","heading":"15.5.4 Multiple dispatch and multiple inheritance","text":"course can combine multiple dispatch multiple inheritance:still complicated case dispatches two classes, multiple inheritance:method graph gets complicated gets harder harder predict method get called given combination inputs, gets harder harder make sure haven’t introduced ambiguity. draw diagrams figure method actually going called, ’s strong indication go back simplify design.","code":""},{"path":"s4.html","id":"exercises-50","chapter":"15 S4","heading":"15.5.5 Exercises","text":"Draw method graph \nf(😅, 😽).Draw method graph \nf(😅, 😽).Draw method graph \nf(😃, 😉, 😙).Draw method graph \nf(😃, 😉, 😙).Take last example shows multiple dispatch two classes \nuse multiple inheritance. happens define method \nterminal classes? method dispatch save us much work ?Take last example shows multiple dispatch two classes \nuse multiple inheritance. happens define method \nterminal classes? method dispatch save us much work ?","code":""},{"path":"s4.html","id":"s4-s3","chapter":"15 S4","heading":"15.6 S4 and S3","text":"\nwriting S4 code, ’ll often need interact existing S3 classes generics. section describes S4 classes, methods, generics interact existing code.","code":""},{"path":"s4.html","id":"classes","chapter":"15 S4","heading":"15.6.1 Classes","text":"slots contains can use S4 classes, S3 classes, implicit class (Section 13.7.1) base type. use S3 class, must first register setOldClass(). call function S3 class, giving class attribute. example, following definitions already provided base R:However, ’s generally better specific provide full S4 definition slots prototype:Generally, definitions provided creator S3 class. ’re trying build S4 class top S3 class provided package, request package maintainer add call package, rather adding code.S4 object inherits S3 class base type, special virtual slot called .Data. contains underlying base type S3 object: possible define S3 methods S4 generics, S4 methods S3 generics (provided ’ve called setOldClass()). However, ’s complicated might appear first glance, make sure thoroughly read ?Methods_for_S3.","code":"\nsetOldClass(\"data.frame\")\nsetOldClass(c(\"ordered\", \"factor\"))\nsetOldClass(c(\"glm\", \"lm\"))\nsetClass(\"factor\",\n  contains = \"integer\",\n  slots = c(\n    levels = \"character\"\n  ),\n  prototype = structure(\n    integer(),\n    levels = character()\n  )\n)\nsetOldClass(\"factor\", S4Class = \"factor\")\nRangedNumeric <- setClass(\n  \"RangedNumeric\",\n  contains = \"numeric\",\n  slots = c(min = \"numeric\", max = \"numeric\"),\n  prototype = structure(numeric(), min = NA_real_, max = NA_real_)\n)\nrn <- RangedNumeric(1:10, min = 1, max = 10)\nrn@min\n#> [1] 1\nrn@.Data\n#>  [1]  1  2  3  4  5  6  7  8  9 10"},{"path":"s4.html","id":"generics","chapter":"15 S4","heading":"15.6.2 Generics","text":"well creating new generic scratch, ’s also possible convert existing S3 generic S4 generic:case, existing function becomes default () method:NB: setMethod() automatically call setGeneric() first argument isn’t already generic, enabling turn existing function S4 generic. OK convert existing S3 generic S4, avoid converting regular functions S4 generics packages requires careful coordination done multiple packages.","code":"\nsetGeneric(\"mean\")\nselectMethod(\"mean\", \"ANY\")\n#> Method Definition (Class \"derivedDefaultMethod\"):\n#> \n#> function (x, ...) \n#> UseMethod(\"mean\")\n#> <bytecode: 0x00000000119bbf30>\n#> <environment: namespace:base>\n#> \n#> Signatures:\n#>         x    \n#> target  \"ANY\"\n#> defined \"ANY\""},{"path":"s4.html","id":"exercises-51","chapter":"15 S4","heading":"15.6.3 Exercises","text":"full setOldClass() definition look like ordered\nfactor (.e. add slots prototype definition )?full setOldClass() definition look like ordered\nfactor (.e. add slots prototype definition )?Define length method Person class.Define length method Person class.","code":""},{"path":"oo-tradeoffs.html","id":"oo-tradeoffs","chapter":"16 Trade-offs","heading":"16 Trade-offs","text":"","code":""},{"path":"oo-tradeoffs.html","id":"introduction-15","chapter":"16 Trade-offs","heading":"16.1 Introduction","text":"now know three important OOP toolkits available R. Now understand basic operation principles underlie , can start compare contrast systems order understand strengths weaknesses. help pick system likely solve new problems.Overall, picking OO system, recommend default S3. S3 simple, widely used throughout base R CRAN. ’s far perfect, idiosyncrasies well understood known approaches overcome shortcomings. existing background programming likely lean towards R6, feel familiar. think resist tendency two reasons. Firstly, use R6 ’s easy create non-idiomatic API feel odd native R users, surprising pain points reference semantics. Secondly, stick R6, ’ll lose learning new way thinking OOP gives new set tools solving problems.","code":""},{"path":"oo-tradeoffs.html","id":"outline-14","chapter":"16 Trade-offs","heading":"Outline","text":"Section 16.2 compares S3 S4. brief, S4 formal \ntends require upfront planning. makes suitable big\nprojects developed teams, individuals.Section 16.2 compares S3 S4. brief, S4 formal \ntends require upfront planning. makes suitable big\nprojects developed teams, individuals.Section 16.3 compares S3 R6. section quite long \ntwo systems fundamentally different number \ntradeoffs need consider.Section 16.3 compares S3 R6. section quite long \ntwo systems fundamentally different number \ntradeoffs need consider.","code":""},{"path":"oo-tradeoffs.html","id":"prerequisites-9","chapter":"16 Trade-offs","heading":"Prerequisites","text":"need familiar S3, S4, R6, discussed previous three chapters.","code":""},{"path":"oo-tradeoffs.html","id":"s3-s4","chapter":"16 Trade-offs","heading":"16.2 S4 versus S3","text":"\n’ve mastered S3, S4 difficult pick : underlying ideas , S4 just formal, strict, verbose. strictness formality S4 make well suited large teams. Since structure provided system , less need convention, new contributors don’t need much training. S4 tends require upfront design S3, investment likely pay larger projects greater resources available.One large team effort S4 used good effect Bioconductor. Bioconductor similar CRAN: ’s way sharing packages amongst wider audience. Bioconductor smaller CRAN (~1,300 versus ~10,000 packages, July 2017) packages tend tightly integrated shared domain Bioconductor stricter review process. Bioconductor packages required use S4, key data structures (e.g. SummarizedExperiment, IRanges, DNAStringSet) built using S4.S4 also good fit complex systems interrelated objects, ’s possible minimise code duplication careful implementation methods. best example system Matrix package.82 designed efficiently store compute many different types sparse dense matrices. version 1.3.4, defines 102 classes, 21 generic functions, 2008 methods, give idea complexity, small subset class graph shown Figure 16.1.\nFigure 16.1: small subset Matrix class graph showing inheritance sparse matrices. concrete class inherits two virtual parents: one describes data stored (C = column oriented, R = row oriented, T = tagged) one describes restriction matrix (s = symmetric, t = triangle, g = general).\ndomain good fit S4 often computational shortcuts specific combinations sparse matrices. S4 makes easy provide general method works inputs, provide specialised methods inputs allow efficient implementation. requires careful planning avoid method dispatch ambiguity, planning pays higher performance.biggest challenge using S4 combination increased complexity absence single source documentation. S4 complex system can challenging use effectively practice. wouldn’t problem S4 documentation wasn’t scattered R documentation, books, websites. S4 needs book length treatment, book (yet) exist. (documentation S3 better, lack less painful S3 much simpler.)","code":""},{"path":"oo-tradeoffs.html","id":"s3-r6","chapter":"16 Trade-offs","heading":"16.3 R6 versus S3","text":"\nR6 profoundly different OO system S3 S4 built encapsulated objects, rather generic functions. Additionally R6 objects reference semantics, means can modified place. two big differences number non-obvious consequences ’ll explore :generic regular function lives global namespace. R6 method\nbelongs object lives local namespace. influences \nthink naming.generic regular function lives global namespace. R6 method\nbelongs object lives local namespace. influences \nthink naming.R6’s reference semantics allow methods simultaneously return value\nmodify object. solves painful problem called “threading state.”R6’s reference semantics allow methods simultaneously return value\nmodify object. solves painful problem called “threading state.”invoke R6 method using $, infix operator. set \nmethods correctly can use chains method calls alternative\npipe.invoke R6 method using $, infix operator. set \nmethods correctly can use chains method calls alternative\npipe.general trade-offs functional encapsulated OOP, also serve discussion system design R versus Python.","code":""},{"path":"oo-tradeoffs.html","id":"namespacing","chapter":"16 Trade-offs","heading":"16.3.1 Namespacing","text":"One non-obvious difference S3 R6 space methods found:Generic functions global: packages share namespace.Encapsulated methods local: methods bound single object.advantage global namespace multiple packages can use verbs working different types objects. Generic functions provide uniform API makes easier perform typical actions new object strong naming conventions. works well data analysis often want thing different types objects. particular, one reason R’s modelling system useful: regardless model implemented always work using set tools (summary(), predict(), …).disadvantage global namespace forces think deeply naming. want avoid multiple generics name different packages requires user type :: frequently. can hard function names usually English verbs, verbs often multiple meanings. Take plot() example:Generally, avoid methods homonyms original generic, instead define new generic.problem doesn’t occur R6 methods scoped object. following code fine, implication plot method two different R6 objects meaning:considerations also apply arguments generic. S3 generics must core arguments, means generally non-specific names like x .data. S3 generics generally need ... pass additional arguments methods, downside misspelled argument names create error. comparison, R6 methods can vary widely use specific evocative argument names.secondary advantage local namespacing creating R6 method cheap. encapsulated OO languages encourage create many small methods, one thing well evocative name. Creating new S3 method expensive, may also create generic, think naming issues described . means advice create many small methods apply S3. ’s still good idea break code small, easily understood chunks, generally just regular functions, methods.","code":"\nplot(data)       # plot some data\nplot(bank_heist) # plot a crime\nplot(land)       # create a new plot of land\nplot(movie)      # extract plot of a movie\ndata$plot()\nbank_heist$plot()\nland$plot()\nmovie$plot()"},{"path":"oo-tradeoffs.html","id":"threading-state","chapter":"16 Trade-offs","heading":"16.3.2 Threading state","text":"\nOne challenge programming S3 want return value modify object. violates guideline function either called return value side effects, necessary handful cases.example, imagine want create stack objects. stack two main methods:push() adds new object top stack.pop() returns top value, removes stack.implementation constructor push() method straightforward. stack contains list items, pushing object stack simply appends list.(haven’t created real method push() making generic just make example complicated real benefit.)Implementing pop() challenging return value (object top stack), side-effect (remove object top). Since can’t modify input object S3 need return two things: value, updated object.leads rather awkward usage:problem known threading state accumulator programming, matter deeply pop() called, thread modified stack object way back lives.\n\nOne way FP languages deal challenge provide multiple assign (destructuring bind) operator allows assign multiple values single step. zeallot package83 provides multi-assign R %<-%. makes code elegant, doesn’t solve key problem:R6 implementation stack simpler $pop() can modify object place, return top-value:leads natural code:encountered real-life example threading state ggplot2 scales. Scales complex need combine data across every facet every layer. originally used S3 classes, required passing scale data many functions. Switching R6 made code substantially simpler. However, also introduced problems forgot call $clone() modifying plot. allowed independent plots share scale data, creating subtle bug hard track .","code":"\nnew_stack <- function(items = list()) {\n  structure(list(items = items), class = \"stack\")\n}\n\npush <- function(x, y) {\n  x$items <- c(x$items, list(y))\n  x\n}\npop <- function(x) {\n  n <- length(x$items)\n  \n  item <- x$items[[n]]\n  x$items <- x$items[-n]\n  \n  list(item = item, x = x)\n}\ns <- new_stack()\ns <- push(s, 10)\ns <- push(s, 20)\n\nout <- pop(s)\nout$item\n#> [1] 20\ns <- out$x\ns\n#> $items\n#> $items[[1]]\n#> [1] 10\n#> \n#> \n#> attr(,\"class\")\n#> [1] \"stack\"\nlibrary(zeallot)\n#> Warning: package 'zeallot' was built under R version 4.1.2\n\nc(value, s) %<-% pop(s)\nvalue\n#> [1] 10\nStack <- R6::R6Class(\"Stack\", list(\n  items = list(),\n  push = function(x) {\n    self$items <- c(self$items, x)\n    invisible(self)\n  },\n  pop = function() {\n    item <- self$items[[self$length()]]\n    self$items <- self$items[-self$length()]\n    item\n  },\n  length = function() {\n    length(self$items)\n  }\n))\ns <- Stack$new()\ns$push(10)\ns$push(20)\ns$pop()\n#> [1] 20"},{"path":"oo-tradeoffs.html","id":"tradeoffs-pipe","chapter":"16 Trade-offs","heading":"16.3.3 Method chaining","text":"\npipe, %>%, useful provides infix operator makes easy compose functions left--right. Interestingly, pipe important R6 objects already use infix operator: $. allows user chain together multiple method calls single expression, technique known method chaining:technique commonly used programming languages, like Python JavaScript, made possible one convention: R6 method primarily called side-effects (usually modifying object) return invisible(self).primary advantage method chaining can get useful autocomplete; primary disadvantage creator class can add new methods (’s way use multiple dispatch).","code":"\ns <- Stack$new()\ns$\n  push(10)$\n  push(20)$\n  pop()\n#> [1] 20"},{"path":"metaprogramming.html","id":"metaprogramming","chapter":"Introduction","heading":"Introduction","text":"\nOne intriguing things R ability metaprogramming. idea code data can inspected modified programmatically. powerful idea; one deeply influences much R code. basic level, allows things like write library(purrr) instead library(\"purrr\") enable plot(x, sin(x)) automatically label axes x sin(x). deeper level, allows things like use y ~ x1 + x2 represent model predicts value y x1 x2, translate subset(df, x == y) df[df$x == df$y, , drop = FALSE], use dplyr::filter(db, .na(x)) generate SQL x NULL db remote database table.Closely related metaprogramming non-standard evaluation, NSE short. term, commonly used describe behaviour R functions, problematic two ways. Firstly, NSE actually property argument (arguments) function, talking NSE functions little sloppy. Secondly, ’s confusing define something ’s (standard), book ’ll introduce precise vocabulary.Specifically, book focuses tidy evaluation (sometimes called tidy eval short). Tidy evaluation implemented rlang package,84 ’ll use rlang extensively chapters. allow focus big ideas, without distracted quirks implementation arise R’s history. introduce big idea rlang, ’ll circle back talk ideas expressed base R. approach may seem backward , ’s like learning drive using automatic transmission rather stick shift: allows focus big picture learn details. book focusses theoretical side tidy evaluation, can fully understand works ground . looking practical introduction, recommend tidy evaluation book https://tidyeval.tidyverse.org85.’ll learn metaprogramming tidy evaluation following five chapters:Chapter 17 gives high level description whole\nmetaprogramming story, briefly learning major components\nfit together form cohesive whole.Chapter 17 gives high level description whole\nmetaprogramming story, briefly learning major components\nfit together form cohesive whole.Chapter 18 shows R code can described \ntree. ’ll learn visualise trees, rules R’s\ngrammar convert linear sequences characters trees, \nuse recursive functions work code trees.Chapter 18 shows R code can described \ntree. ’ll learn visualise trees, rules R’s\ngrammar convert linear sequences characters trees, \nuse recursive functions work code trees.Chapter 19 presents tools rlang can use \ncapture (quote) unevaluated function arguments. ’ll also learn \nquasiquotation, provides set techniques unquote input make\npossible easily generate new trees code fragments.Chapter 19 presents tools rlang can use \ncapture (quote) unevaluated function arguments. ’ll also learn \nquasiquotation, provides set techniques unquote input make\npossible easily generate new trees code fragments.Chapter 20 moves evaluating captured code. ’ll\nlearn important data structure, quosure, ensures\ncorrect evaluation capturing code evaluate, \nenvironment evaluate . chapter show put\npieces together understand NSE works base R, \nwrite functions work like subset().Chapter 20 moves evaluating captured code. ’ll\nlearn important data structure, quosure, ensures\ncorrect evaluation capturing code evaluate, \nenvironment evaluate . chapter show put\npieces together understand NSE works base R, \nwrite functions work like subset().Chapter 21 finishes combining first-class environments, lexical\nscoping, metaprogramming translate R code languages,\nnamely HTML LaTeX.Chapter 21 finishes combining first-class environments, lexical\nscoping, metaprogramming translate R code languages,\nnamely HTML LaTeX.","code":""},{"path":"meta-big-picture.html","id":"meta-big-picture","chapter":"17 Big picture","heading":"17 Big picture","text":"","code":""},{"path":"meta-big-picture.html","id":"introduction-16","chapter":"17 Big picture","heading":"17.1 Introduction","text":"Metaprogramming hardest topic book brings together many formerly unrelated topics forces grapple issues probably haven’t thought . ’ll also need learn lot new vocabulary, first seem like every new term defined three terms haven’t heard . Even ’re experienced programmer another language, existing skills unlikely much help modern popular languages expose level metaprogramming R provides. don’t surprised ’re frustrated confused first; natural part process happens everyone!think ’s easier learn metaprogramming now ever . last years, theory practice matured substantially, providing strong foundation paired tools allow solve common problems. chapter, ’ll get big picture main pieces fit together.","code":""},{"path":"meta-big-picture.html","id":"outline-15","chapter":"17 Big picture","heading":"Outline","text":"section chapter introduces one big new idea:Section 17.2 shows code data teaches create modify expressions capturing code.Section 17.2 shows code data teaches create modify expressions capturing code.Section 17.3 describes tree-like structure code, called \nabstract syntax tree.Section 17.3 describes tree-like structure code, called \nabstract syntax tree.Section 17.4 shows create new expressions programmatically.Section 17.4 shows create new expressions programmatically.Section 17.5 shows execute expressions evaluating environment.Section 17.5 shows execute expressions evaluating environment.Section 17.6 illustrates customise evaluation supplying custom functions new environment.Section 17.6 illustrates customise evaluation supplying custom functions new environment.Section 17.7 extends customisation data masks, blur line environments data frames.Section 17.7 extends customisation data masks, blur line environments data frames.Section 17.8 introduces new data structure called quosure makes simpler correct.Section 17.8 introduces new data structure called quosure makes simpler correct.","code":""},{"path":"meta-big-picture.html","id":"prerequisites-10","chapter":"17 Big picture","heading":"Prerequisites","text":"chapter introduces big ideas using rlang; ’ll learn base equivalents later chapters. ’ll also use lobstr package explore tree structure code.Make sure ’re also familiar environment (Section 7.2) data frame (Section 3.6) data structures.","code":"\nlibrary(rlang)\nlibrary(lobstr)\n#> Warning: package 'lobstr' was built under R version 4.1.2"},{"path":"meta-big-picture.html","id":"code-data","chapter":"17 Big picture","heading":"17.2 Code is data","text":"first big idea code data: can capture code compute can type data. first way can capture code rlang::expr(). can think expr() returning exactly pass :formally, captured code called expression. expression isn’t single type object, collective term four types (call, symbol, constant, pairlist), ’ll learn Chapter 18.expr() lets capture code ’ve typed. need different tool capture code passed function expr() doesn’t work:need use function specifically designed capture user input function argument: enexpr(). Think “en” context “enrich”: enexpr() takes lazily evaluated argument turns expression:capture_it() uses enexpr() say automatically quotes first argument. ’ll learn term Section 19.2.1.captured expression, can inspect modify . Complex expressions behave much like lists. means can modify using [[ $:first element call function called, means first argument second position. ’ll learn full details Section 18.3.","code":"\nexpr(mean(x, na.rm = TRUE))\n#> mean(x, na.rm = TRUE)\nexpr(10 + 100 + 1000)\n#> 10 + 100 + 1000\ncapture_it <- function(x) {\n  expr(x)\n}\ncapture_it(a + b + c)\n#> x\ncapture_it <- function(x) {\n  enexpr(x)\n}\ncapture_it(a + b + c)\n#> a + b + c\nf <- expr(f(x = 1, y = 2))\n\n# Add a new argument\nf$z <- 3\nf\n#> f(x = 1, y = 2, z = 3)\n\n# Or remove an argument:\nf[[2]] <- NULL\nf\n#> f(y = 2, z = 3)"},{"path":"meta-big-picture.html","id":"code-tree","chapter":"17 Big picture","heading":"17.3 Code is a tree","text":"complex manipulation expressions, need fully understand structure. Behind scenes, almost every programming language represents code tree, often called abstract syntax tree, AST short. R unusual can actually inspect manipulate tree.convenient tool understanding tree-like structure lobstr::ast(). Given code, function displays underlying tree structure. Function calls form branches tree, shown rectangles. leaves tree symbols (like ) constants (like \"b\").Nested function calls create deeply branching trees:function forms can written prefix form (Section 6.8.2), every R expression can displayed way:Displaying AST way useful tool exploring R’s grammar, topic Section 18.4.","code":"\nlobstr::ast(f(a, \"b\"))\n#> o-f \n#> +-a \n#> \\-\"b\"\nlobstr::ast(f1(f2(a, b), f3(1, f4(2))))\n#> o-f1 \n#> +-o-f2 \n#> | +-a \n#> | \\-b \n#> \\-o-f3 \n#>   +-1 \n#>   \\-o-f4 \n#>     \\-2\nlobstr::ast(1 + 2 * 3)\n#> o-`+` \n#> +-1 \n#> \\-o-`*` \n#>   +-2 \n#>   \\-3"},{"path":"meta-big-picture.html","id":"coding-code","chapter":"17 Big picture","heading":"17.4 Code can generate code","text":"well seeing tree code typed human, can also use code create new trees. two main tools: call2() unquoting.rlang::call2() constructs function call components: function call, arguments call .call2() often convenient program , bit clunky interactive use. alternative technique build complex code trees combining simpler code trees template. expr() enexpr() built-support idea via !! (pronounced bang-bang), unquote operator.precise details topic Section 19.4, basically !!x inserts code tree stored x expression. makes easy build complex trees simple fragments:Notice output preserves operator precedence get (x + x) / (y + y) x + x / y + y (.e. x + (x / y) + y). important, particularly ’ve wondering wouldn’t easier just paste strings together.Unquoting gets even useful wrap function, first using enexpr() capture user’s expression, expr() !! create new expression using template. example shows can generate expression computes coefficient variation:(isn’t useful , able create sort building block useful solving complex problems.)Importantly, works even given weird variable names:Dealing weird names86 another good reason avoid paste() generating R code. might think esoteric concern, worrying generating SQL code web applications led SQL injection attacks collectively cost billions dollars.","code":"\ncall2(\"f\", 1, 2, 3)\n#> f(1, 2, 3)\ncall2(\"+\", 1, call2(\"*\", 2, 3))\n#> 1 + 2 * 3\nxx <- expr(x + x)\nyy <- expr(y + y)\n\nexpr(!!xx / !!yy)\n#> (x + x)/(y + y)\ncv <- function(var) {\n  var <- enexpr(var)\n  expr(sd(!!var) / mean(!!var))\n}\n\ncv(x)\n#> sd(x)/mean(x)\ncv(x + y)\n#> sd(x + y)/mean(x + y)\ncv(`)`)\n#> sd(`)`)/mean(`)`)"},{"path":"meta-big-picture.html","id":"eval-intro","chapter":"17 Big picture","heading":"17.5 Evaluation runs code","text":"Inspecting modifying code gives one set powerful tools. get another set powerful tools evaluate, .e. execute run, expression. Evaluating expression requires environment, tells R symbols expression mean. ’ll learn details evaluation Chapter 20.primary tool evaluating expressions base::eval(), takes expression environment:omit environment, eval uses current environment:One big advantages evaluating code manually can tweak environment. two main reasons :temporarily override functions implement domain specific language.add data mask can refer variables data frame \nvariables environment.","code":"\neval(expr(x + y), env(x = 1, y = 10))\n#> [1] 11\neval(expr(x + y), env(x = 2, y = 100))\n#> [1] 102\nx <- 10\ny <- 100\neval(expr(x + y))\n#> [1] 110"},{"path":"meta-big-picture.html","id":"eval-funs","chapter":"17 Big picture","heading":"17.6 Customising evaluation with functions","text":"example used environment bound x y vectors. ’s less obvious also bind names functions, allowing override behaviour existing functions. big idea ’ll come back Chapter 21 explore generating HTML LaTeX R. example gives taste power. evaluate code special environment * + overridden work strings instead numbers:dplyr takes idea extreme, running code environment generates SQL execution remote database:","code":"\nstring_math <- function(x) {\n  e <- env(\n    caller_env(),\n    `+` = function(x, y) paste0(x, y),\n    `*` = function(x, y) strrep(x, y)\n  )\n\n  eval(enexpr(x), e)\n}\n\nname <- \"Hadley\"\nstring_math(\"Hello \" + name)\n#> [1] \"Hello Hadley\"\nstring_math((\"x\" * 2 + \"-y\") * 3)\n#> [1] \"xx-yxx-yxx-y\"\nlibrary(dplyr)\n#> Warning: package 'dplyr' was built under R version 4.1.1\n#> \n#> Attaching package: 'dplyr'\n#> The following objects are masked from 'package:stats':\n#> \n#>     filter, lag\n#> The following objects are masked from 'package:base':\n#> \n#>     intersect, setdiff, setequal, union\n\ncon <- DBI::dbConnect(RSQLite::SQLite(), filename = \":memory:\")\nmtcars_db <- copy_to(con, mtcars)\n\nmtcars_db %>%\n  filter(cyl > 2) %>%\n  select(mpg:hp) %>%\n  head(10) %>%\n  show_query()\n#> <SQL>\n#> SELECT `mpg`, `cyl`, `disp`, `hp`\n#> FROM `mtcars`\n#> WHERE (`cyl` > 2.0)\n#> LIMIT 10\n\nDBI::dbDisconnect(con)"},{"path":"meta-big-picture.html","id":"eval-data","chapter":"17 Big picture","heading":"17.7 Customising evaluation with data","text":"Rebinding functions extremely powerful technique, tends require lot investment. immediately practical application modifying evaluation look variables data frame instead environment. idea powers base subset() transform() functions, well many tidyverse functions like ggplot2::aes() dplyr::mutate(). ’s possible use eval() , potential pitfalls (Section 20.6), ’ll switch rlang::eval_tidy() instead.well expression environment, eval_tidy() also takes data mask, typically data frame:Evaluating data mask useful technique interactive analysis allows write x + y rather df$x + df$y. However, convenience comes cost: ambiguity. Section 20.4 ’ll learn deal ambiguity using special .data .env pronouns.can wrap pattern function using enexpr(). gives us function similar base::():Unfortunately, function subtle bug need new data structure help deal .","code":"\ndf <- data.frame(x = 1:5, y = sample(5))\neval_tidy(expr(x + y), df)\n#> [1] 6 6 4 6 8\nwith2 <- function(df, expr) {\n  eval_tidy(enexpr(expr), df)\n}\n\nwith2(df, x + y)\n#> [1] 6 6 4 6 8"},{"path":"meta-big-picture.html","id":"quosure-intro","chapter":"17 Big picture","heading":"17.8 Quosures","text":"make problem obvious, ’m going modify with2(). basic problem still occurs without modification ’s much harder see.can see problem use with2() refer variable called . want value come binding can see (10), binding internal function (1000):problem arises need evaluate captured expression environment written (10), environment inside with2() (1000).Fortunately can solve problem using new data structure: quosure bundles expression environment. eval_tidy() knows work quosures need switch enexpr() enquo():Whenever use data mask, must always use enquo() instead enexpr(). topic Chapter 20.","code":"\nwith2 <- function(df, expr) {\n  a <- 1000\n  eval_tidy(enexpr(expr), df)\n}\ndf <- data.frame(x = 1:3)\na <- 10\nwith2(df, x + a)\n#> [1] 1001 1002 1003\nwith2 <- function(df, expr) {\n  a <- 1000\n  eval_tidy(enquo(expr), df)\n}\n\nwith2(df, x + a)\n#> [1] 11 12 13"},{"path":"expressions.html","id":"expressions","chapter":"18 Expressions","heading":"18 Expressions","text":"","code":""},{"path":"expressions.html","id":"introduction-17","chapter":"18 Expressions","heading":"18.1 Introduction","text":"compute language, first need understand structure. requires new vocabulary, new tools, new ways thinking R code. first distinction operation result. Take following code, multiplies variable x 10 saves result new variable called y. doesn’t work haven’t defined variable called x:nice capture intent code without executing . words, can separate description action action ?One way use rlang::expr():expr() returns expression, object captures structure code without evaluating (.e. running ). expression, can evaluate base::eval():focus chapter data structures underlie expressions. Mastering knowledge allow inspect modify captured code, generate code code. ’ll come back expr() Chapter 19, eval() Chapter 20.","code":"\ny <- x * 10\n#> Error in eval(expr, envir, enclos): objeto 'x' no encontrado\nz <- rlang::expr(y <- x * 10)\nz\n#> y <- x * 10\nx <- 4\neval(z)\ny\n#> [1] 40"},{"path":"expressions.html","id":"outline-16","chapter":"18 Expressions","heading":"Outline","text":"Section 18.2 introduces idea abstract syntax tree (AST),\nreveals tree like structure underlies R code.Section 18.2 introduces idea abstract syntax tree (AST),\nreveals tree like structure underlies R code.Section 18.3 dives details data\nstructures underpin AST: constants, symbols, calls, \ncollectively known expressions.Section 18.3 dives details data\nstructures underpin AST: constants, symbols, calls, \ncollectively known expressions.Section 18.4 covers parsing, act converting linear\nsequence character code AST, uses idea explore\ndetails R’s grammar.Section 18.4 covers parsing, act converting linear\nsequence character code AST, uses idea explore\ndetails R’s grammar.Section 18.5 shows can use recursive functions \ncompute language, writing functions compute expressions.Section 18.5 shows can use recursive functions \ncompute language, writing functions compute expressions.Section 18.6 circles back three \nspecialised data structures: pairlists, missing arguments, expression\nvectors.Section 18.6 circles back three \nspecialised data structures: pairlists, missing arguments, expression\nvectors.","code":""},{"path":"expressions.html","id":"prerequisites-11","chapter":"18 Expressions","heading":"Prerequisites","text":"Make sure ’ve read metaprogramming overview Chapter 17 get broad overview motivation basic vocabulary. ’ll also need rlang package capture compute expressions, lobstr package visualise .","code":"\nlibrary(rlang)\nlibrary(lobstr)\n#> Warning: package 'lobstr' was built under R version 4.1.2"},{"path":"expressions.html","id":"ast","chapter":"18 Expressions","heading":"18.2 Abstract syntax trees","text":"\nExpressions also called abstract syntax trees (ASTs) structure code hierarchical can naturally represented tree. Understanding tree structure crucial inspecting modifying expressions (.e. metaprogramming).","code":""},{"path":"expressions.html","id":"drawing","chapter":"18 Expressions","heading":"18.2.1 Drawing","text":"’ll start introducing conventions drawing ASTs, beginning simple call shows main components: f(x, \"y\", 1). ’ll draw trees two ways87:“hand” (.e. OmniGraffle):\n“hand” (.e. OmniGraffle):lobstr::ast():\n\nlobstr::ast(f(x, \"y\", 1))\n#> o-f \n#> +-x \n#> +-\"y\" \n#> \\-1With lobstr::ast():approaches share conventions much possible:leaves tree either symbols, like f x, constants,\nlike 1 \"y\". Symbols drawn purple rounded corners.\nConstants black borders square corners. Strings symbols \neasily confused, strings always surrounded quotes.leaves tree either symbols, like f x, constants,\nlike 1 \"y\". Symbols drawn purple rounded corners.\nConstants black borders square corners. Strings symbols \neasily confused, strings always surrounded quotes.branches tree call objects, represent function calls,\ndrawn orange rectangles. first child (f) function\ngets called; second subsequent children (x, \"y\", 1)\narguments function.branches tree call objects, represent function calls,\ndrawn orange rectangles. first child (f) function\ngets called; second subsequent children (x, \"y\", 1)\narguments function.Colours shown call ast(), appear book complicated technical reasons.example contained one function call, making shallow tree. expressions contain considerably calls, creating trees multiple levels. example, consider AST f(g(1, 2), h(3, 4, ())):can read hand-drawn diagrams left--right (ignoring vertical position), lobstr-drawn diagrams top--bottom (ignoring horizontal position). depth within tree determined nesting function calls. also determines evaluation order, evaluation generally proceeds deepest--shallowest, guaranteed lazy evaluation (Section 6.5). Also note appearance (), function call arguments; ’s branch single (symbol) leaf.","code":"\nlobstr::ast(f(x, \"y\", 1))\n#> o-f \n#> +-x \n#> +-\"y\" \n#> \\-1\nlobstr::ast(f(g(1, 2), h(3, 4, i())))\n#> o-f \n#> +-o-g \n#> | +-1 \n#> | \\-2 \n#> \\-o-h \n#>   +-3 \n#>   +-4 \n#>   \\-o-i"},{"path":"expressions.html","id":"non-code-components","chapter":"18 Expressions","heading":"18.2.2 Non-code components","text":"might wondered makes abstract syntax trees. abstract capture important structural details code, whitespace comments:’s one place whitespace affects AST:","code":"\nast(\n  f(x,  y)  # important!\n)\n#> o-f \n#> +-x \n#> \\-y\nlobstr::ast(y <- x)\n#> o-`<-` \n#> +-y \n#> \\-x\nlobstr::ast(y < -x)\n#> o-`<` \n#> +-y \n#> \\-o-`-` \n#>   \\-x"},{"path":"expressions.html","id":"infix-calls","chapter":"18 Expressions","heading":"18.2.3 Infix calls","text":"Every call R can written tree form call can written prefix form (Section 6.8.1). Take y <- x * 10 : functions called? easy spot f(x, 1) expression contains two infix calls: <- *. means two lines code equivalent:AST88:really difference ASTs, generate expression prefix calls, R still print infix form:order infix operators applied governed set rules called operator precedence, ’ll use lobstr::ast() explore Section 18.4.1.","code":"\ny <- x * 10\n`<-`(y, `*`(x, 10))\nlobstr::ast(y <- x * 10)\n#> o-`<-` \n#> +-y \n#> \\-o-`*` \n#>   +-x \n#>   \\-10\nexpr(`<-`(y, `*`(x, 10)))\n#> y <- x * 10"},{"path":"expressions.html","id":"exercises-52","chapter":"18 Expressions","heading":"18.2.4 Exercises","text":"Reconstruct code represented trees :\n#> o-f \n#> \\-o-g \n#>   \\-o-h\n#> o-`+` \n#> +-o-`+` \n#> | +-1 \n#> | \\-2 \n#> \\-3\n#> o-`*` \n#> +-o-`(` \n#> | \\-o-`+` \n#> |   +-x \n#> |   \\-y \n#> \\-zReconstruct code represented trees :Draw following trees hand check answers \nlobstr::ast().\n\nf(g(h((1, 2, 3))))\nf(1, g(2, h(3, ())))\nf(g(1, 2), h(3, (4, 5)))Draw following trees hand check answers \nlobstr::ast().’s happening ASTs ? (Hint: carefully read ?\"^\".)\n\nlobstr::ast(`x` + `y`)\n#> o-`+` \n#> +-x \n#> \\-y\nlobstr::ast(x ** y)\n#> o-`^` \n#> +-x \n#> \\-y\nlobstr::ast(1 -> x)\n#> o-`<-` \n#> +-x \n#> \\-1What’s happening ASTs ? (Hint: carefully read ?\"^\".)special AST ? (Hint: re-read Section\n6.2.1.)\n\nlobstr::ast(function(x = 1, y = 2) {})\n#> o-`function` \n#> +-o-x = 1 \n#> | \\-y = 2 \n#> +-o-`{` \n#> \\-<inline srcref>special AST ? (Hint: re-read Section\n6.2.1.)call tree statement multiple else \nconditions look like? ?call tree statement multiple else \nconditions look like? ?","code":"#> o-f \n#> \\-o-g \n#>   \\-o-h\n#> o-`+` \n#> +-o-`+` \n#> | +-1 \n#> | \\-2 \n#> \\-3\n#> o-`*` \n#> +-o-`(` \n#> | \\-o-`+` \n#> |   +-x \n#> |   \\-y \n#> \\-z\nf(g(h(i(1, 2, 3))))\nf(1, g(2, h(3, i())))\nf(g(1, 2), h(3, i(4, 5)))\nlobstr::ast(`x` + `y`)\n#> o-`+` \n#> +-x \n#> \\-y\nlobstr::ast(x ** y)\n#> o-`^` \n#> +-x \n#> \\-y\nlobstr::ast(1 -> x)\n#> o-`<-` \n#> +-x \n#> \\-1\nlobstr::ast(function(x = 1, y = 2) {})\n#> o-`function` \n#> +-o-x = 1 \n#> | \\-y = 2 \n#> +-o-`{` \n#> \\-<inline srcref>"},{"path":"expressions.html","id":"expression-details","chapter":"18 Expressions","heading":"18.3 Expressions","text":"\nCollectively, data structures present AST called expressions. expression member set base types created parsing code: constant scalars, symbols, call objects, pairlists. data structures used represent captured code expr(), is_expression(expr(...)) always true89. Constants, symbols call objects important, discussed . Pairlists empty symbols specialised ’ll come back Sections 18.6.1 Section 18.6.2.NB: base R documentation “expression” used mean two things. well definition , expression also used refer type object returned expression() parse(), basically lists expressions defined . book ’ll call expression vectors, ’ll come back Section 18.6.3.","code":""},{"path":"expressions.html","id":"constants","chapter":"18 Expressions","heading":"18.3.1 Constants","text":"\nScalar constants simplest component AST. precisely, constant either NULL length-1 atomic vector (scalar, Section 3.2.1) like TRUE, 1L, 2.5 \"x\". can test constant rlang::is_syntactic_literal().Constants self-quoting sense expression used represent constant constant:","code":"\nidentical(expr(TRUE), TRUE)\n#> [1] TRUE\nidentical(expr(1), 1)\n#> [1] TRUE\nidentical(expr(2L), 2L)\n#> [1] TRUE\nidentical(expr(\"x\"), \"x\")\n#> [1] TRUE"},{"path":"expressions.html","id":"symbols","chapter":"18 Expressions","heading":"18.3.2 Symbols","text":"\n\nsymbol represents name object like x, mtcars, mean. base R, terms symbol name used interchangeably (.e. .name() identical .symbol()), book used symbol consistently “name” many meanings.can create symbol two ways: capturing code references object expr(), turning string symbol rlang::sym():can turn symbol back string .character() rlang::as_string(). as_string() advantage clearly signalling ’ll get character vector length 1.can recognise symbol ’s printed without quotes, str() tells ’s symbol, .symbol() TRUE:symbol type vectorised, .e. symbol always length 1. want multiple symbols, ’ll need put list, using (e.g.) rlang::syms().","code":"\nexpr(x)\n#> x\nsym(\"x\")\n#> x\nas_string(expr(x))\n#> [1] \"x\"\nstr(expr(x))\n#>  symbol x\nis.symbol(expr(x))\n#> [1] TRUE"},{"path":"expressions.html","id":"calls","chapter":"18 Expressions","heading":"18.3.3 Calls","text":"\ncall object represents captured function call. Call objects special type list90 first component specifies function call (usually symbol), remaining elements arguments call. Call objects create branches AST, calls can nested inside calls.can identify call object printed looks just like function call. Confusingly typeof() str() print “language”91 call objects, .call() returns TRUE:","code":"\nlobstr::ast(read.table(\"important.csv\", row.names = FALSE))\n#> o-read.table \n#> +-\"important.csv\" \n#> \\-row.names = FALSE\nx <- expr(read.table(\"important.csv\", row.names = FALSE))\n\ntypeof(x)\n#> [1] \"language\"\nis.call(x)\n#> [1] TRUE"},{"path":"expressions.html","id":"subsetting-1","chapter":"18 Expressions","heading":"18.3.3.1 Subsetting","text":"Calls generally behave like lists, .e. can use standard subsetting tools. first element call object function call, usually symbol:remainder elements arguments:can extract individual arguments [[ , named, $:can determine number arguments call object subtracting 1 length:Extracting specific arguments calls challenging R’s flexible rules argument matching: potentially location, full name, abbreviated name, name. work around problem, can use rlang::call_standardise() standardises arguments use full name:\n(NB: function uses ... ’s possible standardise arguments.)Calls can modified way lists:","code":"\nx[[1]]\n#> read.table\nis.symbol(x[[1]])\n#> [1] TRUE\nas.list(x[-1])\n#> [[1]]\n#> [1] \"important.csv\"\n#> \n#> $row.names\n#> [1] FALSE\nx[[2]]\n#> [1] \"important.csv\"\nx$row.names\n#> [1] FALSE\nlength(x) - 1\n#> [1] 2\nrlang::call_standardise(x)\n#> read.table(file = \"important.csv\", row.names = FALSE)\nx$header <- TRUE\nx\n#> read.table(\"important.csv\", row.names = FALSE, header = TRUE)"},{"path":"expressions.html","id":"function-position","chapter":"18 Expressions","heading":"18.3.3.2 Function position","text":"first element call object function position. contains function called object evaluated, usually symbol92:R allows surround name function quotes, parser converts symbol:However, sometimes function doesn’t exist current environment need computation retrieve : example, function another package, method R6 object, created function factory. case, function position occupied another call:","code":"\nlobstr::ast(foo())\n#> o-foo\nlobstr::ast(\"foo\"())\n#> o-foo\nlobstr::ast(pkg::foo(1))\n#> o-o-`::` \n#> | +-pkg \n#> | \\-foo \n#> \\-1\nlobstr::ast(obj$foo(1))\n#> o-o-`$` \n#> | +-obj \n#> | \\-foo \n#> \\-1\nlobstr::ast(foo(1)(2))\n#> o-o-foo \n#> | \\-1 \n#> \\-2"},{"path":"expressions.html","id":"call2","chapter":"18 Expressions","heading":"18.3.3.3 Constructing","text":"\ncan construct call object components using rlang::call2(). first argument name function call (either string, symbol, another call). remaining arguments passed along call:Infix calls created way still print usual.Using call2() create complex expressions bit clunky. ’ll learn another technique Chapter 19.","code":"\ncall2(\"mean\", x = expr(x), na.rm = TRUE)\n#> mean(x = x, na.rm = TRUE)\ncall2(expr(base::mean), x = expr(x), na.rm = TRUE)\n#> base::mean(x = x, na.rm = TRUE)\ncall2(\"<-\", expr(x), 10)\n#> x <- 10"},{"path":"expressions.html","id":"summary","chapter":"18 Expressions","heading":"18.3.4 Summary","text":"following table summarises appearance different expression subtypes str() typeof():base R rlang provide functions testing type input, although types covered slightly different. can easily tell apart base functions start . rlang functions start is_.","code":""},{"path":"expressions.html","id":"exercises-53","chapter":"18 Expressions","heading":"18.3.5 Exercises","text":"two six types atomic vector can’t appear expression?\n? Similarly, can’t create expression contains atomic\nvector length greater one?two six types atomic vector can’t appear expression?\n? Similarly, can’t create expression contains atomic\nvector length greater one?happens subset call object remove first element?\ne.g. expr(read.csv(\"foo.csv\", header = TRUE))[-1]. ?happens subset call object remove first element?\ne.g. expr(read.csv(\"foo.csv\", header = TRUE))[-1]. ?Describe differences following call objects.\n\nx <- 1:10\n\ncall2(median, x, na.rm = TRUE)\ncall2(expr(median), x, na.rm = TRUE)\ncall2(median, expr(x), na.rm = TRUE)\ncall2(expr(median), expr(x), na.rm = TRUE)Describe differences following call objects.rlang::call_standardise() doesn’t work well following calls.\n? makes mean() special?\n\ncall_standardise(quote(mean(1:10, na.rm = TRUE)))\n#> mean(x = 1:10, na.rm = TRUE)\ncall_standardise(quote(mean(n = T, 1:10)))\n#> mean(x = 1:10, n = T)\ncall_standardise(quote(mean(x = 1:10, , TRUE)))\n#> mean(x = 1:10, , TRUE)rlang::call_standardise() doesn’t work well following calls.\n? makes mean() special?code make sense?\n\nx <- expr(foo(x = 1))\nnames(x) <- c(\"x\", \"y\")code make sense?Construct expression (x > 1) \"\" else \"b\" using multiple calls \ncall2(). code structure reflect structure AST?Construct expression (x > 1) \"\" else \"b\" using multiple calls \ncall2(). code structure reflect structure AST?","code":"\nx <- 1:10\n\ncall2(median, x, na.rm = TRUE)\ncall2(expr(median), x, na.rm = TRUE)\ncall2(median, expr(x), na.rm = TRUE)\ncall2(expr(median), expr(x), na.rm = TRUE)\ncall_standardise(quote(mean(1:10, na.rm = TRUE)))\n#> mean(x = 1:10, na.rm = TRUE)\ncall_standardise(quote(mean(n = T, 1:10)))\n#> mean(x = 1:10, n = T)\ncall_standardise(quote(mean(x = 1:10, , TRUE)))\n#> mean(x = 1:10, , TRUE)\nx <- expr(foo(x = 1))\nnames(x) <- c(\"x\", \"y\")"},{"path":"expressions.html","id":"grammar","chapter":"18 Expressions","heading":"18.4 Parsing and grammar","text":"’ve talked lot expressions AST, expressions created code type (like \"x + y\"). process computer language takes string constructs expression called parsing, governed set rules known grammar. section, ’ll use lobstr::ast() explore details R’s grammar, show can transform back forth expressions strings.","code":""},{"path":"expressions.html","id":"operator-precedence","chapter":"18 Expressions","heading":"18.4.1 Operator precedence","text":"Infix functions introduce two sources ambiguity93. first source ambiguity arises infix functions: 1 + 2 * 3 yield? get 9 (.e. (1 + 2) * 3), 7 (.e. 1 + (2 * 3))? words, two possible parse trees R use?Programming languages use conventions called operator precedence resolve ambiguity. can use ast() see R :Predicting precedence arithmetic operations usually easy ’s drilled school consistent across vast majority programming languages.Predicting precedence operators harder. ’s one particularly surprising case R: ! much lower precedence (.e. binds less tightly) might expect. allows write useful operations like:R 30 infix operators divided 18 precedence groups. details described ?Syntax, people memorised complete ordering. ’s confusion, use parentheses!Note appearance parentheses AST call ( function.","code":"\nlobstr::ast(1 + 2 * 3)\n#> o-`+` \n#> +-1 \n#> \\-o-`*` \n#>   +-2 \n#>   \\-3\nlobstr::ast(!x %in% y)\n#> o-`!` \n#> \\-o-`%in%` \n#>   +-x \n#>   \\-y\nlobstr::ast((1 + 2) * 3)\n#> o-`*` \n#> +-o-`(` \n#> | \\-o-`+` \n#> |   +-1 \n#> |   \\-2 \n#> \\-3"},{"path":"expressions.html","id":"associativity","chapter":"18 Expressions","heading":"18.4.2 Associativity","text":"second source ambiguity introduced repeated usage infix function. example, 1 + 2 + 3 equivalent (1 + 2) + 3 1 + (2 + 3)? normally doesn’t matter x + (y + z) == (x + y) + z, .e. addition associative, needed S3 classes define + non-associative way. example, ggplot2 overloads + build complex plot simple pieces; non-associative earlier layers drawn underneath later layers (.e. geom_point() + geom_smooth() yield plot geom_smooth() + geom_point()).R, operators left-associative, .e. operations left evaluated first:two exceptions: exponentiation assignment.","code":"\nlobstr::ast(1 + 2 + 3)\n#> o-`+` \n#> +-o-`+` \n#> | +-1 \n#> | \\-2 \n#> \\-3\nlobstr::ast(2^2^3)\n#> o-`^` \n#> +-2 \n#> \\-o-`^` \n#>   +-2 \n#>   \\-3\nlobstr::ast(x <- y <- z)\n#> o-`<-` \n#> +-x \n#> \\-o-`<-` \n#>   +-y \n#>   \\-z"},{"path":"expressions.html","id":"parsing","chapter":"18 Expressions","heading":"18.4.3 Parsing and deparsing","text":"\ntime type code console, R takes care turning characters ’ve typed AST. occasionally code stored string, want parse . can using rlang::parse_expr():parse_expr() always returns single expression. multiple expression separated ; \\n, ’ll need use rlang::parse_exprs(). returns list expressions:find working strings containing code frequently, reconsider process. Read Chapter 19 consider whether can generate expressions using quasiquotation safely.base equivalent parse_exprs() parse(). little harder use ’s specialised parsing R code stored files. need supply string text argument returns expression vector (Section 18.6.3). recommend turning output list:\ninverse parsing deparsing: given expression, want string generate . happens automatically print expression, can get string rlang::expr_text():Parsing deparsing perfectly symmetric parsing generates abstract syntax tree. means lose backticks around ordinary names, comments, whitespace:careful using base R equivalent, deparse(): returns character vector one element line. Whenever use , remember length output might greater one, plan accordingly.","code":"\nx1 <- \"y <- x + 10\"\nx1\n#> [1] \"y <- x + 10\"\nis.call(x1)\n#> [1] FALSE\n\nx2 <- rlang::parse_expr(x1)\nx2\n#> y <- x + 10\nis.call(x2)\n#> [1] TRUE\nx3 <- \"a <- 1; a + 1\"\nrlang::parse_exprs(x3)\n#> [[1]]\n#> a <- 1\n#> \n#> [[2]]\n#> a + 1\nas.list(parse(text = x1))\n#> [[1]]\n#> y <- x + 10\nz <- expr(y <- x + 10)\nexpr_text(z)\n#> [1] \"y <- x + 10\"\ncat(expr_text(expr({\n  # This is a comment\n  x <-             `x` + 1\n})))\n#> {\n#>     x <- x + 1\n#> }"},{"path":"expressions.html","id":"exercises-54","chapter":"18 Expressions","heading":"18.4.4 Exercises","text":"R uses parentheses two slightly different ways illustrated \ntwo calls:\n\nf((1))\n`(`(1 + 1)\nCompare contrast two uses referencing AST.R uses parentheses two slightly different ways illustrated \ntwo calls:Compare contrast two uses referencing AST.= can also used two ways. Construct simple example shows\nuses.= can also used two ways. Construct simple example shows\nuses.-2^2 yield 4 -4? ?-2^2 yield 4 -4? ?!1 + !1 return? ?!1 + !1 return? ?x1 <- x2 <- x3 <- 0 work? Describe two reasons.x1 <- x2 <- x3 <- 0 work? Describe two reasons.Compare ASTs x + y %+% z x ^ y %+% z. learned\nprecedence custom infix functions?Compare ASTs x + y %+% z x ^ y %+% z. learned\nprecedence custom infix functions?happens call parse_expr() string generates\nmultiple expressions? e.g. parse_expr(\"x + 1; y + 1\")happens call parse_expr() string generates\nmultiple expressions? e.g. parse_expr(\"x + 1; y + 1\")happens attempt parse invalid expression? e.g. \"+\"\n\"f())\".happens attempt parse invalid expression? e.g. \"+\"\n\"f())\".deparse() produces vectors input long. example, \nfollowing call produces vector length two:\n\nexpr <- expr(g(+ b + c + d + e + f + g + h + + j + k + l + \n  m + n + o + p + q + r + s + t + u + v + w + x + y + z))\n\ndeparse(expr)\nexpr_text() instead?deparse() produces vectors input long. example, \nfollowing call produces vector length two:expr_text() instead?pairwise.t.test() assumes deparse() always returns length one\ncharacter vector. Can construct input violates expectation?\nhappens?pairwise.t.test() assumes deparse() always returns length one\ncharacter vector. Can construct input violates expectation?\nhappens?","code":"\nf((1))\n`(`(1 + 1)\nexpr <- expr(g(a + b + c + d + e + f + g + h + i + j + k + l + \n  m + n + o + p + q + r + s + t + u + v + w + x + y + z))\n\ndeparse(expr)"},{"path":"expressions.html","id":"ast-funs","chapter":"18 Expressions","heading":"18.5 Walking AST with recursive functions","text":"\nconclude chapter ’m going use everything ’ve learned ASTs solve complicated problems. inspiration comes base codetools package, provides two interesting functions:findGlobals() locates global variables used function. \ncan useful want check function doesn’t inadvertently\nrely variables defined parent environment.findGlobals() locates global variables used function. \ncan useful want check function doesn’t inadvertently\nrely variables defined parent environment.checkUsage() checks range common problems including\nunused local variables, unused parameters, use partial\nargument matching.checkUsage() checks range common problems including\nunused local variables, unused parameters, use partial\nargument matching.Getting details functions correct fiddly, won’t fully develop ideas. Instead ’ll focus big underlying idea: recursion AST. Recursive functions natural fit tree-like data structures recursive function made two parts correspond two parts tree:recursive case handles nodes tree. Typically, ’ll\nsomething child node, usually calling recursive function\n, combine results back together . expressions,\n’ll need handle calls pairlists (function arguments).recursive case handles nodes tree. Typically, ’ll\nsomething child node, usually calling recursive function\n, combine results back together . expressions,\n’ll need handle calls pairlists (function arguments).base case handles leaves tree. base cases ensure\nfunction eventually terminates, solving simplest cases\ndirectly. expressions, need handle symbols constants \nbase case.base case handles leaves tree. base cases ensure\nfunction eventually terminates, solving simplest cases\ndirectly. expressions, need handle symbols constants \nbase case.make pattern easier see, ’ll need two helper functions. First define expr_type() return “constant” constant, “symbol” symbols, “call,” calls, “pairlist” pairlists, “type” anything else:’ll couple wrapper around switch function:two functions hand, can write basic template function walks AST using switch() (Section 5.2.3):Typically, solving base case easy, ’ll first, check results. recursive cases trickier, often require functional programming.","code":"\nexpr_type <- function(x) {\n  if (rlang::is_syntactic_literal(x)) {\n    \"constant\"\n  } else if (is.symbol(x)) {\n    \"symbol\"\n  } else if (is.call(x)) {\n    \"call\"\n  } else if (is.pairlist(x)) {\n    \"pairlist\"\n  } else {\n    typeof(x)\n  }\n}\n\nexpr_type(expr(\"a\"))\n#> [1] \"constant\"\nexpr_type(expr(x))\n#> [1] \"symbol\"\nexpr_type(expr(f(1, 2)))\n#> [1] \"call\"\nswitch_expr <- function(x, ...) {\n  switch(expr_type(x),\n    ...,\n    stop(\"Don't know how to handle type \", typeof(x), call. = FALSE)\n  )\n}\nrecurse_call <- function(x) {\n  switch_expr(x,\n    # Base cases\n    symbol = ,\n    constant = ,\n\n    # Recursive cases\n    call = ,\n    pairlist =\n  )\n}"},{"path":"expressions.html","id":"finding-f-and-t","chapter":"18 Expressions","heading":"18.5.1 Finding F and T","text":"’ll start function determines whether another function uses logical abbreviations T F using often considered poor coding practice. goal return TRUE input contains logical abbreviation, FALSE otherwise.Let’s first find type T versus TRUE:TRUE parsed logical vector length one, T parsed name. tells us write base cases recursive function: constant never logical abbreviation, symbol abbreviation ’s “F” “T”:’ve written logical_abbr_rec() function assuming input expression make recursive operation simpler. However, writing recursive function ’s common write wrapper provides defaults makes function little easier use. ’ll typically make wrapper quotes input (’ll learn next chapter), don’t need use expr() every time.Next need implement recursive cases. want thing calls pairlists: recursively apply function subcomponent, return TRUE subcomponent contains logical abbreviation. made easy purrr::(), iterates list returns TRUE predicate function true element.","code":"\nexpr_type(expr(TRUE))\n#> [1] \"constant\"\n\nexpr_type(expr(T))\n#> [1] \"symbol\"\nlogical_abbr_rec <- function(x) {\n  switch_expr(x,\n    constant = FALSE,\n    symbol = as_string(x) %in% c(\"F\", \"T\")\n  )\n}\n\nlogical_abbr_rec(expr(TRUE))\n#> [1] FALSE\nlogical_abbr_rec(expr(T))\n#> [1] TRUE\nlogical_abbr <- function(x) {\n  logical_abbr_rec(enexpr(x))\n}\n\nlogical_abbr(T)\n#> [1] TRUE\nlogical_abbr(FALSE)\n#> [1] FALSE\nlogical_abbr_rec <- function(x) {\n  switch_expr(x,\n    # Base cases\n    constant = FALSE,\n    symbol = as_string(x) %in% c(\"F\", \"T\"),\n\n    # Recursive cases\n    call = ,\n    pairlist = purrr::some(x, logical_abbr_rec)\n  )\n}\n\nlogical_abbr(mean(x, na.rm = T))\n#> [1] TRUE\nlogical_abbr(function(x, na.rm = T) FALSE)\n#> [1] TRUE"},{"path":"expressions.html","id":"finding-all-variables-created-by-assignment","chapter":"18 Expressions","heading":"18.5.2 Finding all variables created by assignment","text":"logical_abbr() relatively simple: returns single TRUE FALSE. next task, listing variables created assignment, little complicated. ’ll start simply, make function progressively rigorous. start looking AST assignment:Assignment call object first element symbol <-, second name variable, third value assigned.Next, need decide data structure ’re going use results. think easiest return character vector. return symbols, ’ll need use list() makes things little complicated.hand can start implementing base cases providing helpful wrapper around recursive function. base cases straightforward know neither symbol constant represents assignment.Next implement recursive cases. made easier function exist purrr, currently doesn’t. flat_map_chr() expects .f return character vector arbitrary length, flattens results single character vector.recursive case pairlists straightforward: iterate every element pairlist (.e. function argument) combine results. case calls little bit complex: call <- return second element call:Now need make function robust coming examples intended break . happens assign variable multiple times?’s easiest fix level wrapper function:happens nested calls <-? Currently return first. ’s <- occurs immediately terminate recursion.Instead need take rigorous approach. think ’s best keep recursive function focused tree structure, ’m going extract find_assign_call() separate function.complete version function quite complicated, ’s important remember wrote working way writing simple component parts.","code":"\nast(x <- 10)\n#> o-`<-` \n#> +-x \n#> \\-10\nfind_assign_rec <- function(x) {\n  switch_expr(x,\n    constant = ,\n    symbol = character()\n  )\n}\nfind_assign <- function(x) find_assign_rec(enexpr(x))\n\nfind_assign(\"x\")\n#> character(0)\nfind_assign(x)\n#> character(0)\nflat_map_chr <- function(.x, .f, ...) {\n  purrr::flatten_chr(purrr::map(.x, .f, ...))\n}\n\nflat_map_chr(letters[1:3], ~ rep(., sample(3, 1)))\n#> [1] \"a\" \"b\" \"b\" \"b\" \"c\" \"c\" \"c\"\nfind_assign_rec <- function(x) {\n  switch_expr(x,\n    # Base cases\n    constant = ,\n    symbol = character(),\n\n    # Recursive cases\n    pairlist = flat_map_chr(as.list(x), find_assign_rec),\n    call = {\n      if (is_call(x, \"<-\")) {\n        as_string(x[[2]])\n      } else {\n        flat_map_chr(as.list(x), find_assign_rec)\n      }\n    }\n  )\n}\n\nfind_assign(a <- 1)\n#> [1] \"a\"\nfind_assign({\n  a <- 1\n  {\n    b <- 2\n  }\n})\n#> [1] \"a\" \"b\"\nfind_assign({\n  a <- 1\n  a <- 2\n})\n#> [1] \"a\" \"a\"\nfind_assign <- function(x) unique(find_assign_rec(enexpr(x)))\n\nfind_assign({\n  a <- 1\n  a <- 2\n})\n#> [1] \"a\"\nfind_assign({\n  a <- b <- c <- 1\n})\n#> [1] \"a\"\nfind_assign_call <- function(x) {\n  if (is_call(x, \"<-\") && is_symbol(x[[2]])) {\n    lhs <- as_string(x[[2]])\n    children <- as.list(x)[-1]\n  } else {\n    lhs <- character()\n    children <- as.list(x)\n  }\n\n  c(lhs, flat_map_chr(children, find_assign_rec))\n}\n\nfind_assign_rec <- function(x) {\n  switch_expr(x,\n    # Base cases\n    constant = ,\n    symbol = character(),\n\n    # Recursive cases\n    pairlist = flat_map_chr(x, find_assign_rec),\n    call = find_assign_call(x)\n  )\n}\n\nfind_assign(a <- b <- c <- 1)\n#> [1] \"a\" \"b\" \"c\"\nfind_assign(system.time(x <- print(y <- 5)))\n#> [1] \"x\" \"y\""},{"path":"expressions.html","id":"exercises-55","chapter":"18 Expressions","heading":"18.5.3 Exercises","text":"logical_abbr() returns TRUE T(1, 2, 3). modify\nlogical_abbr_rec() ignores function calls use T F?logical_abbr() returns TRUE T(1, 2, 3). modify\nlogical_abbr_rec() ignores function calls use T F?logical_abbr() works expressions. currently fails give \nfunction. ? modify logical_abbr() make \nwork? components function need recurse ?\n\nlogical_abbr(function(x = TRUE) {\n  g(x + T)\n})logical_abbr() works expressions. currently fails give \nfunction. ? modify logical_abbr() make \nwork? components function need recurse ?Modify find_assign also detect assignment using replacement\nfunctions, .e. names(x) <- y.Modify find_assign also detect assignment using replacement\nfunctions, .e. names(x) <- y.Write function extracts calls specified function.Write function extracts calls specified function.","code":"\nlogical_abbr(function(x = TRUE) {\n  g(x + T)\n})"},{"path":"expressions.html","id":"expression-special","chapter":"18 Expressions","heading":"18.6 Specialised data structures","text":"two data structures one special symbol need cover sake completeness. usually important practice.","code":""},{"path":"expressions.html","id":"pairlists","chapter":"18 Expressions","heading":"18.6.1 Pairlists","text":"Pairlists remnant R’s past replaced lists almost everywhere. place likely see pairlists R94 working calls function function, formal arguments function stored pairlist:Fortunately, whenever encounter pairlist, can treat just like regular list:Behind scenes pairlists implemented using different data structure, linked list instead array. makes subsetting pairlist much slower subsetting list, little practical impact.","code":"\nf <- expr(function(x, y = 10) x + y)\n\nargs <- f[[2]]\nargs\n#> $x\n#> \n#> \n#> $y\n#> [1] 10\ntypeof(args)\n#> [1] \"pairlist\"\npl <- pairlist(x = 1, y = 2)\nlength(pl)\n#> [1] 2\npl$x\n#> [1] 1"},{"path":"expressions.html","id":"empty-symbol","chapter":"18 Expressions","heading":"18.6.2 Missing arguments","text":"\nspecial symbol needs little extra discussion empty symbol, used represent missing arguments (missing values!). need care missing symbol ’re programmatically creating functions missing arguments; ’ll come back Section 19.4.3.can make empty symbol missing_arg() (expr()):empty symbol doesn’t print anything, can check one rlang::is_missing():’ll find wild function formals:particularly important ... always associated empty symbol:empty symbol peculiar property: bind variable, access variable, get error:won’t store inside another data structure!need preserve missingness variable, rlang::maybe_missing() often helpful. allows refer potentially missing variable without triggering error. See documentation use cases details.","code":"\nmissing_arg()\ntypeof(missing_arg())\n#> [1] \"symbol\"\nis_missing(missing_arg())\n#> [1] TRUE\nf <- expr(function(x, y = 10) x + y)\nargs <- f[[2]]\nis_missing(args[[1]])\n#> [1] TRUE\nf <- expr(function(...) list(...))\nargs <- f[[2]]\nis_missing(args[[1]])\n#> [1] TRUE\nm <- missing_arg()\nm\n#> Error in eval(expr, envir, enclos): el argumento \"m\" está ausente, sin valor por omisión\nms <- list(missing_arg(), missing_arg())\nms[[1]]"},{"path":"expressions.html","id":"expression-vectors","chapter":"18 Expressions","heading":"18.6.3 Expression vectors","text":"\nFinally, need briefly discuss expression vector. Expression vectors produced two base functions: expression() parse():Like calls pairlists, expression vectors behave like lists:Conceptually, expression vector just list expressions. difference calling eval() expression evaluates individual expression. don’t believe advantage merits introducing new data structure, instead expression vectors just use lists expressions.","code":"\nexp1 <- parse(text = c(\"\nx <- 4\nx\n\"))\nexp2 <- expression(x <- 4, x)\n\ntypeof(exp1)\n#> [1] \"expression\"\ntypeof(exp2)\n#> [1] \"expression\"\n\nexp1\n#> expression(x <- 4, x)\nexp2\n#> expression(x <- 4, x)\nlength(exp1)\n#> [1] 2\nexp1[[1]]\n#> x <- 4"},{"path":"quasiquotation.html","id":"quasiquotation","chapter":"19 Quasiquotation","heading":"19 Quasiquotation","text":"","code":""},{"path":"quasiquotation.html","id":"introduction-18","chapter":"19 Quasiquotation","heading":"19.1 Introduction","text":"Now understand tree structure R code, ’s time return one fundamental ideas make expr() ast() work: quotation. tidy evaluation, quoting functions actually quasiquoting functions also support unquoting. quotation act capturing unevaluated expression, unquotation ability selectively evaluate parts otherwise quoted expression. Together, called quasiquotation. Quasiquotation makes easy create functions combine code written function’s author code written function’s user. helps solve wide variety challenging problems.Quasiquotation one three pillars tidy evaluation. ’ll learn two (quosures data mask) Chapter 20. used alone, quasiquotation useful programming, particularly generating code. ’s combined techniques, tidy evaluation becomes powerful tool data analysis.","code":""},{"path":"quasiquotation.html","id":"outline-17","chapter":"19 Quasiquotation","heading":"Outline","text":"Section 19.2 motivates development quasiquotation\nfunction, cement(), works like paste() automatically\nquotes arguments don’t .Section 19.2 motivates development quasiquotation\nfunction, cement(), works like paste() automatically\nquotes arguments don’t .Section 19.3 gives tools quote expressions, whether\ncome user, whether use rlang base R tools.Section 19.3 gives tools quote expressions, whether\ncome user, whether use rlang base R tools.Section 19.4 introduces biggest difference rlang\nquoting functions base quoting function: unquoting !! !!!.Section 19.4 introduces biggest difference rlang\nquoting functions base quoting function: unquoting !! !!!.Section 19.5 discusses three main non-quoting\ntechniques base R functions uses disable quoting behaviour.Section 19.5 discusses three main non-quoting\ntechniques base R functions uses disable quoting behaviour.Section 19.6 explores another place can use !!!,\nfunctions take .... also introduces special := operator,\nallows dynamically change argument names.Section 19.6 explores another place can use !!!,\nfunctions take .... also introduces special := operator,\nallows dynamically change argument names.Section 19.7 shows practical uses quoting solve\nproblems naturally require code generation.Section 19.7 shows practical uses quoting solve\nproblems naturally require code generation.Section 19.8 finishes little history quasiquotation\ninterested.Section 19.8 finishes little history quasiquotation\ninterested.","code":""},{"path":"quasiquotation.html","id":"prerequisites-12","chapter":"19 Quasiquotation","heading":"Prerequisites","text":"Make sure ’ve read metaprogramming overview Chapter 17 get broad overview motivation basic vocabulary, ’re familiar tree structure expressions described Section 18.3.Code-wise, ’ll mostly using tools rlang, end chapter ’ll also see powerful applications conjunction purrr.","code":"\nlibrary(rlang)\nlibrary(purrr)"},{"path":"quasiquotation.html","id":"related-work","chapter":"19 Quasiquotation","heading":"Related work","text":"\nQuoting functions deep connections Lisp macros. macros usually run compile-time, doesn’t exist R, always input output ASTs. See Thomas Lumley95 one approach implementing R. Quoting functions closely related esoteric Lisp fexprs, functions arguments quoted default. terms useful know looking related work programming languages.","code":""},{"path":"quasiquotation.html","id":"quasi-motivation","chapter":"19 Quasiquotation","heading":"19.2 Motivation","text":"’ll start concrete example helps motivate need unquoting, hence quasiquotation. Imagine ’re creating lot strings joining together words:sick tired writing quotes, instead just want use bare words. end, ’ve written following function. (Don’t worry implementation now; ’ll learn pieces later.)Formally, function quotes inputs. can think automatically putting quotation marks around argument. ’s precisely true intermediate objects generates expressions, strings, ’s useful approximation, root meaning term “quote.”function nice longer need type quotation marks. problem comes want use variables. ’s easy use variables paste(): just don’t surround quotation marks.Obviously doesn’t work cement() every input automatically quoted:need way explicitly unquote input tell cement() remove automatic quote marks. need time name treated differently Good. Quasiquotation gives us standard tool : !!, called “unquote,” pronounced bang-bang. !! tells quoting function drop implicit quotes:’s useful compare cement() paste() directly. paste() evaluates arguments, must quote needed; cement() quotes arguments, must unquote needed.","code":"\npaste(\"Good\", \"morning\", \"Hadley\")\n#> [1] \"Good morning Hadley\"\npaste(\"Good\", \"afternoon\", \"Alice\")\n#> [1] \"Good afternoon Alice\"\ncement <- function(...) {\n  args <- ensyms(...)\n  paste(purrr::map(args, as_string), collapse = \" \")\n}\n\ncement(Good, morning, Hadley)\n#> [1] \"Good morning Hadley\"\ncement(Good, afternoon, Alice)\n#> [1] \"Good afternoon Alice\"\nname <- \"Hadley\"\ntime <- \"morning\"\n\npaste(\"Good\", time, name)\n#> [1] \"Good morning Hadley\"\ncement(Good, time, name)\n#> [1] \"Good time name\"\ncement(Good, !!time, !!name)\n#> [1] \"Good morning Hadley\"\npaste(\"Good\", time, name)\ncement(Good, !!time, !!name)"},{"path":"quasiquotation.html","id":"vocabulary","chapter":"19 Quasiquotation","heading":"19.2.1 Vocabulary","text":"\ndistinction quoted evaluated arguments important:evaluated argument obeys R’s usual evaluation rules.evaluated argument obeys R’s usual evaluation rules.quoted argument captured function, processed \ncustom way.quoted argument captured function, processed \ncustom way.paste() evaluates arguments; cement() quotes arguments.’re ever unsure whether argument quoted evaluated, try executing code outside function. doesn’t work something different, argument quoted. example, can use technique determine first argument library() quoted:Talking whether argument quoted evaluated precise way stating whether function uses non-standard evaluation (NSE). sometimes use “quoting function” short-hand function quotes one arguments, generally, ’ll talk quoted arguments since level difference applies.","code":"\n# works\nlibrary(MASS)\n\n# fails\nMASS\n#> Error in eval(expr, envir, enclos): objeto 'MASS' no encontrado"},{"path":"quasiquotation.html","id":"exercises-56","chapter":"19 Quasiquotation","heading":"19.2.2 Exercises","text":"function following base R code, identify arguments\nquoted evaluated.\n\nlibrary(MASS)\n\nmtcars2 <- subset(mtcars, cyl == 4)\n\n(mtcars2, sum(vs))\nsum(mtcars2$)\n\nrm(mtcars2)function following base R code, identify arguments\nquoted evaluated.function following tidyverse code, identify arguments\nquoted evaluated.\n\nlibrary(dplyr)\nlibrary(ggplot2)\n\nby_cyl <- mtcars %>%\n  group_by(cyl) %>%\n  summarise(mean = mean(mpg))\n\nggplot(by_cyl, aes(cyl, mean)) + geom_point()function following tidyverse code, identify arguments\nquoted evaluated.","code":"\nlibrary(MASS)\n\nmtcars2 <- subset(mtcars, cyl == 4)\n\nwith(mtcars2, sum(vs))\nsum(mtcars2$am)\n\nrm(mtcars2)\nlibrary(dplyr)\nlibrary(ggplot2)\n\nby_cyl <- mtcars %>%\n  group_by(cyl) %>%\n  summarise(mean = mean(mpg))\n\nggplot(by_cyl, aes(cyl, mean)) + geom_point()"},{"path":"quasiquotation.html","id":"quoting","chapter":"19 Quasiquotation","heading":"19.3 Quoting","text":"first part quasiquotation quotation: capturing expression without evaluating . ’ll need pair functions expression can supplied directly indirectly, via lazily-evaluated function argument. ’ll start rlang quoting functions, circle back provided base R.","code":""},{"path":"quasiquotation.html","id":"capturing-expressions","chapter":"19 Quasiquotation","heading":"19.3.1 Capturing expressions","text":"\n\nfour important quoting functions. interactive exploration, important expr(), captures argument exactly provided:(Remember white space comments part expression, captured quoting function.)expr() great interactive exploration, captures , developer, typed. ’s useful inside function:need another function solve problem: enexpr(). captures caller supplied function looking internal promise object powers lazy evaluation (Section 6.5.1).(’s called “en”-expr() analogy enrich. Enriching someone makes richer; enexpr()ing argument makes expression.)capture arguments ..., use enexprs().Finally, exprs() useful interactively make list expressions:short, use enexpr() enexprs() capture expressions supplied arguments user. Use expr() exprs() capture expressions supply.","code":"\nexpr(x + y)\n#> x + y\nexpr(1 / 2 / 3)\n#> 1/2/3\nf1 <- function(x) expr(x)\nf1(a + b + c)\n#> x\nf2 <- function(x) enexpr(x)\nf2(a + b + c)\n#> a + b + c\nf <- function(...) enexprs(...)\nf(x = 1, y = 10 * z)\n#> $x\n#> [1] 1\n#> \n#> $y\n#> 10 * z\nexprs(x = x ^ 2, y = y ^ 3, z = z ^ 4)\n# shorthand for\n# list(x = expr(x ^ 2), y = expr(y ^ 3), z = expr(z ^ 4))"},{"path":"quasiquotation.html","id":"capturing-symbols","chapter":"19 Quasiquotation","heading":"19.3.2 Capturing symbols","text":"\nSometimes want allow user specify variable name, arbitrary expression. case, can use ensym() ensyms(). variants enexpr() enexprs() check captured expression either symbol string (converted symbol96). ensym() ensyms() throw error given anything else.","code":"\nf <- function(...) ensyms(...)\nf(x)\n#> [[1]]\n#> x\nf(\"x\")\n#> [[1]]\n#> x"},{"path":"quasiquotation.html","id":"with-base-r","chapter":"19 Quasiquotation","heading":"19.3.3 With base R","text":"\nrlang function described equivalent base R. primary difference base equivalents support unquoting (’ll talk soon). make quoting functions, rather quasiquoting functions.base equivalent expr() quote():base function closest enexpr() substitute():base equivalent exprs() alist():equivalent enexprs() undocumented feature substitute()97:two important base quoting functions ’ll cover elsewhere:bquote() provides limited form quasiquotation, discussed \nSection 19.5.bquote() provides limited form quasiquotation, discussed \nSection 19.5.~, formula, quoting function also captures environment.\n’s inspiration quosures, topic next chapter, \ndiscussed Section 20.3.4.~, formula, quoting function also captures environment.\n’s inspiration quosures, topic next chapter, \ndiscussed Section 20.3.4.","code":"\nquote(x + y)\n#> x + y\nf3 <- function(x) substitute(x)\nf3(x + y)\n#> x + y\nalist(x = 1, y = x + 2)\n#> $x\n#> [1] 1\n#> \n#> $y\n#> x + 2\nf <- function(...) as.list(substitute(...()))\nf(x = 1, y = 10 * z)\n#> $x\n#> [1] 1\n#> \n#> $y\n#> 10 * z"},{"path":"quasiquotation.html","id":"substitution","chapter":"19 Quasiquotation","heading":"19.3.4 Substitution","text":"’ll often see substitute() used capture unevaluated arguments. However, well quoting, substitute() also substitution (name suggests!). give expression, rather symbol, substitute values symbols defined current environment.think makes code hard understand, taken context, can’t tell goal substitute(x + y) replace x, y, . want use substitute() substitution, recommend use second argument make goal clear:","code":"\nf4 <- function(x) substitute(x * 2)\nf4(a + b + c)\n#> (a + b + c) * 2\nsubstitute(x * y * z, list(x = 10, y = quote(a + b)))\n#> 10 * (a + b) * z"},{"path":"quasiquotation.html","id":"summary-1","chapter":"19 Quasiquotation","heading":"19.3.5 Summary","text":"quoting (.e. capturing code), two important distinctions:supplied developer code user code?\nwords, fixed (supplied body function) varying (supplied\nvia argument)?supplied developer code user code?\nwords, fixed (supplied body function) varying (supplied\nvia argument)?want capture single expression multiple expressions?want capture single expression multiple expressions?leads 2 \\(\\times\\) 2 table functions rlang, Table 19.1, base R, Table 19.2.Table 19.1:  rlang quasiquoting functionsTable 19.2:  base R quoting functions","code":""},{"path":"quasiquotation.html","id":"exercises-57","chapter":"19 Quasiquotation","heading":"19.3.6 Exercises","text":"expr() implemented? Look source code.expr() implemented? Look source code.Compare contrast following two functions. Can predict \noutput running ?\n\nf1 <- function(x, y) {\n  exprs(x = x, y = y)\n}\nf2 <- function(x, y) {\n  enexprs(x = x, y = y)\n}\nf1(+ b, c + d)\nf2(+ b, c + d)Compare contrast following two functions. Can predict \noutput running ?happens try use enexpr() expression (.e. \nenexpr(x + y) ? happens enexpr() passed missing argument?happens try use enexpr() expression (.e. \nenexpr(x + y) ? happens enexpr() passed missing argument?exprs() exprs(= ) different? Think \ninput output.exprs() exprs(= ) different? Think \ninput output.differences exprs() alist()? Read \ndocumentation named arguments exprs() find .differences exprs() alist()? Read \ndocumentation named arguments exprs() find .documentation substitute() says:\n\nSubstitution takes place examining component parse tree\nfollows:\nbound symbol env, unchanged.\npromise object (.e., formal argument function)\nexpression slot promise replaces symbol.\nordinary variable, value substituted, unless\nenv .GlobalEnv case symbol left unchanged.\n\nCreate examples illustrate cases.documentation substitute() says:Substitution takes place examining component parse tree\nfollows:bound symbol env, unchanged.promise object (.e., formal argument function)\nexpression slot promise replaces symbol.ordinary variable, value substituted, unless\nenv .GlobalEnv case symbol left unchanged.Create examples illustrate cases.","code":"\nf1 <- function(x, y) {\n  exprs(x = x, y = y)\n}\nf2 <- function(x, y) {\n  enexprs(x = x, y = y)\n}\nf1(a + b, c + d)\nf2(a + b, c + d)"},{"path":"quasiquotation.html","id":"unquoting","chapter":"19 Quasiquotation","heading":"19.4 Unquoting","text":"\n\nfar, ’ve seen relatively small advantages rlang quoting functions base R quoting functions: consistent naming scheme. big difference rlang quoting functions actually quasiquoting functions can also unquote.Unquoting allows selectively evaluate parts expression otherwise quoted, effectively allows merge ASTs using template AST. Since base functions don’t use unquoting, instead use variety techniques, ’ll learn Section 19.5.Unquoting one inverse quoting. allows selectively evaluate code inside expr(), expr(!!x) equivalent x. Chapter 20, ’ll learn another inverse, evaluation. happens outside expr(), eval(expr(x)) equivalent x.","code":""},{"path":"quasiquotation.html","id":"unquoting-one-argument","chapter":"19 Quasiquotation","heading":"19.4.1 Unquoting one argument","text":"Use !! unquote single argument function call. !! takes single expression, evaluates , inlines result AST.think easiest understand diagram. !! introduces placeholder AST, shown dotted borders. placeholder x replaced AST, illustrated dotted connection.well call objects, !! also works symbols constants:right-hand side !! function call, !! evaluate insert results:!! preserves operator precedence works expressions.simply pasted text expressions together, ’d end x + 1 / x + 2, different AST:","code":"\nx <- expr(-1)\nexpr(f(!!x, y))\n#> f(-1, y)\na <- sym(\"y\")\nb <- 1\nexpr(f(!!a, !!b))\n#> f(y, 1)\nmean_rm <- function(var) {\n  var <- ensym(var)\n  expr(mean(!!var, na.rm = TRUE))\n}\nexpr(!!mean_rm(x) + !!mean_rm(y))\n#> mean(x, na.rm = TRUE) + mean(y, na.rm = TRUE)\nx1 <- expr(x + 1)\nx2 <- expr(x + 2)\n\nexpr(!!x1 / !!x2)\n#> (x + 1)/(x + 2)"},{"path":"quasiquotation.html","id":"unquoting-a-function","chapter":"19 Quasiquotation","heading":"19.4.2 Unquoting a function","text":"!! commonly used replace arguments function, can also use replace function. challenge operator precedence: expr(!!f(x, y)) unquotes result f(x, y), need extra pair parentheses.also works f call:large number parentheses involved, can clearer use rlang::call2():","code":"\nf <- expr(foo)\nexpr((!!f)(x, y))\n#> foo(x, y)\nf <- expr(pkg::foo)\nexpr((!!f)(x, y))\n#> pkg::foo(x, y)\nf <- expr(pkg::foo)\ncall2(f, expr(x), expr(y))\n#> pkg::foo(x, y)"},{"path":"quasiquotation.html","id":"unquote-missing","chapter":"19 Quasiquotation","heading":"19.4.3 Unquoting a missing argument","text":"\noccasionally useful unquote missing argument (Section 18.6.2), naive approach doesn’t work:can work around rlang::maybe_missing() helper:","code":"\narg <- missing_arg()\nexpr(foo(!!arg, !!arg))\n#> Error in enexpr(expr): el argumento \"arg\" está ausente, sin valor por omisión\nexpr(foo(!!maybe_missing(arg), !!maybe_missing(arg)))\n#> foo(, )"},{"path":"quasiquotation.html","id":"unquoting-in-special-forms","chapter":"19 Quasiquotation","heading":"19.4.4 Unquoting in special forms","text":"\nspecial forms unquoting syntax error. Take $ example: must always followed name variable, another expression. means attempting unquote $ fail syntax error:make unquoting work, ’ll need use prefix form (Section 6.8.1):","code":"expr(df$!!x)\n#> Error: unexpected '!' in \"expr(df$!\"\nx <- expr(x)\nexpr(`$`(df, !!x))\n#> df$x"},{"path":"quasiquotation.html","id":"unquoting-many-arguments","chapter":"19 Quasiquotation","heading":"19.4.5 Unquoting many arguments","text":"\n\n!! one--one replacement. !!! (called “unquote-splice,” pronounced bang-bang-bang) one--many replacement. takes list expressions inserts location !!!:!!! can used rlang function takes ... regardless whether ... quoted evaluated. ’ll come back Section 19.6; now note can useful call2().","code":"\nxs <- exprs(1, a, -b)\nexpr(f(!!!xs, y))\n#> f(1, a, -b, y)\n\n# Or with names\nys <- set_names(xs, c(\"a\", \"b\", \"c\"))\nexpr(f(!!!ys, d = 4))\n#> f(a = 1, b = a, c = -b, d = 4)\ncall2(\"f\", !!!xs, expr(y))\n#> f(1, a, -b, y)"},{"path":"quasiquotation.html","id":"the-polite-fiction-of","chapter":"19 Quasiquotation","heading":"19.4.6 The polite fiction of !!","text":"far acted !! !!! regular prefix operators like + , -, !. ’re . R’s perspective, !! !!! simply repeated application !:!! !!! behave specially inside quoting functions powered rlang, behave like real operators precedence equivalent unary + -. requires considerable work inside rlang, means can write !!x + !!y instead (!!x) + (!!y).biggest downside98 using fake operator might get silent errors misusing !! outside quasiquoting functions. time issue !! typically used unquote expressions quosures. Since expressions supported negation operator, get argument type error case:can get silently incorrect results working numeric values:Given drawbacks, might wonder introduced new syntax instead using regular function calls. Indeed, early versions tidy evaluation used function calls like UQ() UQS(). However, ’re really function calls, pretending leads misleading mental mode. chose !! !!! least-bad solution:visually strong don’t look like existing syntax. \nsee !!x !!!x ’s clear something unusual happening.visually strong don’t look like existing syntax. \nsee !!x !!!x ’s clear something unusual happening.override rarely used piece syntax, double negation \ncommon pattern R99. need , can just\nadd parentheses !(!x).override rarely used piece syntax, double negation \ncommon pattern R99. need , can just\nadd parentheses !(!x).","code":"\n!!TRUE\n#> [1] TRUE\n!!!TRUE\n#> [1] FALSE\nx <- quote(variable)\n!!x\n#> Error in !x: argumento de tipo inválido\ndf <- data.frame(x = 1:5)\ny <- 100\nwith(df, x + !!y)\n#> [1] 2 3 4 5 6"},{"path":"quasiquotation.html","id":"non-standard-ast","chapter":"19 Quasiquotation","heading":"19.4.7 Non-standard ASTs","text":"unquoting, ’s easy create non-standard ASTs, .e. ASTs contain components expressions. (also possible create non-standard ASTs directly manipulating underlying objects, ’s harder accidentally.) valid, occasionally useful, correct use beyond scope book. However, ’s important learn , can deparsed, hence printed, misleading ways.example, inline complex objects, attributes printed. can lead confusing output:two main tools reduce confusion: rlang::expr_print() lobstr::ast():Another confusing case arises inline integer sequence:’s also possible create regular ASTs can generated code operator precedence. case, R print parentheses exist AST:","code":"\nx1 <- expr(class(!!data.frame(x = 10)))\nx1\n#> class(list(x = 10))\neval(x1)\n#> [1] \"data.frame\"\nexpr_print(x1)\n#> class(<df[,1]>)\nlobstr::ast(!!x1)\n#> o-class \n#> \\-<inline data.frame>\nx2 <- expr(f(!!c(1L, 2L, 3L, 4L, 5L)))\nx2\n#> f(1:5)\nexpr_print(x2)\n#> f(<int: 1L, 2L, 3L, 4L, 5L>)\nlobstr::ast(!!x2)\n#> o-f \n#> \\-<inline integer>\nx3 <- expr(1 + !!expr(2 + 3))\nx3\n#> 1 + (2 + 3)\n\nlobstr::ast(!!x3)\n#> o-`+` \n#> +-1 \n#> \\-o-`+` \n#>   +-2 \n#>   \\-3"},{"path":"quasiquotation.html","id":"exercises-58","chapter":"19 Quasiquotation","heading":"19.4.8 Exercises","text":"Given following components:\n\nxy <- expr(x + y)\nxz <- expr(x + z)\nyz <- expr(y + z)\nabc <- exprs(, b, c)\nUse quasiquotation construct following calls:\n\n(x + y) / (y + z)\n-(x + z) ^ (y + z)\n(x + y) + (y + z) - (x + y)\natan2(x + y, y + z)\nsum(x + y, x + y, y + z)\nsum(, b, c)\nmean(c(, b, c), na.rm = TRUE)\nfoo(= x + y, b = y + z)Given following components:Use quasiquotation construct following calls:following two calls print , actually different:\n\n(<- expr(mean(1:10)))\n#> mean(1:10)\n(b <- expr(mean(!!(1:10))))\n#> mean(1:10)\nidentical(, b)\n#> [1] FALSE\n’s difference? one natural?following two calls print , actually different:’s difference? one natural?","code":"\nxy <- expr(x + y)\nxz <- expr(x + z)\nyz <- expr(y + z)\nabc <- exprs(a, b, c)\n(x + y) / (y + z)\n-(x + z) ^ (y + z)\n(x + y) + (y + z) - (x + y)\natan2(x + y, y + z)\nsum(x + y, x + y, y + z)\nsum(a, b, c)\nmean(c(a, b, c), na.rm = TRUE)\nfoo(a = x + y, b = y + z)\n(a <- expr(mean(1:10)))\n#> mean(1:10)\n(b <- expr(mean(!!(1:10))))\n#> mean(1:10)\nidentical(a, b)\n#> [1] FALSE"},{"path":"quasiquotation.html","id":"base-nonquote","chapter":"19 Quasiquotation","heading":"19.5 Non-quoting","text":"Base R one function implements quasiquotation: bquote(). uses .() unquoting:bquote() isn’t used function base R, relatively little impact R code written. three challenges effective use bquote():easily used code; hard apply arbitrary\ncode supplied user.easily used code; hard apply arbitrary\ncode supplied user.provide unquote-splice operator allows unquote\nmultiple expressions stored list.provide unquote-splice operator allows unquote\nmultiple expressions stored list.lacks ability handle code accompanied environment, \ncrucial functions evaluate code context data frame,\nlike subset() friends.lacks ability handle code accompanied environment, \ncrucial functions evaluate code context data frame,\nlike subset() friends.Base functions quote argument use technique allow indirect specification. Base R approaches selectively turn quoting , rather using unquoting, call non-quoting techniques.four basic forms seen base R:pair quoting non-quoting functions. example, $ two\narguments, second argument quoted. easier see \nwrite prefix form: mtcars$cyl equivalent `$`(mtcars, cyl).\nwant refer variable indirectly, use [[, \ntakes name variable string.\n\nx <- list(var = 1, y = 2)\nvar <- \"y\"\n\nx$var\n#> [1] 1\nx[[var]]\n#> [1] 2\nthree quoting functions closely related $: subset(),\ntransform(), (). seen wrappers around $ \nsuitable interactive use non-quoting\nalternative: [\n<-/assign() ::/getExportedValue() work similarly $/[.\n\npair quoting non-quoting functions. example, $ two\narguments, second argument quoted. easier see \nwrite prefix form: mtcars$cyl equivalent `$`(mtcars, cyl).\nwant refer variable indirectly, use [[, \ntakes name variable string.three quoting functions closely related $: subset(),\ntransform(), (). seen wrappers around $ \nsuitable interactive use non-quoting\nalternative: [<-/assign() ::/getExportedValue() work similarly $/[.\n\npair quoting non-quoting arguments. example, rm() allows\nprovide bare variable names ..., character vector \nvariable names list:\n\nx <- 1\nrm(x)\n\ny <- 2\nvars <- c(\"y\", \"vars\")\nrm(list = vars)\ndata() save() work similarly.\npair quoting non-quoting arguments. example, rm() allows\nprovide bare variable names ..., character vector \nvariable names list:data() save() work similarly.\nargument controls whether different argument quoting \nnon-quoting. example, library(), character.argument\ncontrols quoting behaviour first argument, package:\n\nlibrary(MASS)\n\npkg <- \"MASS\"\nlibrary(pkg, character.= TRUE)\ndemo(), detach(), example(), require() work similarly.\nargument controls whether different argument quoting \nnon-quoting. example, library(), character.argument\ncontrols quoting behaviour first argument, package:demo(), detach(), example(), require() work similarly.\nQuoting evaluation fails. example, first argument help()\nnon-quoting evaluates string; evaluation fails, \nfirst argument quoted.\n\n# Shows help var\nhelp(var)\n\nvar <- \"mean\"\n# Shows help mean\nhelp(var)\n\nvar <- 10\n# Shows help var\nhelp(var)\nls(), page(), match.fun() work similarly.\nQuoting evaluation fails. example, first argument help()\nnon-quoting evaluates string; evaluation fails, \nfirst argument quoted.ls(), page(), match.fun() work similarly.\nAnother important class quoting functions base modelling plotting functions, follow -called standard non-standard evaluation rules: http://developer.r-project.org/nonstandard-eval.pdf. example, lm() quotes weight subset arguments, used formula argument, plotting function quotes aesthetic arguments (col, cex, etc). Take following code: need col = Species rather col = iris$Species.functions built-options indirect specification, ’ll learn simulate unquoting Section 20.6.","code":"\nxyz <- bquote((x + y + z))\nbquote(-.(xyz) / 2)\n#> -(x + y + z)/2\nx <- list(var = 1, y = 2)\nvar <- \"y\"\n\nx$var\n#> [1] 1\nx[[var]]\n#> [1] 2\nx <- 1\nrm(x)\n\ny <- 2\nvars <- c(\"y\", \"vars\")\nrm(list = vars)\nlibrary(MASS)\n\npkg <- \"MASS\"\nlibrary(pkg, character.only = TRUE)\n# Shows help for var\nhelp(var)\n\nvar <- \"mean\"\n# Shows help for mean\nhelp(var)\n\nvar <- 10\n# Shows help for var\nhelp(var)\npalette(RColorBrewer::brewer.pal(3, \"Set1\"))\nplot(\n  Sepal.Length ~ Petal.Length, \n  data = iris, \n  col = Species, \n  pch = 20, \n  cex = 2\n)"},{"path":"quasiquotation.html","id":"tidy-dots","chapter":"19 Quasiquotation","heading":"19.6 ... (dot-dot-dot)","text":"!!! useful ’s uncommon list expressions want insert call. turns pattern common elsewhere. Take following two motivating problems:elements want put ... already stored\nlist? example, imagine list data frames \nwant rbind() together:\n\ndfs <- list(\n  = data.frame(x = 1, y = 2),\n  b = data.frame(x = 3, y = 4)\n)\nsolve specific case rbind(dfs$, dfs$b), \ngeneralise solution list arbitrary length?elements want put ... already stored\nlist? example, imagine list data frames \nwant rbind() together:solve specific case rbind(dfs$, dfs$b), \ngeneralise solution list arbitrary length?want supply argument name indirectly? \nexample, imagine want create single column data frame \nname column specified variable:\n\nvar <- \"x\"\nval <- c(4, 3, 9)\ncase, create data frame change names\n(.e. setNames(data.frame(val), var)), feels inelegant.\ncan better?want supply argument name indirectly? \nexample, imagine want create single column data frame \nname column specified variable:case, create data frame change names\n(.e. setNames(data.frame(val), var)), feels inelegant.\ncan better?One way think problems draw explicit parallels quasiquotation:Row-binding multiple data frames like unquote-splicing: want inline\nindividual elements list call:\n\ndplyr::bind_rows(!!!dfs)\n#>   x y\n#> 1 1 2\n#> 2 3 4\nused context, behaviour !!! known “spatting” \nRuby, Go, PHP, Julia. closely related *args (star-args) \n**kwarg (star-star-kwargs) Python, sometimes called argument\nunpacking.\nRow-binding multiple data frames like unquote-splicing: want inline\nindividual elements list call:used context, behaviour !!! known “spatting” \nRuby, Go, PHP, Julia. closely related *args (star-args) \n**kwarg (star-star-kwargs) Python, sometimes called argument\nunpacking.\nsecond problem like unquoting left-hand side =: rather\ninterpreting var literally, want use value stored \nvariable called var:\n\ntibble::tibble(!!var := val)\n#> # tibble: 3 x 1\n#>       x\n#>   <dbl>\n#> 1     4\n#> 2     3\n#> 3     9\nNote use := (pronounced colon-equals) rather =. Unfortunately\nneed new operation R’s grammar allow expressions \nargument names:\ntibble::tibble(!!var = value)\n#> Error: unexpected '=' \"tibble::tibble(!!var =\"\n:= like vestigial organ: ’s recognised R’s parser, \ndoesn’t code associated . looks like = allows\nexpressions either side, making flexible alternative =.\nused data.table similar reasons.\nsecond problem like unquoting left-hand side =: rather\ninterpreting var literally, want use value stored \nvariable called var:Note use := (pronounced colon-equals) rather =. Unfortunately\nneed new operation R’s grammar allow expressions \nargument names::= like vestigial organ: ’s recognised R’s parser, \ndoesn’t code associated . looks like = allows\nexpressions either side, making flexible alternative =.\nused data.table similar reasons.\nBase R takes different approach, ’ll come back Section 19.6.4.say functions support tools, without quoting arguments, tidy dots100. gain tidy dots behaviour function, need use list2().","code":"\ndfs <- list(\n  a = data.frame(x = 1, y = 2),\n  b = data.frame(x = 3, y = 4)\n)\nvar <- \"x\"\nval <- c(4, 3, 9)\ndplyr::bind_rows(!!!dfs)\n#>   x y\n#> 1 1 2\n#> 2 3 4\ntibble::tibble(!!var := val)\n#> # A tibble: 3 x 1\n#>       x\n#>   <dbl>\n#> 1     4\n#> 2     3\n#> 3     9tibble::tibble(!!var = value)\n#> Error: unexpected '=' in \"tibble::tibble(!!var =\""},{"path":"quasiquotation.html","id":"examples","chapter":"19 Quasiquotation","heading":"19.6.1 Examples","text":"One place use list2() create wrapper around attributes() allows us set attributes flexibly:","code":"\nset_attr <- function(.x, ...) {\n  attr <- rlang::list2(...)\n  attributes(.x) <- attr\n  .x\n}\n\nattrs <- list(x = 1, y = 2)\nattr_name <- \"z\"\n\n1:10 %>%\n  set_attr(w = 0, !!!attrs, !!attr_name := 3) %>% \n  str()\n#>  int [1:10] 1 2 3 4 5 6 7 8 9 10\n#>  - attr(*, \"w\")= num 0\n#>  - attr(*, \"x\")= num 1\n#>  - attr(*, \"y\")= num 2\n#>  - attr(*, \"z\")= num 3"},{"path":"quasiquotation.html","id":"exec","chapter":"19 Quasiquotation","heading":"19.6.2 exec()","text":"want use technique function doesn’t tidy dots? One option use rlang::exec() call function arguments supplied directly (...) others indirectly (list):rlang::exec() also makes possible supply argument names indirectly:finally, ’s useful vector function names list functions want call arguments:exec() closely related call2(); call2() returns expression, exec() evaluates .","code":"\n# Directly\nexec(\"mean\", x = 1:10, na.rm = TRUE, trim = 0.1)\n#> [1] 5.5\n\n# Indirectly\nargs <- list(x = 1:10, na.rm = TRUE, trim = 0.1)\nexec(\"mean\", !!!args)\n#> [1] 5.5\n\n# Mixed\nparams <- list(na.rm = TRUE, trim = 0.1)\nexec(\"mean\", x = 1:10, !!!params)\n#> [1] 5.5\narg_name <- \"na.rm\"\narg_val <- TRUE\nexec(\"mean\", 1:10, !!arg_name := arg_val)\n#> [1] 5.5\nx <- c(runif(10), NA)\nfuns <- c(\"mean\", \"median\", \"sd\")\n\npurrr::map_dbl(funs, exec, x, na.rm = TRUE)\n#> [1] 0.444 0.482 0.298"},{"path":"quasiquotation.html","id":"dots_list","chapter":"19 Quasiquotation","heading":"19.6.3 dots_list()","text":"list2() provides one handy feature: default ignore empty arguments end. useful functions like tibble::tibble() means can easily change order variables without worrying final comma:list2() wrapper around rlang::dots_list() defaults set commonly used settings. can get control calling dots_list() directly:.ignore_empty allows control exactly arguments ignored.\ndefault ignores single trailing argument get behaviour\ndescribed , can choose ignore missing arguments, \nmissing arguments..ignore_empty allows control exactly arguments ignored.\ndefault ignores single trailing argument get behaviour\ndescribed , can choose ignore missing arguments, \nmissing arguments..homonyms controls happens multiple arguments use name:\n\nstr(dots_list(x = 1, x = 2))\n#> List 2\n#>  $ x: num 1\n#>  $ x: num 2\nstr(dots_list(x = 1, x = 2, .homonyms = \"first\"))\n#> List 1\n#>  $ x: num 1\nstr(dots_list(x = 1, x = 2, .homonyms = \"last\"))\n#> List 1\n#>  $ x: num 2\nstr(dots_list(x = 1, x = 2, .homonyms = \"error\"))\n#> Error: Arguments name.\n#> found multiple arguments named `x` positions 1 2.homonyms controls happens multiple arguments use name:empty arguments ignored, .preserve_empty\ncontrols . default throws error; setting\n.preserve_empty = TRUE instead returns missing symbols. useful\n’re using dots_list() generate function calls.empty arguments ignored, .preserve_empty\ncontrols . default throws error; setting\n.preserve_empty = TRUE instead returns missing symbols. useful\n’re using dots_list() generate function calls.","code":"\n# Can easily move x to first entry:\ntibble::tibble(\n  y = 1:5,\n  z = 3:-1,\n  x = 5:1,\n)\n\n# Need to remove comma from z and add comma to x\ndata.frame(\n  y = 1:5,\n  z = 3:-1,\n  x = 5:1\n)\nstr(dots_list(x = 1, x = 2))\n#> List of 2\n#>  $ x: num 1\n#>  $ x: num 2\nstr(dots_list(x = 1, x = 2, .homonyms = \"first\"))\n#> List of 1\n#>  $ x: num 1\nstr(dots_list(x = 1, x = 2, .homonyms = \"last\"))\n#> List of 1\n#>  $ x: num 2\nstr(dots_list(x = 1, x = 2, .homonyms = \"error\"))\n#> Error: Arguments can't have the same name.\n#> We found multiple arguments named `x` at positions 1 and 2"},{"path":"quasiquotation.html","id":"do-call","chapter":"19 Quasiquotation","heading":"19.6.4 With base R","text":"\nBase R provides Swiss army knife solve problems: .call(). .call() two main arguments. first argument, , gives function call. second argument, args, list arguments pass function, .call(\"f\", list(x, y, z)) equivalent f(x, y, z)..call() gives straightforward solution rbind()ing together many\ndata frames:\n\n.call(\"rbind\", dfs)\n#>   x y\n#> 1 2\n#> b 3 4do.call() gives straightforward solution rbind()ing together many\ndata frames:little work, can use .call() solve second problem.\nfirst create list arguments, name , use .call():\n\nargs <- list(val)\nnames(args) <- var\n\n.call(\"data.frame\", args)\n#>   x\n#> 1 4\n#> 2 3\n#> 3 9With little work, can use .call() solve second problem.\nfirst create list arguments, name , use .call():base functions (including interaction(), expand.grid(), options(), par()) use trick avoid .call(): first component ... list, ’ll take components instead looking elements .... implementation looks something like :Another approach avoiding .call() found RCurl::getURL() function written Duncan Temple Lang. getURL() takes ... .dots concatenated together looks something like :time discovered , found technique particularly compelling can see used throughout tidyverse. Now, however, prefer approach described previously.","code":"\ndo.call(\"rbind\", dfs)\n#>   x y\n#> a 1 2\n#> b 3 4\nargs <- list(val)\nnames(args) <- var\n\ndo.call(\"data.frame\", args)\n#>   x\n#> 1 4\n#> 2 3\n#> 3 9\nf <- function(...) {\n  dots <- list(...)\n  if (length(dots) == 1 && is.list(dots[[1]])) {\n    dots <- dots[[1]]\n  }\n  \n  # Do something\n  ...\n}\nf <- function(..., .dots) {\n  dots <- c(list(...), .dots)\n  # Do something\n}"},{"path":"quasiquotation.html","id":"exercises-59","chapter":"19 Quasiquotation","heading":"19.6.5 Exercises","text":"One way implement exec() shown . Describe works. \nkey ideas?\n\nexec <- function(f, ..., .env = caller_env()) {\n  args <- list2(...)\n  .call(f, args, envir = .env)\n}One way implement exec() shown . Describe works. \nkey ideas?Carefully read source code interaction(), expand.grid(), \npar(). Compare contrast techniques use switching\ndots list behaviour.Carefully read source code interaction(), expand.grid(), \npar(). Compare contrast techniques use switching\ndots list behaviour.Explain problem definition set_attr()\n\nset_attr <- function(x, ...) {\n  attr <- rlang::list2(...)\n  attributes(x) <- attr\n  x\n}\nset_attr(1:10, x = 10)\n#> Error attributes(x) <- attr: los atributos deben tener nombreExplain problem definition set_attr()","code":"\nexec <- function(f, ..., .env = caller_env()) {\n  args <- list2(...)\n  do.call(f, args, envir = .env)\n}\nset_attr <- function(x, ...) {\n  attr <- rlang::list2(...)\n  attributes(x) <- attr\n  x\n}\nset_attr(1:10, x = 10)\n#> Error in attributes(x) <- attr: los atributos deben tener nombre"},{"path":"quasiquotation.html","id":"expr-case-studies","chapter":"19 Quasiquotation","heading":"19.7 Case studies","text":"make ideas quasiquotation concrete, section contains small case studies use solve real problems. case studies also use purrr: find combination quasiquotation functional programming particularly elegant.","code":""},{"path":"quasiquotation.html","id":"lobstrast","chapter":"19 Quasiquotation","heading":"19.7.1 lobstr::ast()","text":"Quasiquotation allows us solve annoying problem lobstr::ast(): happens ’ve already captured expression?ast() quotes first argument, can use !!:","code":"\nz <- expr(foo(x, y))\nlobstr::ast(z)\n#> z\nlobstr::ast(!!z)\n#> o-foo \n#> +-x \n#> \\-y"},{"path":"quasiquotation.html","id":"map-reduce-to-generate-code","chapter":"19 Quasiquotation","heading":"19.7.2 Map-reduce to generate code","text":"Quasiquotation gives us powerful tools generating code, particularly combined purrr::map() purr::reduce(). example, assume linear model specified following coefficients:want convert expression like 10 + (x1 * 5) + (x2 * -4). first thing need turn character names vector list symbols. rlang::syms() designed precisely case:Next need combine variable name coefficient. can combining rlang::expr() purrr::map2():case, intercept also part sum, although doesn’t involve multiplication. can just add start summands vector:Finally, need reduce (Section 9.5) individual terms single sum adding pieces together:make even general allowing user supply name coefficient, instead assuming many different variables, index single one.finish wrapping function:Note use ensym(): want user supply name single variable, complex expression.","code":"\nintercept <- 10\ncoefs <- c(x1 = 5, x2 = -4)\ncoef_sym <- syms(names(coefs))\ncoef_sym\n#> [[1]]\n#> x1\n#> \n#> [[2]]\n#> x2\nsummands <- map2(coef_sym, coefs, ~ expr((!!.x * !!.y)))\nsummands\n#> [[1]]\n#> (x1 * 5)\n#> \n#> [[2]]\n#> (x2 * -4)\nsummands <- c(intercept, summands)\nsummands\n#> [[1]]\n#> [1] 10\n#> \n#> [[2]]\n#> (x1 * 5)\n#> \n#> [[3]]\n#> (x2 * -4)\neq <- reduce(summands, ~ expr(!!.x + !!.y))\neq\n#> 10 + (x1 * 5) + (x2 * -4)\nvar <- expr(y)\ncoef_sym <- map(seq_along(coefs), ~ expr((!!var)[[!!.x]]))\ncoef_sym\n#> [[1]]\n#> y[[1L]]\n#> \n#> [[2]]\n#> y[[2L]]\nlinear <- function(var, val) {\n  var <- ensym(var)\n  coef_name <- map(seq_along(val[-1]), ~ expr((!!var)[[!!.x]]))\n\n  summands <- map2(val[-1], coef_name, ~ expr((!!.x * !!.y)))\n  summands <- c(val[[1]], summands)\n\n  reduce(summands, ~ expr(!!.x + !!.y))\n}\n\nlinear(x, c(10, 5, -4))\n#> 10 + (5 * x[[1L]]) + (-4 * x[[2L]])"},{"path":"quasiquotation.html","id":"slicing-an-array","chapter":"19 Quasiquotation","heading":"19.7.3 Slicing an array","text":"occasionally useful tool missing base R ability extract slice array given dimension index. example, ’d like write slice(x, 2, 1) extract first slice along second dimension, .e. x[, 1, ]. moderately challenging problem requires working missing arguments.’ll need generate call multiple missing arguments. first generate list missing arguments rep() missing_arg(), unquote-splice call:use subset-assignment insert index desired position:wrap function, using couple stopifnot()s make interface clear:real slice() evaluate generated call (Chapter 20), think ’s illuminating see code ’s generated, ’s hard part challenge.","code":"\nindices <- rep(list(missing_arg()), 3)\nexpr(x[!!!indices])\n#> x[, , ]\nindices[[2]] <- 1\nexpr(x[!!!indices])\n#> x[, 1, ]\nslice <- function(x, along, index) {\n  stopifnot(length(along) == 1)\n  stopifnot(length(index) == 1)\n    \n  nd <- length(dim(x))\n  indices <- rep(list(missing_arg()), nd)\n  indices[[along]] <- index\n  \n  expr(x[!!!indices])\n}\n\nx <- array(sample(30), c(5, 2, 3))\nslice(x, 1, 3)\n#> x[3, , ]\nslice(x, 2, 2)\n#> x[, 2, ]\nslice(x, 3, 1)\n#> x[, , 1]"},{"path":"quasiquotation.html","id":"new-function","chapter":"19 Quasiquotation","heading":"19.7.4 Creating functions","text":"\nAnother powerful application quotation creating functions “hand,” using rlang::new_function(). ’s function creates function three components (Section 6.2.1): arguments, body, (optionally) environment:NB: empty arguments exprs() generates arguments defaults.One use new_function() alternative function factories scalar symbol arguments. example, write function generates functions raise function power number.Another application new_function() functions work like graphics::curve(), allows plot mathematical expression without creating function:code, x pronoun: doesn’t represent single concrete value, instead placeholder varies range plot. One way implement curve() turn expression function single argument, x, call function:Functions like curve() use expression containing pronoun known anaphoric functions101.","code":"\nnew_function(\n  exprs(x = , y = ), \n  expr({x + y})\n)\n#> function (x, y) \n#> {\n#>     x + y\n#> }\npower <- function(exponent) {\n  new_function(\n    exprs(x = ), \n    expr({\n      x ^ !!exponent\n    }), \n    caller_env()\n  )\n}\npower(0.5)\n#> function (x) \n#> {\n#>     x^0.5\n#> }\ncurve(sin(exp(4 * x)), n = 1000)\ncurve2 <- function(expr, xlim = c(0, 1), n = 100) {\n  expr <- enexpr(expr)\n  f <- new_function(exprs(x = ), expr)\n  \n  x <- seq(xlim[1], xlim[2], length = n)\n  y <- f(x)\n\n  plot(x, y, type = \"l\", ylab = expr_text(expr))\n}\ncurve2(sin(exp(4 * x)), n = 1000)"},{"path":"quasiquotation.html","id":"exercises-60","chapter":"19 Quasiquotation","heading":"19.7.5 Exercises","text":"linear-model example, replace expr() \nreduce(summands, ~ expr(!!.x + !!.y)) call2():\nreduce(summands, call2, \"+\"). Compare contrast two\napproaches. think easier read?linear-model example, replace expr() \nreduce(summands, ~ expr(!!.x + !!.y)) call2():\nreduce(summands, call2, \"+\"). Compare contrast two\napproaches. think easier read?Re-implement Box-Cox transform defined using unquoting \nnew_function():\n\nbc <- function(lambda) {\n  (lambda == 0) {\n    function(x) log(x)\n  } else {\n    function(x) (x ^ lambda - 1) / lambda\n  }\n}Re-implement Box-Cox transform defined using unquoting \nnew_function():Re-implement simple compose() defined using quasiquotation \nnew_function():\n\ncompose <- function(f, g) {\n  function(...) f(g(...))\n}Re-implement simple compose() defined using quasiquotation \nnew_function():","code":"\nbc <- function(lambda) {\n  if (lambda == 0) {\n    function(x) log(x)\n  } else {\n    function(x) (x ^ lambda - 1) / lambda\n  }\n}\ncompose <- function(f, g) {\n  function(...) f(g(...))\n}"},{"path":"quasiquotation.html","id":"history","chapter":"19 Quasiquotation","heading":"19.8 History","text":"idea quasiquotation old one. first developed philosopher Willard van Orman Quine102 early 1940s. ’s needed philosophy helps precisely delineating use mention words, .e. distinguishing object words use refer object.Quasiquotation first used programming language, Lisp, mid-1970s.103 Lisp one quoting function `, uses , unquoting. languages Lisp heritage behave similarly. example, Racket (` @), Clojure (` ~), Julia (: @) quasiquotation tools differ slightly Lisp. languages single quoting function must call explicitly.R, however, many functions quote one inputs. introduces ambiguity (need read documentation determine argument quoted ), allows concise elegant data exploration code. base R, one function supports quasiquotation: bquote(), written 2003 Thomas Lumley. However, bquote() major limitations prevented wide impact R code (Section 19.5).attempt resolve limitations led lazyeval package (2014-2015). Unfortunately, analysis problem incomplete lazyeval solved problems, created others. started working Lionel Henry problem pieces finally fell place created full tidy evaluation framework (2017). Despite newness tidy evaluation, teach rich powerful theory , mastered, makes many hard problems much easier.","code":""},{"path":"evaluation.html","id":"evaluation","chapter":"20 Evaluation","heading":"20 Evaluation","text":"","code":""},{"path":"evaluation.html","id":"introduction-19","chapter":"20 Evaluation","heading":"20.1 Introduction","text":"user-facing inverse quotation unquotation: gives user ability selectively evaluate parts otherwise quoted argument. developer-facing complement quotation evaluation: gives developer ability evaluate quoted expressions custom environments achieve specific goals.chapter begins discussion evaluation purest form. ’ll learn eval() evaluates expression environment, can used implement number important base R functions. basics belt, ’ll learn extensions evaluation needed robustness. two big new ideas:quosure: data structure captures expression along \nassociated environment, found function arguments.quosure: data structure captures expression along \nassociated environment, found function arguments.data mask, makes easier evaluate expression \ncontext data frame. introduces potential evaluation ambiguity\n’ll resolve data pronouns.data mask, makes easier evaluate expression \ncontext data frame. introduces potential evaluation ambiguity\n’ll resolve data pronouns.Together, quasiquotation, quosures, data masks form call tidy evaluation, tidy eval short. Tidy eval provides principled approach non-standard evaluation makes possible use functions interactively embedded functions. Tidy evaluation important practical implication theory ’ll spend little time exploring implications. chapter finishes discussion closest related approaches base R, can program around drawbacks.","code":""},{"path":"evaluation.html","id":"outline-18","chapter":"20 Evaluation","heading":"Outline","text":"Section 20.2 discusses basics evaluation using eval(),\nshows can use implement key functions like local()\nsource().Section 20.2 discusses basics evaluation using eval(),\nshows can use implement key functions like local()\nsource().Section 20.3 introduces new data structure, quosure, \ncombines expression environment. ’ll learn capture\nquosures promises, evaluate using rlang::eval_tidy().Section 20.3 introduces new data structure, quosure, \ncombines expression environment. ’ll learn capture\nquosures promises, evaluate using rlang::eval_tidy().Section 20.4 extends evaluation data mask, \nmakes trivial intermingle symbols bound environment \nvariables found data frame.Section 20.4 extends evaluation data mask, \nmakes trivial intermingle symbols bound environment \nvariables found data frame.Section 20.5 shows use tidy evaluation practice,\nfocussing common pattern quoting unquoting, \nhandle ambiguity pronouns.Section 20.5 shows use tidy evaluation practice,\nfocussing common pattern quoting unquoting, \nhandle ambiguity pronouns.Section 20.6 circles back evaluation base R,\ndiscusses downsides, shows use quasiquotation \nevaluation wrap functions use NSE.Section 20.6 circles back evaluation base R,\ndiscusses downsides, shows use quasiquotation \nevaluation wrap functions use NSE.","code":""},{"path":"evaluation.html","id":"prerequisites-13","chapter":"20 Evaluation","heading":"Prerequisites","text":"’ll need familiar content Chapter 18 Chapter 19, well environment data structure (Section 7.2) caller environment (Section 7.5).’ll continue use rlang purrr.","code":"\nlibrary(rlang)\nlibrary(purrr)"},{"path":"evaluation.html","id":"eval","chapter":"20 Evaluation","heading":"20.2 Evaluation basics","text":"\n’ll explore details eval() briefly mentioned last chapter. two key arguments: expr envir. first argument, expr, object evaluate, typically symbol expression104. None evaluation functions quote inputs, ’ll usually use expr() similar:second argument, env, gives environment expression evaluated, .e. look values x, y, +. default, current environment, .e. calling environment eval(), can override want:first argument evaluated, quoted, can lead confusing results use custom environment forget manually quote:Now ’ve seen basics, let’s explore applications. ’ll focus primarily base R functions might used , reimplementing underlying principles using rlang.","code":"\nx <- 10\neval(expr(x))\n#> [1] 10\n\ny <- 2\neval(expr(x + y))\n#> [1] 12\neval(expr(x + y), env(x = 1000))\n#> [1] 1002\neval(print(x + 1), env(x = 1000))\n#> [1] 11\n#> [1] 11\n\neval(expr(print(x + 1)), env(x = 1000))\n#> [1] 1001"},{"path":"evaluation.html","id":"application-local","chapter":"20 Evaluation","heading":"20.2.1 Application: local()","text":"Sometimes want perform chunk calculation creates intermediate variables. intermediate variables long-term use quite large, ’d rather keep around. One approach clean using rm(); another wrap code function just call . elegant approach use local():essence local() quite simple re-implemented . capture input expression, create new environment evaluate . new environment (assignment doesn’t affect existing environment) caller environment parent (expr can still access variables environment). effectively emulates running expr inside function (.e. ’s lexically scoped, Section 6.4).Understanding base::local() works harder, uses eval() substitute() together rather complicated ways. Figuring exactly ’s going good practice really want understand subtleties substitute() base eval() functions, included exercises .","code":"\n# Clean up variables created earlier\nrm(x, y)\n\nfoo <- local({\n  x <- 10\n  y <- 200\n  x + y\n})\n\nfoo\n#> [1] 210\nx\n#> Error in eval(expr, envir, enclos): objeto 'x' no encontrado\ny\n#> Error in eval(expr, envir, enclos): objeto 'y' no encontrado\nlocal2 <- function(expr) {\n  env <- env(caller_env())\n  eval(enexpr(expr), env)\n}\n\nfoo <- local2({\n  x <- 10\n  y <- 200\n  x + y\n})\n\nfoo\n#> [1] 210\nx\n#> Error in eval(expr, envir, enclos): objeto 'x' no encontrado\ny\n#> Error in eval(expr, envir, enclos): objeto 'y' no encontrado"},{"path":"evaluation.html","id":"application-source","chapter":"20 Evaluation","heading":"20.2.2 Application: source()","text":"can create simple version source() combining eval() parse_expr() Section 18.4.3. read file disk, use parse_expr() parse string list expressions, use eval() evaluate element turn. version evaluates code caller environment, invisibly returns result last expression file just like base::source().real source() considerably complicated can echo input output, many settings control behaviour.Expression vectors\nbase::eval() special behaviour expression vectors, evaluating component turn. makes compact implementation source2() base::parse() also returns expression object:source3() considerably concise source2(), advantage expression vectors. Overall don’t believe benefit outweighs cost introducing new data structure, hence book avoids use expression vectors.","code":"\nsource2 <- function(path, env = caller_env()) {\n  file <- paste(readLines(path, warn = FALSE), collapse = \"\\n\")\n  exprs <- parse_exprs(file)\n\n  res <- NULL\n  for (i in seq_along(exprs)) {\n    res <- eval(exprs[[i]], env)\n  }\n\n  invisible(res)\n}\nsource3 <- function(file, env = parent.frame()) {\n  lines <- parse(file)\n  res <- eval(lines, envir = env)\n  invisible(res)\n}"},{"path":"evaluation.html","id":"gotcha-function","chapter":"20 Evaluation","heading":"20.2.3 Gotcha: function()","text":"\n’s one small gotcha aware ’re using eval() expr() generate functions:function doesn’t look like work, :, available, functions print srcref attribute (Section 6.2.1), srcref base R feature ’s unaware quasiquotation.work around problem, either use new_function() (Section 19.7.4) remove srcref attribute:","code":"\nx <- 10\ny <- 20\nf <- eval(expr(function(x, y) !!x + !!y))\nf\n#> function(x, y) !!x + !!y\nf()\n#> [1] 30\nattr(f, \"srcref\") <- NULL\nf\n#> function (x, y) \n#> 10 + 20"},{"path":"evaluation.html","id":"exercises-61","chapter":"20 Evaluation","heading":"20.2.4 Exercises","text":"Carefully read documentation source(). environment \nuse default? supply local = TRUE? provide\ncustom environment?Carefully read documentation source(). environment \nuse default? supply local = TRUE? provide\ncustom environment?Predict results following lines code:\n\neval(expr(eval(expr(eval(expr(2 + 2))))))\neval(eval(expr(eval(expr(eval(expr(2 + 2)))))))\nexpr(eval(expr(eval(expr(eval(expr(2 + 2)))))))Predict results following lines code:Fill function bodies re-implement get() using sym()\neval(), andassign() using sym(), expr(), eval(). Don’t\nworry multiple ways choosing environment get() \nassign() support; assume user supplies explicitly.\n\n# name string\nget2 <- function(name, env) {}\nassign2 <- function(name, value, env) {}Fill function bodies re-implement get() using sym()\neval(), andassign() using sym(), expr(), eval(). Don’t\nworry multiple ways choosing environment get() \nassign() support; assume user supplies explicitly.Modify source2() returns result every expression,\njust last one. Can eliminate loop?Modify source2() returns result every expression,\njust last one. Can eliminate loop?can make base::local() slightly easier understand spreading\nmultiple lines:\n\nlocal3 <- function(expr, envir = new.env()) {\n  call <- substitute(eval(quote(expr), envir))\n  eval(call, envir = parent.frame())\n}\nExplain local() works words. (Hint: might want print(call)\nhelp understand substitute() , read documentation\nremind environment new.env() inherit .)can make base::local() slightly easier understand spreading\nmultiple lines:Explain local() works words. (Hint: might want print(call)\nhelp understand substitute() , read documentation\nremind environment new.env() inherit .)","code":"\neval(expr(eval(expr(eval(expr(2 + 2))))))\neval(eval(expr(eval(expr(eval(expr(2 + 2)))))))\nexpr(eval(expr(eval(expr(eval(expr(2 + 2)))))))\n# name is a string\nget2 <- function(name, env) {}\nassign2 <- function(name, value, env) {}\nlocal3 <- function(expr, envir = new.env()) {\n  call <- substitute(eval(quote(expr), envir))\n  eval(call, envir = parent.frame())\n}"},{"path":"evaluation.html","id":"quosures","chapter":"20 Evaluation","heading":"20.3 Quosures","text":"Almost every use eval() involves expression environment. coupling important need data structure can hold pieces. Base R structure105 rlang fills gap quosure, object contains expression environment. name portmanteau quoting closure, quosure quotes expression encloses environment. Quosures reify internal promise object (Section 6.5.1) something can program .section, ’ll learn create manipulate quosures, little implemented.","code":""},{"path":"evaluation.html","id":"creating","chapter":"20 Evaluation","heading":"20.3.1 Creating","text":"three ways create quosures:Use enquo() enquos() capture user-supplied expressions.\nvast majority quosures created way.\n\nfoo <- function(x) enquo(x)\nfoo(+ b)\n#> <quosure>\n#> expr: ^+ b\n#> env:  globalUse enquo() enquos() capture user-supplied expressions.\nvast majority quosures created way.quo() quos() exist match expr() exprs(), \nincluded sake completeness needed \nrarely. find using , think carefully expr() \ncareful unquoting can eliminate need capture environment.\n\nquo(x + y + z)\n#> <quosure>\n#> expr: ^x + y + z\n#> env:  global\nquo() quos() exist match expr() exprs(), \nincluded sake completeness needed \nrarely. find using , think carefully expr() \ncareful unquoting can eliminate need capture environment.new_quosure() create quosure components: expression \nenvironment. rarely needed practice, useful \nlearning, used lot chapter.\n\nnew_quosure(expr(x + y), env(x = 1, y = 10))\n#> <quosure>\n#> expr: ^x + y\n#> env:  0000000011AE3848new_quosure() create quosure components: expression \nenvironment. rarely needed practice, useful \nlearning, used lot chapter.","code":"\nfoo <- function(x) enquo(x)\nfoo(a + b)\n#> <quosure>\n#> expr: ^a + b\n#> env:  global\nquo(x + y + z)\n#> <quosure>\n#> expr: ^x + y + z\n#> env:  global\nnew_quosure(expr(x + y), env(x = 1, y = 10))\n#> <quosure>\n#> expr: ^x + y\n#> env:  0000000011AE3848"},{"path":"evaluation.html","id":"evaluating","chapter":"20 Evaluation","heading":"20.3.2 Evaluating","text":"\n\nQuosures paired new evaluation function eval_tidy() takes single quosure instead expression-environment pair. straightforward use:simple case, eval_tidy(q1) basically shortcut eval(get_expr(q1), get_env(q1)). However, two important features ’ll learn later chapter: supports nested quosures (Section 20.3.5) pronouns (Section 20.4.2).","code":"\nq1 <- new_quosure(expr(x + y), env(x = 1, y = 10))\neval_tidy(q1)\n#> [1] 11"},{"path":"evaluation.html","id":"quosure-dots","chapter":"20 Evaluation","heading":"20.3.3 Dots","text":"Quosures typically just convenience: make code cleaner one object pass around, instead two. , however, essential comes working ... ’s possible argument passed ... associated different environment. following example note quosures expression, x, different environment:means evaluate , get correct results:Correctly evaluating elements ... one original motivations development quosures.","code":"\nf <- function(...) {\n  x <- 1\n  g(..., f = x)\n}\ng <- function(...) {\n  enquos(...)\n}\n\nx <- 0\nqs <- f(global = x)\nqs\n#> <list_of<quosure>>\n#> \n#> $global\n#> <quosure>\n#> expr: ^x\n#> env:  global\n#> \n#> $f\n#> <quosure>\n#> expr: ^x\n#> env:  0000000022656350\nmap_dbl(qs, eval_tidy)\n#> global      f \n#>      0      1"},{"path":"evaluation.html","id":"quosure-impl","chapter":"20 Evaluation","heading":"20.3.4 Under the hood","text":"\nQuosures inspired R’s formulas, formulas capture expression environment:early version tidy evaluation used formulas instead quosures, attractive feature ~ provides quoting single keystroke. Unfortunately, however, clean way make ~ quasiquoting function.Quosures subclass formulas:means hood, quosures, like formulas, call objects:attribute stores environment:need extract expression environment, don’t rely implementation details. Instead use get_expr() get_env():","code":"\nf <- ~runif(3)\nstr(f)\n#> Class 'formula'  language ~runif(3)\n#>   ..- attr(*, \".Environment\")=<environment: R_GlobalEnv>\nq4 <- new_quosure(expr(x + y + z))\nclass(q4)\n#> [1] \"quosure\" \"formula\"\nis_call(q4)\n#> [1] TRUE\n\nq4[[1]]\n#> Warning: Subsetting quosures with `[[` is deprecated as of rlang 0.4.0\n#> Please use `quo_get_expr()` instead.\n#> This warning is displayed once per session.\n#> `~`\nq4[[2]]\n#> x + y + z\nattr(q4, \".Environment\")\n#> <environment: R_GlobalEnv>\nget_expr(q4)\n#> x + y + z\nget_env(q4)\n#> <environment: R_GlobalEnv>"},{"path":"evaluation.html","id":"nested-quosures","chapter":"20 Evaluation","heading":"20.3.5 Nested quosures","text":"’s possible use quasiquotation embed quosure expression. advanced tool, time don’t need think just works, talk can spot nested quosures wild confused. Take example, inlines two quosures expression:evaluates correctly eval_tidy():However, print , see xs, formula heritage leaking :can get better display rlang::expr_print() (Section 19.4.7):use expr_print() console, quosures coloured according environment, making easier spot symbols bound different variables.","code":"\nq2 <- new_quosure(expr(x), env(x = 1))\nq3 <- new_quosure(expr(x), env(x = 10))\n\nx <- expr(!!q2 + !!q3)\neval_tidy(x)\n#> [1] 11\nx\n#> (~x) + ~x\nexpr_print(x)\n#> (^x) + (^x)"},{"path":"evaluation.html","id":"exercises-62","chapter":"20 Evaluation","heading":"20.3.6 Exercises","text":"Predict following quosures return \nevaluated.\n\nq1 <- new_quosure(expr(x), env(x = 1))\nq1\n#> <quosure>\n#> expr: ^x\n#> env:  00000000238B9120\n\nq2 <- new_quosure(expr(x + !!q1), env(x = 10))\nq2\n#> <quosure>\n#> expr: ^x + (^x)\n#> env:  00000000239F6CC8\n\nq3 <- new_quosure(expr(x + !!q2), env(x = 100))\nq3\n#> <quosure>\n#> expr: ^x + (^x + (^x))\n#> env:  0000000023C1C1A8Predict following quosures return \nevaluated.Write enenv() function captures environment associated\nargument. (Hint: require two function calls.)Write enenv() function captures environment associated\nargument. (Hint: require two function calls.)","code":"\nq1 <- new_quosure(expr(x), env(x = 1))\nq1\n#> <quosure>\n#> expr: ^x\n#> env:  00000000238B9120\n\nq2 <- new_quosure(expr(x + !!q1), env(x = 10))\nq2\n#> <quosure>\n#> expr: ^x + (^x)\n#> env:  00000000239F6CC8\n\nq3 <- new_quosure(expr(x + !!q2), env(x = 100))\nq3\n#> <quosure>\n#> expr: ^x + (^x + (^x))\n#> env:  0000000023C1C1A8"},{"path":"evaluation.html","id":"data-masks","chapter":"20 Evaluation","heading":"20.4 Data masks","text":"section, ’ll learn data mask, data frame evaluated code look first variable definitions. data mask key idea powers base functions like (), subset() transform(), used throughout tidyverse packages like dplyr ggplot2.","code":""},{"path":"evaluation.html","id":"basics-3","chapter":"20 Evaluation","heading":"20.4.1 Basics","text":"data mask allows mingle variables environment data frame single expression. supply data mask second argument eval_tidy():code little hard follow ’s much syntax ’re creating every object scratch. ’s easier see ’s going make little wrapper. call with2() ’s equivalent base::().\ncan now rewrite code :base::eval() similar functionality, although doesn’t call data mask. Instead can supply data frame second argument environment third. gives following implementation ():","code":"\nq1 <- new_quosure(expr(x * y), env(x = 100))\ndf <- data.frame(y = 1:10)\n\neval_tidy(q1, df)\n#>  [1]  100  200  300  400  500  600  700  800  900 1000\nwith2 <- function(data, expr) {\n  expr <- enquo(expr)\n  eval_tidy(expr, data)\n}\nx <- 100\nwith2(df, x * y)\n#>  [1]  100  200  300  400  500  600  700  800  900 1000\nwith3 <- function(data, expr) {\n  expr <- substitute(expr)\n  eval(expr, data, caller_env())\n}"},{"path":"evaluation.html","id":"pronouns","chapter":"20 Evaluation","heading":"20.4.2 Pronouns","text":"\n\nUsing data mask introduces ambiguity. example, following code can’t know whether x come data mask environment, unless know variables found df.makes code harder reason (need know context), can introduce bugs. resolve issue, data mask provides two pronouns: .data .env..data$x always refers x data mask..env$x always refers x environment.can also subset .data .env using [[, e.g. .data[[\"x\"]]. Otherwise pronouns special objects shouldn’t expect behave like data frames environments. particular, throw error object isn’t found:","code":"\nwith2(df, x)\nx <- 1\ndf <- data.frame(x = 2)\n\nwith2(df, .data$x)\n#> [1] 2\nwith2(df, .env$x)\n#> [1] 1\nwith2(df, .data$y)\n#> Error: Column `y` not found in `.data`"},{"path":"evaluation.html","id":"subset","chapter":"20 Evaluation","heading":"20.4.3 Application: subset()","text":"’ll explore tidy evaluation context base::subset(), ’s simple yet powerful function makes common data manipulation challenge easier. haven’t used , subset(), like dplyr::filter(), provides convenient way selecting rows data frame. give data, along expression evaluated context data. considerably reduces number times need type name data frame:core version subset(), subset2(), quite simple. takes two arguments: data frame, data, expression, rows. evaluate rows using df data mask, use results subset data frame [. ’ve included simple check ensure result logical vector; real code create informative error.","code":"\nsample_df <- data.frame(a = 1:5, b = 5:1, c = c(5, 3, 1, 4, 1))\n\n# Shorthand for sample_df[sample_df$a >= 4, ]\nsubset(sample_df, a >= 4)\n#>   a b c\n#> 4 4 2 4\n#> 5 5 1 1\n\n# Shorthand for sample_df[sample_df$b == sample_df$c, ]\nsubset(sample_df, b == c)\n#>   a b c\n#> 1 1 5 5\n#> 5 5 1 1\nsubset2 <- function(data, rows) {\n  rows <- enquo(rows)\n  rows_val <- eval_tidy(rows, data)\n  stopifnot(is.logical(rows_val))\n\n  data[rows_val, , drop = FALSE]\n}\n\nsubset2(sample_df, b == c)\n#>   a b c\n#> 1 1 5 5\n#> 5 5 1 1"},{"path":"evaluation.html","id":"application-transform","chapter":"20 Evaluation","heading":"20.4.4 Application: transform","text":"complicated situation base::transform() allows add new variables data frame, evaluating expressions context existing variables:, transform2() requires little code. capture unevaluated ... enquos(...), evaluate expression using loop. Real code error checking ensure input named evaluates vector length data.NB: named first argument .data avoid problems users tried create variable called data. still problems attempt create variable called .data, much less likely. reasoning leads .x .f arguments map() (Section 9.2.4).","code":"\ndf <- data.frame(x = c(2, 3, 1), y = runif(3))\ntransform(df, x = -x, y2 = 2 * y)\n#>    x      y    y2\n#> 1 -2 0.0808 0.162\n#> 2 -3 0.8343 1.669\n#> 3 -1 0.6008 1.202\ntransform2 <- function(.data, ...) {\n  dots <- enquos(...)\n\n  for (i in seq_along(dots)) {\n    name <- names(dots)[[i]]\n    dot <- dots[[i]]\n\n    .data[[name]] <- eval_tidy(dot, .data)\n  }\n\n  .data\n}\n\ntransform2(df, x2 = x * 2, y = -y)\n#>   x       y x2\n#> 1 2 -0.0808  4\n#> 2 3 -0.8343  6\n#> 3 1 -0.6008  2"},{"path":"evaluation.html","id":"select","chapter":"20 Evaluation","heading":"20.4.5 Application: select()","text":"data mask typically data frame, ’s sometimes useful provide list filled exotic contents. basically select argument base::subset() works. allows refer variables numbers:key idea create named list component gives position corresponding variable:implementation lines code:dplyr::select() takes idea runs , providing number helpers allow select variables based names (e.g. starts_with(\"x\") ends_with(\"_a\")).","code":"\ndf <- data.frame(a = 1, b = 2, c = 3, d = 4, e = 5)\nsubset(df, select = b:d)\n#>   b c d\n#> 1 2 3 4\nvars <- as.list(set_names(seq_along(df), names(df)))\nstr(vars)\n#> List of 5\n#>  $ a: int 1\n#>  $ b: int 2\n#>  $ c: int 3\n#>  $ d: int 4\n#>  $ e: int 5\nselect2 <- function(data, ...) {\n  dots <- enquos(...)\n\n  vars <- as.list(set_names(seq_along(data), names(data)))\n  cols <- unlist(map(dots, eval_tidy, vars))\n\n  data[, cols, drop = FALSE]\n}\nselect2(df, b:d)\n#>   b c d\n#> 1 2 3 4"},{"path":"evaluation.html","id":"exercises-63","chapter":"20 Evaluation","heading":"20.4.6 Exercises","text":"use loop transform2() instead map()?\nConsider transform2(df, x = x * 2, x = x * 2).use loop transform2() instead map()?\nConsider transform2(df, x = x * 2, x = x * 2).’s alternative implementation subset2():\n\nsubset3 <- function(data, rows) {\n  rows <- enquo(rows)\n  eval_tidy(expr(data[!!rows, , drop = FALSE]), data = data)\n}\n\ndf <- data.frame(x = 1:3)\nsubset3(df, x == 1)\nCompare contrast subset3() subset2(). advantages\ndisadvantages?’s alternative implementation subset2():Compare contrast subset3() subset2(). advantages\ndisadvantages?following function implements basics dplyr::arrange().\nAnnotate line comment explaining . Can \nexplain !!.na.last strictly correct, omitting !!\nunlikely cause problems?\n\narrange2 <- function(.df, ..., .na.last = TRUE) {\n  args <- enquos(...)\n\n  order_call <- expr(order(!!!args, na.last = !!.na.last))\n\n  ord <- eval_tidy(order_call, .df)\n  stopifnot(length(ord) == nrow(.df))\n\n  .df[ord, , drop = FALSE]\n}following function implements basics dplyr::arrange().\nAnnotate line comment explaining . Can \nexplain !!.na.last strictly correct, omitting !!\nunlikely cause problems?","code":"\nsubset3 <- function(data, rows) {\n  rows <- enquo(rows)\n  eval_tidy(expr(data[!!rows, , drop = FALSE]), data = data)\n}\n\ndf <- data.frame(x = 1:3)\nsubset3(df, x == 1)\narrange2 <- function(.df, ..., .na.last = TRUE) {\n  args <- enquos(...)\n\n  order_call <- expr(order(!!!args, na.last = !!.na.last))\n\n  ord <- eval_tidy(order_call, .df)\n  stopifnot(length(ord) == nrow(.df))\n\n  .df[ord, , drop = FALSE]\n}"},{"path":"evaluation.html","id":"tidy-evaluation","chapter":"20 Evaluation","heading":"20.5 Using tidy evaluation","text":"’s important understand eval_tidy() works, time won’t call directly. Instead, ’ll usually use indirectly calling function uses eval_tidy(). section give practical examples wrapping functions use tidy evaluation.","code":""},{"path":"evaluation.html","id":"quoting-and-unquoting","chapter":"20 Evaluation","heading":"20.5.1 Quoting and unquoting","text":"\n\nImagine written function resamples dataset:want create new function allows us resample subset single step. naive approach doesn’t work:subsample() doesn’t quote arguments cond evaluated normally (data mask), get error tries find binding x. fix problem need quote cond, unquote pass ot subset2():common pattern; whenever call quoting function arguments user, need quote unquote.","code":"\nresample <- function(df, n) {\n  idx <- sample(nrow(df), n, replace = TRUE)\n  df[idx, , drop = FALSE]\n}\nsubsample <- function(df, cond, n = nrow(df)) {\n  df <- subset2(df, cond)\n  resample(df, n)\n}\n\ndf <- data.frame(x = c(1, 1, 1, 2, 2), y = 1:5)\nsubsample(df, x == 1)\n#> Error in eval_tidy(rows, data): objeto 'x' no encontrado\nsubsample <- function(df, cond, n = nrow(df)) {\n  cond <- enquo(cond)\n\n  df <- subset2(df, !!cond)\n  resample(df, n)\n}\n\nsubsample(df, x == 1)\n#>   x y\n#> 3 1 3\n#> 1 1 1\n#> 2 1 2"},{"path":"evaluation.html","id":"handling-ambiguity","chapter":"20 Evaluation","heading":"20.5.2 Handling ambiguity","text":"case , needed think tidy evaluation quasiquotation. also need think tidy evaluation even wrapper doesn’t need quote arguments. Take wrapper around subset2():function can silently return incorrect result two situations:x exists calling environment, df:\n\nx <- 10\nno_x <- data.frame(y = 1:3)\nthreshold_x(no_x, 2)\n#>   y\n#> 1 1\n#> 2 2\n#> 3 3When x exists calling environment, df:val exists df:\n\nhas_val <- data.frame(x = 1:3, val = 9:11)\nthreshold_x(has_val, 2)\n#> [1] x   val\n#> <0 rows> (0-length row.names)val exists df:failure modes arise tidy evaluation ambiguous: variable can found either data mask environment. make function safe need remove ambiguity using .data .env pronouns:Generally, whenever use .env pronoun, can use unquoting instead:subtle differences val evaluated. unquote, val early evaluated enquo(); use pronoun, val lazily evaluated eval_tidy(). differences usually unimportant, pick form looks natural.","code":"\nthreshold_x <- function(df, val) {\n  subset2(df, x >= val)\n}\nx <- 10\nno_x <- data.frame(y = 1:3)\nthreshold_x(no_x, 2)\n#>   y\n#> 1 1\n#> 2 2\n#> 3 3\nhas_val <- data.frame(x = 1:3, val = 9:11)\nthreshold_x(has_val, 2)\n#> [1] x   val\n#> <0 rows> (or 0-length row.names)\nthreshold_x <- function(df, val) {\n  subset2(df, .data$x >= .env$val)\n}\n\nx <- 10\nthreshold_x(no_x, 2)\n#> Error: Column `x` not found in `.data`\nthreshold_x(has_val, 2)\n#>   x val\n#> 2 2  10\n#> 3 3  11\nthreshold_x <- function(df, val) {\n  subset2(df, .data$x >= !!val)\n}"},{"path":"evaluation.html","id":"quoting-and-ambiguity","chapter":"20 Evaluation","heading":"20.5.3 Quoting and ambiguity","text":"finish discussion let’s consider case quoting potential ambiguity. ’ll generalise threshold_x() slightly user can pick variable used thresholding. used .data[[var]] makes code little simpler; exercises ’ll chance explore might use $ instead.always responsibility function author avoid ambiguity. Imagine generalise allow thresholding based expression:’s possible evaluate expr data mask, data mask doesn’t include functions like + ==. , ’s user’s responsibility avoid ambiguity. general rule thumb, function author ’s responsibility avoid ambiguity expressions create; ’s user’s responsibility avoid ambiguity expressions create.","code":"\nthreshold_var <- function(df, var, val) {\n  var <- as_string(ensym(var))\n  subset2(df, .data[[var]] >= !!val)\n}\n\ndf <- data.frame(x = 1:10)\nthreshold_var(df, x, 8)\n#>     x\n#> 8   8\n#> 9   9\n#> 10 10\nthreshold_expr <- function(df, expr, val) {\n  expr <- enquo(expr)\n  subset2(df, !!expr >= !!val)\n}"},{"path":"evaluation.html","id":"exercises-64","chapter":"20 Evaluation","heading":"20.5.4 Exercises","text":"’ve included alternative implementation threshold_var() .\nmakes different approach used ? makes harder?\n\nthreshold_var <- function(df, var, val) {\n  var <- ensym(var)\n  subset2(df, `$`(.data, !!var) >= !!val)\n}’ve included alternative implementation threshold_var() .\nmakes different approach used ? makes harder?","code":"\nthreshold_var <- function(df, var, val) {\n  var <- ensym(var)\n  subset2(df, `$`(.data, !!var) >= !!val)\n}"},{"path":"evaluation.html","id":"base-evaluation","chapter":"20 Evaluation","heading":"20.6 Base evaluation","text":"Now understand tidy evaluation, ’s time come back alternative approaches taken base R. ’ll explore two common uses base R:substitute() evaluation caller environment, used \nsubset(). ’ll use technique demonstrate technique \nprogramming friendly, warned subset() documentation.substitute() evaluation caller environment, used \nsubset(). ’ll use technique demonstrate technique \nprogramming friendly, warned subset() documentation.match.call(), call manipulation, evaluation caller environment,\nused write.csv() lm(). ’ll use technique demonstrate \nquasiquotation (regular) evaluation can help write wrappers around\nfunctions.match.call(), call manipulation, evaluation caller environment,\nused write.csv() lm(). ’ll use technique demonstrate \nquasiquotation (regular) evaluation can help write wrappers around\nfunctions.two approaches common forms non-standard evaluation (NSE).","code":""},{"path":"evaluation.html","id":"substitute","chapter":"20 Evaluation","heading":"20.6.1 substitute()","text":"common form NSE base R substitute() + eval(). following code shows might write core subset() style using substitute() eval() rather enquo() eval_tidy(). repeat code introduced Section 20.4.3 can compare easily. main difference evaluation environment: subset_base() argument evaluated caller environment, subset_tidy(), ’s evaluated environment defined.","code":"\nsubset_base <- function(data, rows) {\n  rows <- substitute(rows)\n  rows_val <- eval(rows, data, caller_env())\n  stopifnot(is.logical(rows_val))\n\n  data[rows_val, , drop = FALSE]\n}\n\nsubset_tidy <- function(data, rows) {\n  rows <- enquo(rows)\n  rows_val <- eval_tidy(rows, data)\n  stopifnot(is.logical(rows_val))\n\n  data[rows_val, , drop = FALSE]\n}"},{"path":"evaluation.html","id":"programming-with-subset","chapter":"20 Evaluation","heading":"20.6.1.1 Programming with subset()","text":"documentation subset() includes following warning:convenience function intended use interactively. \nprogramming better use standard subsetting functions like [,\nparticular non-standard evaluation argument subset can \nunanticipated consequences.three main problems:base::subset() always evaluates rows calling environment, \n... used, expression might need evaluated\nelsewhere:\n\nf1 <- function(df, ...) {\n  xval <- 3\n  subset_base(df, ...)\n}\n\nmy_df <- data.frame(x = 1:3, y = 3:1)\nxval <- 1\nf1(my_df, x == xval)\n#>   x y\n#> 3 3 1\nmay seems like esoteric concern, means subset_base()\nreliably work functionals like map() lapply():\n\nlocal({\n  zzz <- 2\n  dfs <- list(data.frame(x = 1:3), data.frame(x = 4:6))\n  lapply(dfs, subset_base, x == zzz)\n})\n#> Error eval(rows, data, caller_env()): objeto 'zzz' encontradobase::subset() always evaluates rows calling environment, \n... used, expression might need evaluated\nelsewhere:may seems like esoteric concern, means subset_base()\nreliably work functionals like map() lapply():Calling subset() another function requires care: \nuse substitute() capture call subset() complete expression,\nevaluate. think code hard understand \nsubstitute() doesn’t use syntactic marker unquoting. print\ngenerated call make little easier see ’s happening.\n\nf2 <- function(df1, expr) {\n  call <- substitute(subset_base(df1, expr))\n  expr_print(call)\n  eval(call, caller_env())\n}\n\nmy_df <- data.frame(x = 1:3, y = 3:1)\nf2(my_df, x == 1)\n#> subset_base(my_df, x == 1)\n#>   x y\n#> 1 1 3Calling subset() another function requires care: \nuse substitute() capture call subset() complete expression,\nevaluate. think code hard understand \nsubstitute() doesn’t use syntactic marker unquoting. print\ngenerated call make little easier see ’s happening.eval() doesn’t provide pronouns ’s way require part \nexpression come data. far can tell, ’s \nway make following function safe except manually checking \npresence z variable df.\n\nf3 <- function(df) {\n  call <- substitute(subset_base(df, z > 0))\n  expr_print(call)\n  eval(call, caller_env())\n}\n\nmy_df <- data.frame(x = 1:3, y = 3:1)\nz <- -1\nf3(my_df)\n#> subset_base(my_df, z > 0)\n#> [1] x y\n#> <0 rows> (0-length row.names)eval() doesn’t provide pronouns ’s way require part \nexpression come data. far can tell, ’s \nway make following function safe except manually checking \npresence z variable df.","code":"\nf1 <- function(df, ...) {\n  xval <- 3\n  subset_base(df, ...)\n}\n\nmy_df <- data.frame(x = 1:3, y = 3:1)\nxval <- 1\nf1(my_df, x == xval)\n#>   x y\n#> 3 3 1\nlocal({\n  zzz <- 2\n  dfs <- list(data.frame(x = 1:3), data.frame(x = 4:6))\n  lapply(dfs, subset_base, x == zzz)\n})\n#> Error in eval(rows, data, caller_env()): objeto 'zzz' no encontrado\nf2 <- function(df1, expr) {\n  call <- substitute(subset_base(df1, expr))\n  expr_print(call)\n  eval(call, caller_env())\n}\n\nmy_df <- data.frame(x = 1:3, y = 3:1)\nf2(my_df, x == 1)\n#> subset_base(my_df, x == 1)\n#>   x y\n#> 1 1 3\nf3 <- function(df) {\n  call <- substitute(subset_base(df, z > 0))\n  expr_print(call)\n  eval(call, caller_env())\n}\n\nmy_df <- data.frame(x = 1:3, y = 3:1)\nz <- -1\nf3(my_df)\n#> subset_base(my_df, z > 0)\n#> [1] x y\n#> <0 rows> (or 0-length row.names)"},{"path":"evaluation.html","id":"what-about","chapter":"20 Evaluation","heading":"20.6.1.2 What about [?","text":"Given tidy evaluation quite complex, simply use [ ?subset recommends? Primarily, seems unappealing functions can used interactively, never inside another function.Additionally, even simple subset() function provides two useful features compared [:sets drop = FALSE default, ’s guaranteed return data frame.sets drop = FALSE default, ’s guaranteed return data frame.drops rows condition evaluates NA.drops rows condition evaluates NA.means subset(df, x == y) equivalent df[x == y,] might expect. Instead, equivalent df[x == y & !.na(x == y), , drop = FALSE]: ’s lot typing! Real-life alternatives subset(), like dplyr::filter(), even . example, dplyr::filter() can translate R expressions SQL can executed database. makes programming filter() relatively important.","code":""},{"path":"evaluation.html","id":"match.call","chapter":"20 Evaluation","heading":"20.6.2 match.call()","text":"Another common form NSE capture complete call match.call(), modify , evaluate result. match.call() similar substitute(), instead capturing single argument, captures complete call. doesn’t equivalent rlang.One prominent user match.call() write.csv(), basically works transforming call call write.table() appropriate arguments set. following code shows heart write.csv():don’t think technique good idea can achieve result without NSE:Nevertheless, ’s important understand technique ’s commonly used modelling functions. functions also prominently print captured call, poses special challenges, ’ll see next.","code":"\ng <- function(x, y, z) {\n  match.call()\n}\ng(1, 2, z = 3)\n#> g(x = 1, y = 2, z = 3)\nwrite.csv <- function(...) {\n  call <- match.call(write.table, expand.dots = TRUE)\n\n  call[[1]] <- quote(write.table)\n  call$sep <- \",\"\n  call$dec <- \".\"\n\n  eval(call, parent.frame())\n}\nwrite.csv <- function(...) {\n  write.table(..., sep = \",\", dec = \".\")\n}"},{"path":"evaluation.html","id":"wrapping-modelling-functions","chapter":"20 Evaluation","heading":"20.6.2.1 Wrapping modelling functions","text":"begin, consider simplest possible wrapper around lm():wrapper works, suboptimal lm() captures call displays printing.Fixing important call chief way see model specification printing model. overcome problem, need capture arguments, create call lm() using unquoting, evaluate call. make easier see ’s going , ’ll also print expression generate. become useful calls get complicated.three pieces ’ll use whenever wrapping base NSE function way:capture unevaluated arguments using enexpr(), capture caller\nenvironment using caller_env().capture unevaluated arguments using enexpr(), capture caller\nenvironment using caller_env().generate new expression using expr() unquoting.generate new expression using expr() unquoting.evaluate expression caller environment. accept\nfunction work correctly arguments defined\ncaller environment. Providing env argument least provides\nhook experts can use default environment isn’t correct.evaluate expression caller environment. accept\nfunction work correctly arguments defined\ncaller environment. Providing env argument least provides\nhook experts can use default environment isn’t correct.use enexpr() nice side-effect: can use unquoting generate formulas dynamically:","code":"\nlm2 <- function(formula, data) {\n  lm(formula, data)\n}\nlm2(mpg ~ disp, mtcars)\n#> \n#> Call:\n#> lm(formula = formula, data = data)\n#> \n#> Coefficients:\n#> (Intercept)         disp  \n#>     29.5999      -0.0412\nlm3 <- function(formula, data, env = caller_env()) {\n  formula <- enexpr(formula)\n  data <- enexpr(data)\n\n  lm_call <- expr(lm(!!formula, data = !!data))\n  expr_print(lm_call)\n  eval(lm_call, env)\n}\n\nlm3(mpg ~ disp, mtcars)\n#> lm(mpg ~ disp, data = mtcars)\n#> \n#> Call:\n#> lm(formula = mpg ~ disp, data = mtcars)\n#> \n#> Coefficients:\n#> (Intercept)         disp  \n#>     29.5999      -0.0412\nresp <- expr(mpg)\ndisp1 <- expr(vs)\ndisp2 <- expr(wt)\nlm3(!!resp ~ !!disp1 + !!disp2, mtcars)\n#> lm(mpg ~ vs + wt, data = mtcars)\n#> \n#> Call:\n#> lm(formula = mpg ~ vs + wt, data = mtcars)\n#> \n#> Coefficients:\n#> (Intercept)           vs           wt  \n#>       33.00         3.15        -4.44"},{"path":"evaluation.html","id":"evaluation-environment","chapter":"20 Evaluation","heading":"20.6.2.2 Evaluation environment","text":"want mingle objects supplied user objects create function? example, imagine want make auto-resampling version lm(). might write like :doesn’t code work? ’re evaluating lm_call caller environment, resample_data exists execution environment. instead evaluate execution environment resample_lm0(), ’s guarantee formula evaluated environment.two basic ways overcome challenge:Unquote data frame call. means lookup \noccur, problems inlining expressions (Section\n19.4.7). modelling functions means \ncaptured call suboptimal:\n\nresample_lm1 <- function(formula, data, env = caller_env()) {\n  formula <- enexpr(formula)\n  resample_data <- resample(data, n = nrow(data))\n\n  lm_call <- expr(lm(!!formula, data = !!resample_data))\n  expr_print(lm_call)\n  eval(lm_call, env)\n}\nresample_lm1(y ~ x, data = df)$call\n#> lm(y ~ x, data = <data.frame>)\n#> lm(formula = y ~ x, data = list(x = c(3L, 7L, 4L, 4L, \n#> 2L, 7L, 2L, 1L, 8L, 9L), y = c(13.21, 27.04, 18.63, \n#> 18.63, 10.99, 27.04, 10.99, 7.83, 28.14, 32.72)))Unquote data frame call. means lookup \noccur, problems inlining expressions (Section\n19.4.7). modelling functions means \ncaptured call suboptimal:Alternatively can create new environment inherits \ncaller, bind variables ’ve created inside \nfunction environment.\n\nresample_lm2 <- function(formula, data, env = caller_env()) {\n  formula <- enexpr(formula)\n  resample_data <- resample(data, n = nrow(data))\n\n  lm_env <- env(env, resample_data = resample_data)\n  lm_call <- expr(lm(!!formula, data = resample_data))\n  expr_print(lm_call)\n  eval(lm_call, lm_env)\n}\nresample_lm2(y ~ x, data = df)\n#> lm(y ~ x, data = resample_data)\n#> \n#> Call:\n#> lm(formula = y ~ x, data = resample_data)\n#> \n#> Coefficients:\n#> (Intercept)            x  \n#>        4.42         3.11\nwork, gives cleanest specification.Alternatively can create new environment inherits \ncaller, bind variables ’ve created inside \nfunction environment.work, gives cleanest specification.","code":"\nresample_lm0 <- function(formula, data, env = caller_env()) {\n  formula <- enexpr(formula)\n  resample_data <- resample(data, n = nrow(data))\n\n  lm_call <- expr(lm(!!formula, data = resample_data))\n  expr_print(lm_call)\n  eval(lm_call, env)\n}\n\ndf <- data.frame(x = 1:10, y = 5 + 3 * (1:10) + round(rnorm(10), 2))\nresample_lm0(y ~ x, data = df)\n#> lm(y ~ x, data = resample_data)\n#> Error in is.data.frame(data): objeto 'resample_data' no encontrado\nresample_lm1 <- function(formula, data, env = caller_env()) {\n  formula <- enexpr(formula)\n  resample_data <- resample(data, n = nrow(data))\n\n  lm_call <- expr(lm(!!formula, data = !!resample_data))\n  expr_print(lm_call)\n  eval(lm_call, env)\n}\nresample_lm1(y ~ x, data = df)$call\n#> lm(y ~ x, data = <data.frame>)\n#> lm(formula = y ~ x, data = list(x = c(3L, 7L, 4L, 4L, \n#> 2L, 7L, 2L, 1L, 8L, 9L), y = c(13.21, 27.04, 18.63, \n#> 18.63, 10.99, 27.04, 10.99, 7.83, 28.14, 32.72)))\nresample_lm2 <- function(formula, data, env = caller_env()) {\n  formula <- enexpr(formula)\n  resample_data <- resample(data, n = nrow(data))\n\n  lm_env <- env(env, resample_data = resample_data)\n  lm_call <- expr(lm(!!formula, data = resample_data))\n  expr_print(lm_call)\n  eval(lm_call, lm_env)\n}\nresample_lm2(y ~ x, data = df)\n#> lm(y ~ x, data = resample_data)\n#> \n#> Call:\n#> lm(formula = y ~ x, data = resample_data)\n#> \n#> Coefficients:\n#> (Intercept)            x  \n#>        4.42         3.11"},{"path":"evaluation.html","id":"exercises-65","chapter":"20 Evaluation","heading":"20.6.3 Exercises","text":"function fail?\n\nlm3a <- function(formula, data) {\n  formula <- enexpr(formula)\n\n  lm_call <- expr(lm(!!formula, data = data))\n  eval(lm_call, caller_env())\n}\nlm3a(mpg ~ disp, mtcars)$call\n#> Error .data.frame.default(data, optional = TRUE): \n#> coerce class ‘\"function\"’ data.frameWhy function fail?model building, typically response data relatively\nconstant rapidly experiment different predictors. Write \nsmall wrapper allows reduce duplication code .\n\nlm(mpg ~ disp, data = mtcars)\nlm(mpg ~ (1 / disp), data = mtcars)\nlm(mpg ~ disp * cyl, data = mtcars)model building, typically response data relatively\nconstant rapidly experiment different predictors. Write \nsmall wrapper allows reduce duplication code .Another way write resample_lm() include \nresample expression (data[sample(nrow(data), replace = TRUE), , drop = FALSE])\ndata argument. Implement approach. advantages?\ndisadvantages?Another way write resample_lm() include \nresample expression (data[sample(nrow(data), replace = TRUE), , drop = FALSE])\ndata argument. Implement approach. advantages?\ndisadvantages?","code":"\nlm3a <- function(formula, data) {\n  formula <- enexpr(formula)\n\n  lm_call <- expr(lm(!!formula, data = data))\n  eval(lm_call, caller_env())\n}\nlm3a(mpg ~ disp, mtcars)$call\n#> Error in as.data.frame.default(data, optional = TRUE): \n#> cannot coerce class ‘\"function\"’ to a data.frame\nlm(mpg ~ disp, data = mtcars)\nlm(mpg ~ I(1 / disp), data = mtcars)\nlm(mpg ~ disp * cyl, data = mtcars)"},{"path":"translation.html","id":"translation","chapter":"21 Translating R code","heading":"21 Translating R code","text":"","code":""},{"path":"translation.html","id":"introduction-20","chapter":"21 Translating R code","heading":"21.1 Introduction","text":"combination first-class environments, lexical scoping, metaprogramming gives us powerful toolkit translating R code languages. One fully-fledged example idea dbplyr, powers database backends dplyr, allowing express data manipulation R automatically translate SQL. can see key idea translate_sql() takes R code returns equivalent SQL:Translating R SQL complex many idiosyncrasies SQL dialects, ’ll develop two simple, useful, domain specific languages (DSL): one generate HTML, generate mathematical equations LaTeX.’re interested learning domain specific languages general, highly recommend Domain Specific Languages.106 discusses many options creating DSL provides many examples different languages.","code":"\nlibrary(dbplyr)\ntranslate_sql(x ^ 2)\n#> <SQL> POWER(`x`, 2.0)\ntranslate_sql(x < 5 & !is.na(x))\n#> <SQL> `x` < 5.0 AND NOT(((`x`) IS NULL))\ntranslate_sql(!first %in% c(\"John\", \"Roger\", \"Robert\"))\n#> <SQL> NOT(`first` IN ('John', 'Roger', 'Robert'))\ntranslate_sql(select == 7)\n#> <SQL> `select` = 7.0"},{"path":"translation.html","id":"outline-19","chapter":"21 Translating R code","heading":"Outline","text":"Section 21.2 creates DSL generating HTML, using quasiquotation\npurrr generate function HTML tag, tidy evaluation \neasily access .Section 21.2 creates DSL generating HTML, using quasiquotation\npurrr generate function HTML tag, tidy evaluation \neasily access .Section 21.3 transforms mathematically R code LaTeX\nequivalent using combination tidy evaluation expression walking.Section 21.3 transforms mathematically R code LaTeX\nequivalent using combination tidy evaluation expression walking.","code":""},{"path":"translation.html","id":"prerequisites-14","chapter":"21 Translating R code","heading":"Prerequisites","text":"chapter pulls together many techniques discussed elsewhere book. particular, ’ll need understand environments, expressions, tidy evaluation, little functional programming S3. ’ll use rlang metaprogramming tools, purrr functional programming.","code":"\nlibrary(rlang)\nlibrary(purrr)"},{"path":"translation.html","id":"html","chapter":"21 Translating R code","heading":"21.2 HTML","text":"HTML (HyperText Markup Language) underlies majority web. ’s special case SGML (Standard Generalised Markup Language), ’s similar identical XML (eXtensible Markup Language). HTML looks like :Even ’ve never looked HTML , can still see key component coding structure tags, look like <tag><\/tag> <tag />. Tags can nested within tags intermingled text. 100 HTML tags, chapter ’ll focus just handful:<body> top-level tag contains content.<h1> defines top level heading.<p> defines paragraph.<b> emboldens text.<img> embeds image.Tags can named attributes look like <tag name1='value1' name2='value2'><\/tag>. Two important attributes id class, used conjunction CSS (Cascading Style Sheets) control visual appearance page.Void tags, like <img>, don’t children, written <img />, <img><\/img>. Since content, attributes important, img three used almost every image: src (image lives), width, height.< > special meanings HTML, can’t write directly. Instead use HTML escapes: &gt; &lt;. since escapes use &, want literal ampersand escape &amp;.","code":"<body>\n  <h1 id='first'>A heading<\/h1>\n  <p>Some text &amp; <b>some bold text.<\/b><\/p>\n  <img src='myimg.png' width='100' height='100' />\n<\/body>"},{"path":"translation.html","id":"goal","chapter":"21 Translating R code","heading":"21.2.1 Goal","text":"goal make easy generate HTML R. give concrete example, want generate following HTML:Using following code matches structure HTML closely possible:DSL following three properties:nesting function calls matches nesting tags.nesting function calls matches nesting tags.Unnamed arguments become content tag, named arguments\nbecome attributes.Unnamed arguments become content tag, named arguments\nbecome attributes.& special characters automatically escaped.& special characters automatically escaped.","code":"<body>\n  <h1 id='first'>A heading<\/h1>\n  <p>Some text &amp; <b>some bold text.<\/b><\/p>\n  <img src='myimg.png' width='100' height='100' />\n<\/body>\nwith_html(\n  body(\n    h1(\"A heading\", id = \"first\"),\n    p(\"Some text &\", b(\"some bold text.\")),\n    img(src = \"myimg.png\", width = 100, height = 100)\n  )\n)"},{"path":"translation.html","id":"escaping","chapter":"21 Translating R code","heading":"21.2.2 Escaping","text":"Escaping fundamental translation ’ll first topic. two related challenges:user input, need automatically escape &, < >.user input, need automatically escape &, < >.time need make sure &, < > generate\ndouble-escaped (.e. don’t accidentally generate &amp;amp;, &amp;lt; &amp;gt;).time need make sure &, < > generate\ndouble-escaped (.e. don’t accidentally generate &amp;amp;, &amp;lt; &amp;gt;).easiest way create S3 class (Section 13.3) distinguishes regular text (needs escaping) HTML (doesn’t).write escape generic. two important methods:escape.character() takes regular character vector returns HTML\nvector special characters (&, <, >) escaped.escape.character() takes regular character vector returns HTML\nvector special characters (&, <, >) escaped.escape.advr_html() leaves already escaped HTML alone.escape.advr_html() leaves already escaped HTML alone.Now check worksConveniently, also allows user opt escaping know content already escaped.","code":"\nhtml <- function(x) structure(x, class = \"advr_html\")\n\nprint.advr_html <- function(x, ...) {\n  out <- paste0(\"<HTML> \", x)\n  cat(paste(strwrap(out), collapse = \"\\n\"), \"\\n\", sep = \"\")\n}\nescape <- function(x) UseMethod(\"escape\")\n\nescape.character <- function(x) {\n  x <- gsub(\"&\", \"&amp;\", x)\n  x <- gsub(\"<\", \"&lt;\", x)\n  x <- gsub(\">\", \"&gt;\", x)\n\n  html(x)\n}\n\nescape.advr_html <- function(x) x\nescape(\"This is some text.\")\n#> <HTML> This is some text.\nescape(\"x > 1 & y < 2\")\n#> <HTML> x &gt; 1 &amp; y &lt; 2\n\n# Double escaping is not a problem\nescape(escape(\"This is some text. 1 > 2\"))\n#> <HTML> This is some text. 1 &gt; 2\n\n# And text we know is HTML doesn't get escaped.\nescape(html(\"<hr />\"))\n#> <HTML> <hr />"},{"path":"translation.html","id":"basic-tag-functions","chapter":"21 Translating R code","heading":"21.2.3 Basic tag functions","text":"Next, ’ll write one-tag function hand, figure generalise can generate function every tag code.Let’s start <p>. HTML tags can attributes (e.g., id class) children (like <b> <>). need way separating function call. Given attributes named children , seems natural use named unnamed arguments respectively. example, call p() might look like:list possible attributes <p> tag function definition, ’s hard many attributes, ’s possible use custom attributes. Instead, ’ll use ... separate components based whether named. mind, create helper function wraps around rlang::list2() (Section 19.6) returns named unnamed components separately:can now create p() function. Notice ’s one new function : html_attributes(). takes named list returns HTML attribute specification string. ’s little complicated (part, deals idiosyncrasies HTML haven’t mentioned ), ’s important doesn’t introduce new programming ideas, won’t discuss detail. can find source online want work .","code":"\np(\"Some text. \", b(i(\"some bold italic text\")), class = \"mypara\")\ndots_partition <- function(...) {\n  dots <- list2(...)\n  \n if (is.null(names(dots))) {\n  is_named <- rep(FALSE, length(dots))\n} else {\n  is_named <- names(dots) != \"\"\n}\n  \n  list(\n    named = dots[is_named],\n    unnamed = dots[!is_named]\n  )\n}\n\nstr(dots_partition(a = 1, 2, b = 3, 4))\n#> List of 2\n#>  $ named  :List of 2\n#>   ..$ a: num 1\n#>   ..$ b: num 3\n#>  $ unnamed:List of 2\n#>   ..$ : num 2\n#>   ..$ : num 4\nsource(\"dsl-html-attributes.r\")\np <- function(...) {\n  dots <- dots_partition(...)\n  attribs <- html_attributes(dots$named)\n  children <- map_chr(dots$unnamed, escape)\n\n  html(paste0(\n    \"<p\", attribs, \">\",\n    paste(children, collapse = \"\"),\n    \"<\/p>\"\n  ))\n}\n\np(\"Some text\")\n#> <HTML> <p>Some text<\/p>\np(\"Some text\", id = \"myid\")\n#> <HTML> <p id='myid'>Some text<\/p>\np(\"Some text\", class = \"important\", `data-value` = 10)\n#> <HTML> <p class='important' data-value='10'>Some text<\/p>"},{"path":"translation.html","id":"tag-functions","chapter":"21 Translating R code","heading":"21.2.4 Tag functions","text":"’s straightforward adapt p() tags: just need replace \"p\" name tag. One elegant way create function rlang::new_function() (Section 19.7.4), using unquoting paste0() generate starting ending tags.need weird exprs(... = ) syntax generate empty ... argument tag function. See Section 18.6.2 details.Now can run earlier example:generate functions every possible HTML tag, need create variant handles void tags. void_tag() quite similar tag(), throws error unnamed tags, tag looks little different.","code":"\ntag <- function(tag) {\n  new_function(\n    exprs(... = ),\n    expr({\n      dots <- dots_partition(...)\n      attribs <- html_attributes(dots$named)\n      children <- map_chr(dots$unnamed, escape)\n\n      html(paste0(\n        !!paste0(\"<\", tag), attribs, \">\",\n        paste(children, collapse = \"\"),\n        !!paste0(\"<\/\", tag, \">\")\n      ))\n    }),\n    caller_env()\n  )\n}\ntag(\"b\")\n#> function (...) \n#> {\n#>     dots <- dots_partition(...)\n#>     attribs <- html_attributes(dots$named)\n#>     children <- map_chr(dots$unnamed, escape)\n#>     html(paste0(\"<b\", attribs, \">\", paste(children, collapse = \"\"), \n#>         \"<\/b>\"))\n#> }\np <- tag(\"p\")\nb <- tag(\"b\")\ni <- tag(\"i\")\np(\"Some text. \", b(i(\"some bold italic text\")), class = \"mypara\")\n#> <HTML> <p class='mypara'>Some text. <b><i>some bold italic\n#> text<\/i><\/b><\/p>\nvoid_tag <- function(tag) {\n  new_function(\n    exprs(... = ),\n    expr({\n      dots <- dots_partition(...)\n      if (length(dots$unnamed) > 0) {\n        abort(!!paste0(\"<\", tag, \"> must not have unnamed arguments\"))\n      }\n      attribs <- html_attributes(dots$named)\n\n      html(paste0(!!paste0(\"<\", tag), attribs, \" />\"))\n    }),\n    caller_env()\n  )\n}\n\nimg <- void_tag(\"img\")\nimg\n#> function (...) \n#> {\n#>     dots <- dots_partition(...)\n#>     if (length(dots$unnamed) > 0) {\n#>         abort(\"<img> must not have unnamed arguments\")\n#>     }\n#>     attribs <- html_attributes(dots$named)\n#>     html(paste0(\"<img\", attribs, \" />\"))\n#> }\nimg(src = \"myimage.png\", width = 100, height = 100)\n#> <HTML> <img src='myimage.png' width='100' height='100' />"},{"path":"translation.html","id":"html-env","chapter":"21 Translating R code","heading":"21.2.5 Processing all tags","text":"Next need generate functions every tag. ’ll start list HTML tags:look list carefully, ’ll see quite tags name base R functions (body, col, q, source, sub, summary, table). means don’t want make functions available default, either global environment package. Instead, ’ll put list (like Section 10.5) provide helper make easy use desired. First, make named list containing tag functions:gives us explicit (verbose) way create HTML:can finish HTML DSL function allows us evaluate code context list. slightly abuse data mask, passing list functions rather data frame. quick hack mingle execution environment code functions html_tags.gives us succinct API allows us write HTML need doesn’t clutter namespace don’t.want access R function overridden HTML tag name inside with_html(), can use full package::function specification.","code":"\ntags <- c(\"a\", \"abbr\", \"address\", \"article\", \"aside\", \"audio\",\n  \"b\",\"bdi\", \"bdo\", \"blockquote\", \"body\", \"button\", \"canvas\",\n  \"caption\",\"cite\", \"code\", \"colgroup\", \"data\", \"datalist\",\n  \"dd\", \"del\",\"details\", \"dfn\", \"div\", \"dl\", \"dt\", \"em\",\n  \"eventsource\",\"fieldset\", \"figcaption\", \"figure\", \"footer\",\n  \"form\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\",\n  \"hgroup\", \"html\", \"i\",\"iframe\", \"ins\", \"kbd\", \"label\",\n  \"legend\", \"li\", \"mark\", \"map\",\"menu\", \"meter\", \"nav\",\n  \"noscript\", \"object\", \"ol\", \"optgroup\", \"option\", \"output\",\n  \"p\", \"pre\", \"progress\", \"q\", \"ruby\", \"rp\",\"rt\", \"s\", \"samp\",\n  \"script\", \"section\", \"select\", \"small\", \"span\", \"strong\",\n  \"style\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\",\n  \"textarea\", \"tfoot\", \"th\", \"thead\", \"time\", \"title\", \"tr\",\n  \"u\", \"ul\", \"var\", \"video\"\n)\n\nvoid_tags <- c(\"area\", \"base\", \"br\", \"col\", \"command\", \"embed\",\n  \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\",\n  \"source\", \"track\", \"wbr\"\n)\nhtml_tags <- c(\n  tags %>% set_names() %>% map(tag),\n  void_tags %>% set_names() %>% map(void_tag)\n)\nhtml_tags$p(\n  \"Some text. \",\n  html_tags$b(html_tags$i(\"some bold italic text\")),\n  class = \"mypara\"\n)\n#> <HTML> <p class='mypara'>Some text. <b><i>some bold italic\n#> text<\/i><\/b><\/p>\nwith_html <- function(code) {\n  code <- enquo(code)\n  eval_tidy(code, html_tags)\n}\nwith_html(\n  body(\n    h1(\"A heading\", id = \"first\"),\n    p(\"Some text &\", b(\"some bold text.\")),\n    img(src = \"myimg.png\", width = 100, height = 100)\n  )\n)\n#> <HTML> <body><h1 id='first'>A heading<\/h1><p>Some text &amp;<b>some\n#> bold text.<\/b><\/p><img src='myimg.png' width='100' height='100'\n#> /><\/body>"},{"path":"translation.html","id":"exercises-66","chapter":"21 Translating R code","heading":"21.2.6 Exercises","text":"escaping rules <script> tags different contain\nJavaScript, HTML. Instead escaping angle brackets ampersands,\nneed escape <\/script> tag isn’t closed early.\nexample, script(\"'<\/script>'\"), shouldn’t generate :\n<script>'<\/script>'<\/script>\n\n<script>'<\\/script>'<\/script>\nAdapt escape() follow rules new argument script\nset TRUE.escaping rules <script> tags different contain\nJavaScript, HTML. Instead escaping angle brackets ampersands,\nneed escape <\/script> tag isn’t closed early.\nexample, script(\"'<\/script>'\"), shouldn’t generate :ButAdapt escape() follow rules new argument script\nset TRUE.use ... functions big downsides. ’s \ninput validation little information \ndocumentation autocomplete used function.\nCreate new function , given named list tags \nattribute names (like ), creates tag functions named arguments.\n\nlist(\n  = c(\"href\"),\n  img = c(\"src\", \"width\", \"height\")\n)\ntags get class id attributes.use ... functions big downsides. ’s \ninput validation little information \ndocumentation autocomplete used function.\nCreate new function , given named list tags \nattribute names (like ), creates tag functions named arguments.tags get class id attributes.Reason following code calls with_html() referencing objects\nenvironment. work fail? ? Run code \nverify predictions.\n\ngreeting <- \"Hello!\"\nwith_html(p(greeting))\n\np <- function() \"p\"\naddress <- \"123 anywhere street\"\nwith_html(p(address))Reason following code calls with_html() referencing objects\nenvironment. work fail? ? Run code \nverify predictions.Currently HTML doesn’t look terribly pretty, ’s hard see \nstructure. adapt tag() indenting formatting?\n(may need research block inline tags.)Currently HTML doesn’t look terribly pretty, ’s hard see \nstructure. adapt tag() indenting formatting?\n(may need research block inline tags.)","code":"<script>'<\/script>'<\/script><script>'<\\/script>'<\/script>\nlist(\n  a = c(\"href\"),\n  img = c(\"src\", \"width\", \"height\")\n)\ngreeting <- \"Hello!\"\nwith_html(p(greeting))\n\np <- function() \"p\"\naddress <- \"123 anywhere street\"\nwith_html(p(address))"},{"path":"translation.html","id":"latex","chapter":"21 Translating R code","heading":"21.3 LaTeX","text":"next DSL convert R expressions LaTeX math equivalents. (bit like ?plotmath, text instead plots.) LaTeX lingua franca mathematicians statisticians: ’s common use LaTeX notation whenever want express equation text, like email. Since many reports produced using R LaTeX, might useful able automatically convert mathematical expressions one language .need convert functions names, mathematical DSL complicated HTML DSL. ’ll also need create default conversion, symbols don’t know get standard conversion. means can longer use just evaluation: also need walk abstract syntax tree (AST).","code":""},{"path":"translation.html","id":"latex-mathematics","chapter":"21 Translating R code","heading":"21.3.1 LaTeX mathematics","text":"begin, let’s quickly cover formulas expressed LaTeX. full standard complex, fortunately well documented, common commands fairly simple structure:simple mathematical equations written way ’d type\nR: x * y, z ^ 5. Subscripts written using _ (e.g., x_1).simple mathematical equations written way ’d type\nR: x * y, z ^ 5. Subscripts written using _ (e.g., x_1).Special characters start \\: \\pi = \\(\\pi\\), \\pm = \\(\\pm\\), .\nhuge number symbols available LaTeX: searching online \nlatex math symbols returns many\nlists.\n’s even service \nlook symbol sketch browser.Special characters start \\: \\pi = \\(\\pi\\), \\pm = \\(\\pm\\), .\nhuge number symbols available LaTeX: searching online \nlatex math symbols returns many\nlists.\n’s even service \nlook symbol sketch browser.complicated functions look like \\name{arg1}{arg2}. example, \nwrite fraction ’d use \\frac{}{b}. write square root, ’d use\n\\sqrt{}.complicated functions look like \\name{arg1}{arg2}. example, \nwrite fraction ’d use \\frac{}{b}. write square root, ’d use\n\\sqrt{}.group elements together use {}: .e., x ^ + b versus x ^ {+ b}.group elements together use {}: .e., x ^ + b versus x ^ {+ b}.good math typesetting, distinction made variables \nfunctions. without extra information, LaTeX doesn’t know whether\nf(* b) represents calling function f input * b,\nshorthand f * (* b). f function, can tell\nLaTeX typeset using upright font \\textrm{f}(* b).\n(rm stands “Roman,” opposite italics.)good math typesetting, distinction made variables \nfunctions. without extra information, LaTeX doesn’t know whether\nf(* b) represents calling function f input * b,\nshorthand f * (* b). f function, can tell\nLaTeX typeset using upright font \\textrm{f}(* b).\n(rm stands “Roman,” opposite italics.)","code":""},{"path":"translation.html","id":"goal-1","chapter":"21 Translating R code","heading":"21.3.2 Goal","text":"goal use rules automatically convert R expression appropriate LaTeX representation. ’ll tackle four stages:Convert known symbols: pi → \\piConvert known symbols: pi → \\piLeave symbols unchanged: x → x, y → yLeave symbols unchanged: x → x, y → yConvert known functions special forms: sqrt(frac(, b)) →\n\\sqrt{\\frac{}{b}}Convert known functions special forms: sqrt(frac(, b)) →\n\\sqrt{\\frac{}{b}}Wrap unknown functions \\textrm: f() → \\textrm{f}()Wrap unknown functions \\textrm: f() → \\textrm{f}()’ll code translation opposite direction HTML DSL. ’ll start infrastructure, makes easy experiment DSL, work way back generate desired output.","code":""},{"path":"translation.html","id":"to_math","chapter":"21 Translating R code","heading":"21.3.3 to_math()","text":"begin, need wrapper function convert R expressions LaTeX math expressions. work like to_html() capturing unevaluated expression evaluating special environment. two main differences:evaluation environment longer constant, vary depending \ninput. necessary handle unknown symbols functions.evaluation environment longer constant, vary depending \ninput. necessary handle unknown symbols functions.never evaluate argument environment ’re translating every\nfunction LaTeX expression. user need use explicitly !! \norder evaluate normally.never evaluate argument environment ’re translating every\nfunction LaTeX expression. user need use explicitly !! \norder evaluate normally.gives us:Next ’ll build latex_env(), starting simply getting progressively complex.","code":"\nto_math <- function(x) {\n  expr <- enexpr(x)\n  out <- eval_bare(expr, latex_env(expr))\n\n  latex(out)\n}\n\nlatex <- function(x) structure(x, class = \"advr_latex\")\nprint.advr_latex <- function(x) {\n  cat(\"<LATEX> \", x, \"\\n\", sep = \"\")\n}"},{"path":"translation.html","id":"known-symbols","chapter":"21 Translating R code","heading":"21.3.4 Known symbols","text":"first step create environment convert special LaTeX symbols used Greek characters, e.g., pi \\pi. ’ll use trick Section 20.4.3 bind symbol pi value \"\\pi\".can check :Looks good far!","code":"\ngreek <- c(\n  \"alpha\", \"theta\", \"tau\", \"beta\", \"vartheta\", \"pi\", \"upsilon\",\n  \"gamma\", \"varpi\", \"phi\", \"delta\", \"kappa\", \"rho\",\n  \"varphi\", \"epsilon\", \"lambda\", \"varrho\", \"chi\", \"varepsilon\",\n  \"mu\", \"sigma\", \"psi\", \"zeta\", \"nu\", \"varsigma\", \"omega\", \"eta\",\n  \"xi\", \"Gamma\", \"Lambda\", \"Sigma\", \"Psi\", \"Delta\", \"Xi\",\n  \"Upsilon\", \"Omega\", \"Theta\", \"Pi\", \"Phi\"\n)\ngreek_list <- set_names(paste0(\"\\\\\", greek), greek)\ngreek_env <- as_environment(greek_list)\nlatex_env <- function(expr) {\n  greek_env\n}\n\nto_math(pi)\n#> <LATEX> \\pi\nto_math(beta)\n#> <LATEX> \\beta"},{"path":"translation.html","id":"unknown-symbols","chapter":"21 Translating R code","heading":"21.3.5 Unknown symbols","text":"symbol isn’t Greek, want leave . tricky don’t know advance symbols used, can’t possibly generate . Instead, ’ll use approach described Section 18.5: walking AST find symbols. gives us all_names_rec() helper all_names():now want take list symbols convert environment symbol mapped corresponding string representation (e.g., eval(quote(x), env) yields \"x\"). use pattern converting named character vector list, converting list environment.works, need combine Greek symbols environment. Since want give preference Greek defaults (e.g., to_math(pi) give \"\\\\pi\", \"pi\"), symbol_env needs parent greek_env. , need make copy greek_env new parent. gives us function can convert known (Greek) unknown symbols.","code":"\nall_names_rec <- function(x) {\n  switch_expr(x,\n    constant = character(),\n    symbol =   as.character(x),\n    call =     flat_map_chr(as.list(x[-1]), all_names)\n  )\n}\n\nall_names <- function(x) {\n  unique(all_names_rec(x))\n}\n\nall_names(expr(x + y + f(a, b, c, 10)))\n#> [1] \"x\" \"y\" \"a\" \"b\" \"c\"\nlatex_env <- function(expr) {\n  names <- all_names(expr)\n  symbol_env <- as_environment(set_names(names))\n\n  symbol_env\n}\n\nto_math(x)\n#> <LATEX> x\nto_math(longvariablename)\n#> <LATEX> longvariablename\nto_math(pi)\n#> <LATEX> pi\nlatex_env <- function(expr) {\n  # Unknown symbols\n  names <- all_names(expr)\n  symbol_env <- as_environment(set_names(names))\n\n  # Known symbols\n  env_clone(greek_env, parent = symbol_env)\n}\n\nto_math(x)\n#> <LATEX> x\nto_math(longvariablename)\n#> <LATEX> longvariablename\nto_math(pi)\n#> <LATEX> \\pi"},{"path":"translation.html","id":"known-functions","chapter":"21 Translating R code","heading":"21.3.6 Known functions","text":"Next ’ll add functions DSL. ’ll start couple helpers make easy add new unary binary operators. functions simple: assemble strings.Using helpers, can map illustrative examples converting R LaTeX. Note R’s lexical scoping rules helping us, can easily provide new meanings standard functions like +, -, *, even ( {.modify latex_env() include environment. last environment R looks names expressions like sin(sin) work.","code":"\nunary_op <- function(left, right) {\n  new_function(\n    exprs(e1 = ),\n    expr(\n      paste0(!!left, e1, !!right)\n    ),\n    caller_env()\n  )\n}\n\nbinary_op <- function(sep) {\n  new_function(\n    exprs(e1 = , e2 = ),\n    expr(\n      paste0(e1, !!sep, e2)\n    ),\n    caller_env()\n  )\n}\n\nunary_op(\"\\\\sqrt{\", \"}\")\n#> function (e1) \n#> paste0(\"\\\\sqrt{\", e1, \"}\")\nbinary_op(\"+\")\n#> function (e1, e2) \n#> paste0(e1, \"+\", e2)\n# Binary operators\nf_env <- child_env(\n  .parent = empty_env(),\n  `+` = binary_op(\" + \"),\n  `-` = binary_op(\" - \"),\n  `*` = binary_op(\" * \"),\n  `/` = binary_op(\" / \"),\n  `^` = binary_op(\"^\"),\n  `[` = binary_op(\"_\"),\n\n  # Grouping\n  `{` = unary_op(\"\\\\left{ \", \" \\\\right}\"),\n  `(` = unary_op(\"\\\\left( \", \" \\\\right)\"),\n  paste = paste,\n\n  # Other math functions\n  sqrt = unary_op(\"\\\\sqrt{\", \"}\"),\n  sin =  unary_op(\"\\\\sin(\", \")\"),\n  log =  unary_op(\"\\\\log(\", \")\"),\n  abs =  unary_op(\"\\\\left| \", \"\\\\right| \"),\n  frac = function(a, b) {\n    paste0(\"\\\\frac{\", a, \"}{\", b, \"}\")\n  },\n\n  # Labelling\n  hat =   unary_op(\"\\\\hat{\", \"}\"),\n  tilde = unary_op(\"\\\\tilde{\", \"}\")\n)\nlatex_env <- function(expr) {\n  # Known functions\n  f_env\n\n  # Default symbols\n  names <- all_names(expr)\n  symbol_env <- as_environment(set_names(names), parent = f_env)\n\n  # Known symbols\n  greek_env <- env_clone(greek_env, parent = symbol_env)\n\n  greek_env\n}\n\nto_math(sin(x + pi))\n#> <LATEX> \\sin(x + \\pi)\nto_math(log(x[i]^2))\n#> <LATEX> \\log(x_i^2)\nto_math(sin(sin))\n#> <LATEX> \\sin(sin)"},{"path":"translation.html","id":"unknown-functions","chapter":"21 Translating R code","heading":"21.3.7 Unknown functions","text":"Finally, ’ll add default functions don’t yet know . can’t know advance unknown funtions walk AST find :need closure generate functions unknown call:update latex_env():completes original requirements:certainly take idea translate types mathematical expression, need additional metaprogramming tools.","code":"\nall_calls_rec <- function(x) {\n  switch_expr(x,\n    constant = ,\n    symbol =   character(),\n    call = {\n      fname <- as.character(x[[1]])\n      children <- flat_map_chr(as.list(x[-1]), all_calls)\n      c(fname, children)\n    }\n  )\n}\nall_calls <- function(x) {\n  unique(all_calls_rec(x))\n}\n\nall_calls(expr(f(g + b, c, d(a))))\n#> [1] \"f\" \"+\" \"d\"\nunknown_op <- function(op) {\n  new_function(\n    exprs(... = ),\n    expr({\n      contents <- paste(..., collapse = \", \")\n      paste0(!!paste0(\"\\\\mathrm{\", op, \"}(\"), contents, \")\")\n    })\n  )\n}\nunknown_op(\"foo\")\n#> function (...) \n#> {\n#>     contents <- paste(..., collapse = \", \")\n#>     paste0(\"\\\\mathrm{foo}(\", contents, \")\")\n#> }\n#> <environment: 0x0000000022ec6738>\nlatex_env <- function(expr) {\n  calls <- all_calls(expr)\n  call_list <- map(set_names(calls), unknown_op)\n  call_env <- as_environment(call_list)\n\n  # Known functions\n  f_env <- env_clone(f_env, call_env)\n\n  # Default symbols\n  names <- all_names(expr)\n  symbol_env <- as_environment(set_names(names), parent = f_env)\n\n  # Known symbols\n  greek_env <- env_clone(greek_env, parent = symbol_env)\n  greek_env\n}\nto_math(sin(pi) + f(a))\n#> <LATEX> \\sin(\\pi) + \\mathrm{f}(a)"},{"path":"translation.html","id":"exercises-67","chapter":"21 Translating R code","heading":"21.3.8 Exercises","text":"Add escaping. special symbols escaped adding backslash\nfront \\, $, %. Just HTML, ’ll need \nmake sure don’t end double-escaping. ’ll need create small\nS3 class use function operators. also allow \nembed arbitrary LaTeX needed.Add escaping. special symbols escaped adding backslash\nfront \\, $, %. Just HTML, ’ll need \nmake sure don’t end double-escaping. ’ll need create small\nS3 class use function operators. also allow \nembed arbitrary LaTeX needed.Complete DSL support functions plotmath supports.Complete DSL support functions plotmath supports.","code":""},{"path":"techniques.html","id":"techniques","chapter":"Introduction","heading":"Introduction","text":"final four chapters cover two general programming techniques: finding fixing bugs, finding fixing performance issues. Tools measure improve performance particularly important R fast language. accident: R purposely designed make interactive data analysis easier humans, make computers fast possible. R slow compared programming languages, purposes, ’s fast enough. chapters help handle cases R longer fast enough, either improving performance R code, switching language, C++, designed performance.Chapter 22 talks debugging, finding root cause \nerror can extremely frustrating. Fortunately R great tools debugging, ’re coupled solid strategy, able find root cause problems rapidly relatively painlessly.Chapter 22 talks debugging, finding root cause \nerror can extremely frustrating. Fortunately R great tools debugging, ’re coupled solid strategy, able find root cause problems rapidly relatively painlessly.Chapter 23 focuses measuring performance.Chapter 23 focuses measuring performance.Chapter 24 shows improve performance.Chapter 24 shows improve performance.","code":""},{"path":"debugging.html","id":"debugging","chapter":"22 Debugging","heading":"22 Debugging","text":"","code":""},{"path":"debugging.html","id":"introduction-21","chapter":"22 Debugging","heading":"22.1 Introduction","text":"\n\nR code throws unexpected error? tools find fix problem? chapter teach art science debugging, starting general strategy, following specific tools.’ll show tools provided R RStudio IDE. recommend using RStudio’s tools possible, ’ll also show equivalents work everywhere. may also want refer official RStudio debugging documentation always reflects latest version RStudio.NB: shouldn’t need use tools writing new functions. find using frequently new code, reconsider approach. Instead trying write one big function , work interactively small pieces. start small, can quickly identify something doesn’t work, don’t need sophisticated debugging tools.","code":""},{"path":"debugging.html","id":"outline-20","chapter":"22 Debugging","heading":"Outline","text":"Section 22.2 outlines general strategy \nfinding fixing errors.Section 22.2 outlines general strategy \nfinding fixing errors.Section 22.3 introduces traceback() function\nhelps locate exactly error occurred.Section 22.3 introduces traceback() function\nhelps locate exactly error occurred.Section 22.4 shows pause execution function\nlaunch environment can interactively explore ’s happening.Section 22.4 shows pause execution function\nlaunch environment can interactively explore ’s happening.Section 22.5 discusses challenging problem\ndebugging ’re running code non-interactively.Section 22.5 discusses challenging problem\ndebugging ’re running code non-interactively.Section 22.6 discusses handful non-error problems\noccassionally also need debugging.Section 22.6 discusses handful non-error problems\noccassionally also need debugging.","code":""},{"path":"debugging.html","id":"debugging-strategy","chapter":"22 Debugging","heading":"22.2 Overall approach","text":"Finding bug process confirming many things\nbelieve true — find one \ntrue.—Norm MatloffFinding root cause problem always challenging. bugs subtle hard find obvious, ’ve avoided first place. good strategy helps. outline four step process found useful:Google!\nWhenever see error message, start googling . ’re lucky,\n’ll discover ’s common error known solution. \ngoogling, improve chances good match removing variable\nnames values specific problem.\ncan automate process errorist107 searcher108 packages. See websites details.Google!Whenever see error message, start googling . ’re lucky,\n’ll discover ’s common error known solution. \ngoogling, improve chances good match removing variable\nnames values specific problem.can automate process errorist107 searcher108 packages. See websites details.Make repeatable\nfind root cause error, ’re going need execute \ncode many times consider reject hypotheses. make \niteration quick possible, ’s worth upfront investment make\nproblem easy fast reproduce.\nStart creating reproducible example (Section 1.7).\nNext, make example minimal removing code simplifying data.\n, may discover inputs don’t trigger error.\nMake note : helpful diagnosing root cause.\n’re using automated testing, also good time create \nautomated test case. existing test coverage low, take \nopportunity add nearby tests ensure existing good behaviour\npreserved. reduces chances creating new bug.Make repeatableTo find root cause error, ’re going need execute \ncode many times consider reject hypotheses. make \niteration quick possible, ’s worth upfront investment make\nproblem easy fast reproduce.Start creating reproducible example (Section 1.7).\nNext, make example minimal removing code simplifying data.\n, may discover inputs don’t trigger error.\nMake note : helpful diagnosing root cause.’re using automated testing, also good time create \nautomated test case. existing test coverage low, take \nopportunity add nearby tests ensure existing good behaviour\npreserved. reduces chances creating new bug.Figure \n’re lucky, one tools following section help \nquickly identify line code ’s causing bug. Usually, however,\n’ll think bit problem. ’s great idea \nadopt scientific method. Generate hypotheses, design experiments test\n, record results. may seem like lot work, \nsystematic approach end saving time. often waste lot time\nrelying intuition solve bug (“oh, must --one error,\n’ll just subtract 1 ”), better taking \nsystematic approach.\nfails, might need ask help someone else. ’ve\nfollowed previous step, ’ll small example ’s easy \nshare others. makes much easier people look \nproblem, likely help find solution.Figure isIf ’re lucky, one tools following section help \nquickly identify line code ’s causing bug. Usually, however,\n’ll think bit problem. ’s great idea \nadopt scientific method. Generate hypotheses, design experiments test\n, record results. may seem like lot work, \nsystematic approach end saving time. often waste lot time\nrelying intuition solve bug (“oh, must --one error,\n’ll just subtract 1 ”), better taking \nsystematic approach.fails, might need ask help someone else. ’ve\nfollowed previous step, ’ll small example ’s easy \nshare others. makes much easier people look \nproblem, likely help find solution.Fix test \n’ve found bug, need figure fix check\nfix actually worked. , ’s useful automated\ntests place. help ensure ’ve actually fixed\nbug, also helps ensure haven’t introduced new bugs \nprocess. absence automated tests, make sure carefully record\ncorrect output, check inputs previously failed.Fix test itOnce ’ve found bug, need figure fix check\nfix actually worked. , ’s useful automated\ntests place. help ensure ’ve actually fixed\nbug, also helps ensure haven’t introduced new bugs \nprocess. absence automated tests, make sure carefully record\ncorrect output, check inputs previously failed.","code":""},{"path":"debugging.html","id":"traceback","chapter":"22 Debugging","heading":"22.3 Locating errors","text":"\n’ve made error repeatable, next step figure comes . important tool part process traceback(), shows sequence calls (also known call stack, Section 7.5) lead error.’s simple example: can see f() calls g() calls h() calls (), checks argument numeric:run f(\"\") code RStudio see:Two options appear right error message: “Show Traceback” “Rerun Debug.” click “Show traceback” see:’re using RStudio, can use traceback() get information (sans pretty formatting):NB: read traceback() output bottom top: initial call f(), calls g(), h(), (), triggers error. ’re calling code source()d R, traceback also display location function, form filename.r#linenumber. clickable RStudio, take corresponding line code editor.","code":"\nf <- function(a) g(a)\ng <- function(b) h(b)\nh <- function(c) i(c)\ni <- function(d) {\n  if (!is.numeric(d)) {\n    stop(\"`d` must be numeric\", call. = FALSE)\n  }\n  d + 10\n}\ntraceback()\n#> 5: stop(\"`d` must be numeric\", call. = FALSE) at debugging.R#6\n#> 4: i(c) at debugging.R#3\n#> 3: h(b) at debugging.R#2\n#> 2: g(a) at debugging.R#1\n#> 1: f(\"a\")"},{"path":"debugging.html","id":"debug-lazy","chapter":"22 Debugging","heading":"22.3.1 Lazy evaluation","text":"One drawback traceback() always linearises call tree, can confusing much lazy evaluation involved (Section 7.5.2). example, take following example error happens evaluating first argument f():can using rlang::with_abort() rlang::last_trace() see call tree. , think makes much easier see source problem. Look last branch call tree see error comes j() calling k().NB: rlang::last_trace() ordered opposite way traceback(). ’ll come back issue Section 22.4.2.4.","code":"\nj <- function() k()\nk <- function() stop(\"Oops!\", call. = FALSE)\nf(j())\n#> Error: Oops!\ntraceback()\n#> 7: stop(\"Oops!\") at #1\n#> 6: k() at #1\n#> 5: j() at debugging.R#1\n#> 4: i(c) at debugging.R#3\n#> 3: h(b) at debugging.R#2\n#> 2: g(a) at debugging.R#1\n#> 1: f(j())\nrlang::with_abort(f(j()))\n#> Error: Oops!\nrlang::last_trace()\n#> Error: Can't show last error because no error was recorded yet"},{"path":"debugging.html","id":"browser","chapter":"22 Debugging","heading":"22.4 Interactive debugger","text":"\nSometimes, precise location error enough let track fix . Frequently, however, need information, easiest way get interactive debugger allows pause execution function interactively explore state.’re using RStudio, easiest way enter interactive debugger RStudio’s “Rerun Debug” tool. reruns command created error, pausing execution error occurred. Otherwise, can insert call browser() want pause, re-run function. example, insert call browser() g():browser() just regular function call means can run conditionally wrapping statement:either case, ’ll end interactive environment inside function can run arbitrary R code explore current state. ’ll know ’re interactive debugger get special prompt:RStudio, ’ll see corresponding code editor (statement run next highlighted), objects current environment Environment pane, call stack Traceback pane.","code":"\ng <- function(b) {\n  browser()\n  h(b)\n}\nf(10)\ng <- function(b) {\n  if (b < 0) {\n    browser()\n  }\n  h(b)\n}Browse[1]> "},{"path":"debugging.html","id":"browser-commands","chapter":"22 Debugging","heading":"22.4.1 browser() commands","text":"well allowing run regular R code, browser() provides special commands. can use either typing short text commands, clicking button RStudio toolbar, Figure 22.1:\nFigure 22.1: RStudio debugging toolbar\nNext, n: executes next step function. \nvariable named n, ’ll need print(n) display value.Next, n: executes next step function. \nvariable named n, ’ll need print(n) display value.Step ,  s:\nworks like next, next step function, step \nfunction can explore interactively.Step ,  s:\nworks like next, next step function, step \nfunction can explore interactively.Finish,  f:\nfinishes execution current loop function.Finish,  f:\nfinishes execution current loop function.Continue, c: leaves interactive debugging continues regular execution\nfunction. useful ’ve fixed bad state want \ncheck function proceeds correctly.Continue, c: leaves interactive debugging continues regular execution\nfunction. useful ’ve fixed bad state want \ncheck function proceeds correctly.Stop, Q: stops debugging, terminates function, returns global\nworkspace. Use ’ve figured problem , ’re\nready fix reload code.Stop, Q: stops debugging, terminates function, returns global\nworkspace. Use ’ve figured problem , ’re\nready fix reload code.two slightly less useful commands aren’t available toolbar:Enter: repeats previous command. find easy activate\naccidentally, turn using options(browserNLdisabled = TRUE).\nEnter: repeats previous command. find easy activate\naccidentally, turn using options(browserNLdisabled = TRUE).\n: prints stack trace active calls (interactive equivalent \ntraceback).: prints stack trace active calls (interactive equivalent \ntraceback).","code":""},{"path":"debugging.html","id":"alternatives","chapter":"22 Debugging","heading":"22.4.2 Alternatives","text":"three alternatives using browser(): setting breakpoints RStudio, options(error = recover), debug() related functions.","code":""},{"path":"debugging.html","id":"breakpoints","chapter":"22 Debugging","heading":"22.4.2.1 Breakpoints","text":"RStudio, can set breakpoint clicking left line number, pressing Shift + F9. Breakpoints behave similarly browser() easier set (one click instead nine key presses), don’t run risk accidentally including browser() statement source code. two small downsides breakpoints:unusual situations breakpoints work.\nRead breakpoint troubleshooting details.unusual situations breakpoints work.\nRead breakpoint troubleshooting details.RStudio currently support conditional breakpoints.RStudio currently support conditional breakpoints.","code":""},{"path":"debugging.html","id":"recover","chapter":"22 Debugging","heading":"22.4.2.2 recover()","text":"\nAnother way activate browser() use options(error = recover). Now get error, ’ll get interactive prompt displays traceback gives ability interactively debug inside frames:can return default error handling options(error = NULL).","code":"\noptions(error = recover)\nf(\"x\")\n#> Error: `d` must be numeric\n#> \n#> Enter a frame number, or 0 to exit   \n#> \n#> 1: f(\"x\")\n#> 2: debugging.R#1: g(a)\n#> 3: debugging.R#2: h(b)\n#> 4: debugging.R#3: i(c)\n#> \n#> Selection:"},{"path":"debugging.html","id":"debug","chapter":"22 Debugging","heading":"22.4.2.3 debug()","text":"Another approach call function inserts browser() call :debug() inserts browser statement first line specified\nfunction. undebug() removes . Alternatively, can use debugonce()\nbrowse next run.debug() inserts browser statement first line specified\nfunction. undebug() removes . Alternatively, can use debugonce()\nbrowse next run.utils::setBreakpoint() works similarly, instead taking function\nname, takes file name line number finds appropriate function\n.utils::setBreakpoint() works similarly, instead taking function\nname, takes file name line number finds appropriate function\n.two functions special cases trace(), inserts arbitrary code position existing function. trace() occasionally useful ’re debugging code don’t source . remove tracing function, use untrace(). can perform one trace per function, one trace can call multiple functions.","code":""},{"path":"debugging.html","id":"call-stack-ordering","chapter":"22 Debugging","heading":"22.4.2.4 Call stack","text":"Unfortunately, call stacks printed traceback(), browser() & , recover() consistent. following table shows call stacks simple nested set calls displayed three tools. numbering different traceback() , recover() displays calls opposite order.RStudio displays calls order traceback(). rlang functions use ordering numbering recover(), also use indenting reinforce hierarchy calls.","code":""},{"path":"debugging.html","id":"debug-compiled","chapter":"22 Debugging","heading":"22.4.3 Compiled code","text":"also possible use interactive debugger (gdb lldb) compiled code (like C C++). Unfortunately ’s beyond scope book, resources might find useful:http://r-pkgs..co.nz/src.html#src-debugginghttps://github.com/wch/r-debug/blob/master/debugging-r.mdhttp://kevinushey.github.io/blog/2015/04/05/debugging--valgrind/https://www.jimhester.com/2018/08/22/debugging-rstudio/","code":""},{"path":"debugging.html","id":"non-interactive-debugging","chapter":"22 Debugging","heading":"22.5 Non-interactive debugging","text":"Debugging challenging can’t run code interactively, typically ’s part pipeline run automatically (possibly another computer), error doesn’t occur run code interactively. can extremely frustrating!section give useful tools, don’t forget general strategy Section 22.2. can’t explore interactively, ’s particularly important spend time making problem small possible can iterate quickly. Sometimes callr::r(f, list(1, 2)) can useful; calls f(1, 2) fresh session, can help reproduce problem.might also want double check common issues:global environment different? loaded different packages?\nobjects left previous sessions causing differences?global environment different? loaded different packages?\nobjects left previous sessions causing differences?working directory different?working directory different?PATH environment variable, determines external\ncommands (like git) found, different?PATH environment variable, determines external\ncommands (like git) found, different?R_LIBS environment variable, determines library()\nlooks packages, different?R_LIBS environment variable, determines library()\nlooks packages, different?","code":""},{"path":"debugging.html","id":"dump.frames","chapter":"22 Debugging","heading":"22.5.1 dump.frames()","text":"dump.frames() equivalent recover() non-interactive code; saves last.dump.rda file working directory. Later, interactive session, can load(\"last.dump.rda\"); debugger() enter interactive debugger interface recover(). lets “cheat,” interactively debugging code run non-interactively.","code":"\n# In batch R process ----\ndump_and_quit <- function() {\n  # Save debugging info to file last.dump.rda\n  dump.frames(to.file = TRUE)\n  # Quit R with error status\n  q(status = 1)\n}\noptions(error = dump_and_quit)\n\n# In a later interactive session ----\nload(\"last.dump.rda\")\ndebugger()"},{"path":"debugging.html","id":"print-debugging","chapter":"22 Debugging","heading":"22.5.2 Print debugging","text":"dump.frames() doesn’t help, good fallback print debugging, insert numerous print statements precisely locate problem, see values important variables. Print debugging slow primitive, always works, ’s particularly useful can’t get good traceback. Start inserting coarse-grained markers, make progressively fine-grained determine exactly problem .Print debugging particularly useful compiled code ’s uncommon compiler modify code extent can’t figure root problem even inside interactive debugger.","code":"\nf <- function(a) {\n  cat(\"f()\\n\")\n  g(a)\n}\ng <- function(b) {\n  cat(\"g()\\n\")\n  cat(\"b =\", b, \"\\n\")\n  h(b)\n}\nh <- function(c) {\n  cat(\"i()\\n\")\n  i(c)\n}\n\nf(10)\n#> f()\n#> g()\n#> b = 10 \n#> i()\n#> [1] 20"},{"path":"debugging.html","id":"rmarkdown","chapter":"22 Debugging","heading":"22.5.3 RMarkdown","text":"Debugging code inside RMarkdown files requires special tools. First, ’re knitting file using RStudio, switch calling rmarkdown::render(\"path//file.Rmd\") instead. runs code current session, makes easier debug. makes problem go away, ’ll need figure makes environments different.problem persists, ’ll need use interactive debugging skills. Whatever method use, ’ll need extra step: error handler, ’ll need call sink(). removes default sink knitr uses capture output, ensures can see results console. example, use recover() RMarkdown, ’d put following code setup block:generate “sink remove” warning knitr completes; can safely ignore warning.simply want traceback, easiest option use rlang::trace_back(), taking advantage rlang_trace_top_env option. ensures see traceback code, instead functions called RMarkdown knitr.","code":"\noptions(error = function() {\n  sink()\n  recover()\n})\noptions(rlang_trace_top_env = rlang::current_env())\noptions(error = function() {\n  sink()\n  print(rlang::trace_back(bottom = sys.frame(-1)), simplify = \"none\")\n})"},{"path":"debugging.html","id":"non-error-failures","chapter":"22 Debugging","heading":"22.6 Non-error failures","text":"\n\n\nways function fail apart throwing error:function may generate unexpected warning. easiest way track \nwarnings convert errors options(warn = 2) use \ncall stack, like doWithOneRestart(), withOneRestart(),\nregular debugging tools. ’ll see extra calls\nwithRestarts(), .signalSimpleWarning(). Ignore : \ninternal functions used turn warnings errors.function may generate unexpected warning. easiest way track \nwarnings convert errors options(warn = 2) use \ncall stack, like doWithOneRestart(), withOneRestart(),\nregular debugging tools. ’ll see extra calls\nwithRestarts(), .signalSimpleWarning(). Ignore : \ninternal functions used turn warnings errors.function may generate unexpected message. can use\nrlang::with_abort() turn messages errors:\n\nf <- function() g()\ng <- function() message(\"Hi!\")\nf()\n#> Hi!\n\nrlang::with_abort(f(), \"message\")\n#> Error: Hi!\nrlang::last_trace()\n#> Error: show last error error recorded yetA function may generate unexpected message. can use\nrlang::with_abort() turn messages errors:function might never return. particularly hard debug\nautomatically, sometimes terminating function looking \ntraceback() informative. Otherwise, use use print debugging,\nSection 22.5.2.function might never return. particularly hard debug\nautomatically, sometimes terminating function looking \ntraceback() informative. Otherwise, use use print debugging,\nSection 22.5.2.worst scenario code might crash R completely, leaving \nway interactively debug code. indicates bug \ncompiled (C C++) code.\nbug compiled code, ’ll need follow links Section\n22.4.3 learn use interactive C debugger\n(insert many print statements).\nbug package base R, ’ll need contact package\nmaintainer. either case, work making smallest possible\nreproducible example (Section 1.7) help developer help .worst scenario code might crash R completely, leaving \nway interactively debug code. indicates bug \ncompiled (C C++) code.bug compiled code, ’ll need follow links Section\n22.4.3 learn use interactive C debugger\n(insert many print statements).bug package base R, ’ll need contact package\nmaintainer. either case, work making smallest possible\nreproducible example (Section 1.7) help developer help .","code":"\nf <- function() g()\ng <- function() message(\"Hi!\")\nf()\n#> Hi!\n\nrlang::with_abort(f(), \"message\")\n#> Error: Hi!\nrlang::last_trace()\n#> Error: Can't show last error because no error was recorded yet"},{"path":"perf-measure.html","id":"perf-measure","chapter":"23 Measuring performance","heading":"23 Measuring performance","text":"","code":""},{"path":"perf-measure.html","id":"introduction-22","chapter":"23 Measuring performance","heading":"23.1 Introduction","text":"Programmers waste enormous amounts time thinking , worrying\n, speed noncritical parts programs, attempts\nefficiency actually strong negative impact debugging \nmaintenance considered.— Donald Knuth.can make code faster, first need figure ’s making slow. sounds easy, ’s . Even experienced programmers hard time identifying bottlenecks code. instead relying intuition, profile code: measure run-time line code using realistic inputs.’ve identified bottlenecks ’ll need carefully experiment alternatives find faster code still equivalent. Chapter 24 ’ll learn bunch ways speed code, first need learn microbenchmark can precisely measure difference performance.","code":""},{"path":"perf-measure.html","id":"outline-21","chapter":"23 Measuring performance","heading":"Outline","text":"Section 23.2 shows use profiling tools dig \nexactly making code slow.Section 23.2 shows use profiling tools dig \nexactly making code slow.Section 23.3 shows use microbenchmarking \nexplore alternative implementations figure exactly one \nfastest.Section 23.3 shows use microbenchmarking \nexplore alternative implementations figure exactly one \nfastest.","code":""},{"path":"perf-measure.html","id":"prerequisites-15","chapter":"23 Measuring performance","heading":"Prerequisites","text":"’ll use profvis profiling, bench microbenchmarking.","code":"\nlibrary(profvis)\n#> Warning: package 'profvis' was built under R version 4.1.2\nlibrary(bench)\n#> Warning: package 'bench' was built under R version 4.1.2"},{"path":"perf-measure.html","id":"profiling","chapter":"23 Measuring performance","heading":"23.2 Profiling","text":"\nAcross programming languages, primary tool used understand code performance profiler. number different types profilers, R uses fairly simple type called sampling statistical profiler. sampling profiler stops execution code every milliseconds records call stack (.e. function currently executing, function called function, ). example, consider f(), :(use profvis::pause() instead Sys.sleep() Sys.sleep() appear profiling outputs far R can tell, doesn’t use computing time.) profiled execution f(), stopping execution code every 0.1 s, ’d see profile like :line represents one “tick” profiler (0.1 s case), function calls recorded right left: first line shows f() calling pause(). shows code spends 0.1 s running f(), 0.2 s running g(), 0.1 s running h().actually profile f(), using utils::Rprof() code , ’re unlikely get clear result.’s profilers must make fundamental trade-accuracy performance. compromise makes, using sampling profiler, minimal impact performance, fundamentally stochastic ’s variability accuracy timer time taken operation. means time profile ’ll get slightly different answer. Fortunately, variability affects functions take little time run, also functions least interest.","code":"\nf <- function() {\n  pause(0.1)\n  g()\n  h()\n}\ng <- function() {\n  pause(0.1)\n  h()\n}\nh <- function() {\n  pause(0.1)\n}\"pause\" \"f\" \n\"pause\" \"g\" \"f\"\n\"pause\" \"h\" \"g\" \"f\"\n\"pause\" \"h\" \"f\"\ntmp <- tempfile()\nRprof(tmp, interval = 0.1)\nf()\nRprof(NULL)\nwriteLines(readLines(tmp))\n#> sample.interval=100000\n#> \"pause\" \"g\" \"f\" \n#> \"pause\" \"h\" \"g\" \"f\" \n#> \"pause\" \"h\" \"f\" "},{"path":"perf-measure.html","id":"visualising-profiles","chapter":"23 Measuring performance","heading":"23.2.1 Visualising profiles","text":"default profiling resolution quite small, function takes even seconds generate hundreds samples. quickly grows beyond ability look directly, instead using utils::Rprof() ’ll use profvis package visualise aggregates. profvis also connects profiling data back underlying source code, making easier build mental model need change. find profvis doesn’t help code, might try one options like utils::summaryRprof() proftools package.109There two ways use profvis:Profile menu RStudio.Profile menu RStudio.profvis::profvis(). recommend storing code separate\nfile source()ing ; ensure get best connection\nprofiling data source code.\n\nsource(\"profiling-example.R\")\nprofvis(f())profvis::profvis(). recommend storing code separate\nfile source()ing ; ensure get best connection\nprofiling data source code.profiling complete, profvis open interactive HTML document allows explore results. two panes, shown Figure 23.1.\nFigure 23.1: profvis output showing source top flame graph .\ntop pane shows source code, overlaid bar graphs memory execution time line code. ’ll focus time, ’ll come back memory shortly. display gives good overall feel bottlenecks doesn’t always help precisely identify cause. , example, can see h() takes 150 ms, twice long g(); ’s function slower, ’s called twice often.bottom pane displays flame graph showing full call stack. allows see full sequence calls leading function, allowing see h() called two different places. display can mouse individual calls get information, see corresponding line source code, Figure 23.2.\nFigure 23.2: Hovering call flamegraph highlights corresponding line code, displays additional information performance.\nAlternatively, can use data tab, Figure 23.3 lets interactively dive tree performance data. basically display flame graph (rotated 90 degrees), ’s useful large deeply nested call stacks can choose interactively zoom selected components.\nFigure 23.3: data gives interactive tree allows selectively zoom key components\n","code":"\nsource(\"profiling-example.R\")\nprofvis(f())"},{"path":"perf-measure.html","id":"memory-profiling","chapter":"23 Measuring performance","heading":"23.2.2 Memory profiling","text":"\n\nspecial entry flame graph doesn’t correspond code: <GC>, indicates garbage collector running. <GC> taking lot time, ’s usually indication ’re creating many short-lived objects. example, take small snippet code:profile , ’ll see time spent garbage collector, Figure 23.4.\nFigure 23.4: Profiling loop modifies existing variable reveals time spent garbage collector ().\nsee garbage collector taking lot time code, can often figure source problem looking memory column: ’ll see line large amounts memory allocated (bar right) freed (bar left). problem arises copy--modify (Section 2.3): iteration loop creates another copy x. ’ll learn strategies resolve type problem Section 24.6.","code":"\nx <- integer()\nfor (i in 1:1e4) {\n  x <- c(x, i)\n}"},{"path":"perf-measure.html","id":"limitations","chapter":"23 Measuring performance","heading":"23.2.3 Limitations","text":"limitations profiling:Profiling extend C code. can see R code calls C/C++\ncode functions called inside C/C++ code.\nUnfortunately, tools profiling compiled code beyond scope \nbook; start looking https://github.com/r-prof/jointprof.Profiling extend C code. can see R code calls C/C++\ncode functions called inside C/C++ code.\nUnfortunately, tools profiling compiled code beyond scope \nbook; start looking https://github.com/r-prof/jointprof.’re lot functional programming anonymous functions,\ncan hard figure exactly function called.\neasiest way work around name functions.’re lot functional programming anonymous functions,\ncan hard figure exactly function called.\neasiest way work around name functions.Lazy evaluation means arguments often evaluated inside another\nfunction, complicates call stack (Section\n7.5.2). Unfortunately R’s profiler doesn’t store enough\ninformation disentangle lazy evaluation following code,\nprofiling make seem like () called j() \nargument isn’t evaluated ’s needed j().\n\n<- function() {\n  pause(0.1)\n  10\n}\nj <- function(x) {\n  x + 10\n}\nj(())\nconfusing, use force() (Section 10.2.3) \nforce computation happen earlier.Lazy evaluation means arguments often evaluated inside another\nfunction, complicates call stack (Section\n7.5.2). Unfortunately R’s profiler doesn’t store enough\ninformation disentangle lazy evaluation following code,\nprofiling make seem like () called j() \nargument isn’t evaluated ’s needed j().confusing, use force() (Section 10.2.3) \nforce computation happen earlier.","code":"\ni <- function() {\n  pause(0.1)\n  10\n}\nj <- function(x) {\n  x + 10\n}\nj(i())"},{"path":"perf-measure.html","id":"exercises-68","chapter":"23 Measuring performance","heading":"23.2.4 Exercises","text":"Profile following function torture = TRUE. \nsurprising? Read source code rm() figure ’s going .\n\nf <- function(n = 1e5) {\n  x <- rep(1, n)\n  rm(x)\n}Profile following function torture = TRUE. \nsurprising? Read source code rm() figure ’s going .","code":"\nf <- function(n = 1e5) {\n  x <- rep(1, n)\n  rm(x)\n}"},{"path":"perf-measure.html","id":"microbenchmarking","chapter":"23 Measuring performance","heading":"23.3 Microbenchmarking","text":"\nmicrobenchmark measurement performance small piece code, something might take milliseconds (ms), microseconds (µs), nanoseconds (ns) run. Microbenchmarks useful comparing small snippets code specific tasks. wary generalising results microbenchmarks real code: observed differences microbenchmarks typically dominated higher-order effects real code; deep understanding subatomic physics helpful baking.great tool microbenchmarking R bench package.110 bench package uses high precision timer, making possible compare operations take tiny amount time. example, following code compares speed two approaches computing square root.default, bench::mark() runs expression least (min_iterations = 1), enough times take 0.5 s (min_time = 0.5). checks run returns value typically want microbenchmarking; want compare speed expressions return different values, set check = FALSE.","code":"\nx <- runif(100)\n(lb <- bench::mark(\n  sqrt(x),\n  x ^ 0.5\n))\n#> # A tibble: 2 x 6\n#>   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 sqrt(x)       1.8us    2.1us   246923.      848B        0\n#> 2 x^0.5        11.1us   12.2us    59701.      848B        0"},{"path":"perf-measure.html","id":"benchmark-results","chapter":"23 Measuring performance","heading":"23.3.1 bench::mark() results","text":"bench::mark() returns results tibble, one row input expression, following columns:min, mean, median, max, itr/sec summarise time taken \nexpression. Focus minimum (best possible running time) \nmedian (typical time). example, can see using \nspecial purpose sqrt() function faster general exponentiation\noperator.\ncan visualise distribution individual timings plot():\n\nplot(lb)\n#> Loading required namespace: tidyr\n\ndistribution tends heavily right-skewed (note x-axis \nalready log scale!), avoid comparing means.\n’ll also often see multimodality computer running\nsomething else background.min, mean, median, max, itr/sec summarise time taken \nexpression. Focus minimum (best possible running time) \nmedian (typical time). example, can see using \nspecial purpose sqrt() function faster general exponentiation\noperator.can visualise distribution individual timings plot():distribution tends heavily right-skewed (note x-axis \nalready log scale!), avoid comparing means.\n’ll also often see multimodality computer running\nsomething else background.mem_alloc tells amount memory allocated first run,\nn_gc() tells total number garbage collections \nruns. useful assessing memory usage expression.mem_alloc tells amount memory allocated first run,\nn_gc() tells total number garbage collections \nruns. useful assessing memory usage expression.n_itr total_time tells many times expression \nevaluated long took total. n_itr always \ngreater min_iteration parameter, total_time always\ngreater min_time parameter.n_itr total_time tells many times expression \nevaluated long took total. n_itr always \ngreater min_iteration parameter, total_time always\ngreater min_time parameter.result, memory, time, gc list-columns store \nraw underlying data.result, memory, time, gc list-columns store \nraw underlying data.result special type tibble, can use [ select just important columns. ’ll frequently next chapter.","code":"\nplot(lb)\n#> Loading required namespace: tidyr\nlb[c(\"expression\", \"min\", \"median\", \"itr/sec\", \"n_gc\")]\n#> # A tibble: 2 x 4\n#>   expression      min   median `itr/sec`\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl>\n#> 1 sqrt(x)       1.8us    2.1us   246923.\n#> 2 x^0.5        11.1us   12.2us    59701."},{"path":"perf-measure.html","id":"interpreting-results","chapter":"23 Measuring performance","heading":"23.3.2 Interpreting results","text":"microbenchmarks, pay careful attention units: , computation takes 1,800 ns, 1,800 billionths second. help calibrate impact microbenchmark run time, ’s useful think many times function needs run takes second. microbenchmark takes:1 ms, one thousand calls take second.1 µs, one million calls take second.1 ns, one billion calls take second.sqrt() function takes 1,800 ns, 1.8 µs, compute square roots 100 numbers. means repeated operation million times, take 1.8 s, hence changing way compute square root unlikely significantly affect real code. reason need exercise care generalising microbenchmarking results.","code":""},{"path":"perf-measure.html","id":"exercises-69","chapter":"23 Measuring performance","heading":"23.3.3 Exercises","text":"Instead using bench::mark(), use built-function\nsystem.time(). system.time() much less precise, ’ll\nneed repeat operation many times loop, divide\nfind average time operation, code .\n\nn <- 1e6\nsystem.time((1:n) sqrt(x)) / n\nsystem.time((1:n) x ^ 0.5) / n\nestimates system.time() compare \nbench::mark()? different?Instead using bench::mark(), use built-function\nsystem.time(). system.time() much less precise, ’ll\nneed repeat operation many times loop, divide\nfind average time operation, code .estimates system.time() compare \nbench::mark()? different?two ways compute square root vector. \nthink fastest? slowest? Use microbenchmarking\ntest answers.\n\nx ^ (1 / 2)\nexp(log(x) / 2)two ways compute square root vector. \nthink fastest? slowest? Use microbenchmarking\ntest answers.","code":"\nn <- 1e6\nsystem.time(for (i in 1:n) sqrt(x)) / n\nsystem.time(for (i in 1:n) x ^ 0.5) / n\nx ^ (1 / 2)\nexp(log(x) / 2)"},{"path":"perf-improve.html","id":"perf-improve","chapter":"24 Improving performance","heading":"24 Improving performance","text":"","code":""},{"path":"perf-improve.html","id":"introduction-23","chapter":"24 Improving performance","heading":"24.1 Introduction","text":"forget small efficiencies, say 97% time:\npremature optimization root evil. Yet pass \nopportunities critical 3%. good programmer lulled\ncomplacency reasoning, wise look carefully \ncritical code; code identified.— Donald KnuthOnce ’ve used profiling identify bottleneck, need make faster. ’s difficult provide general advice improving performance, try best four techniques can applied many situations. ’ll also suggest general strategy performance optimisation helps ensure faster code still correct.’s easy get caught trying remove bottlenecks. Don’t! time valuable better spent analysing data, eliminating possible inefficiencies code. pragmatic: don’t spend hours time save seconds computer time. enforce advice, set goal time code optimise goal. means eliminate bottlenecks. get ’ve met goal. Others may need pass accept either quick easy solution code already well optimised significant improvement possible. Accept possibilities move next candidate.’d like learn performance characteristics R language, ’d highly recommend Evaluating Design R Language.111 draws conclusions combining modified R interpreter wide set code found wild.","code":""},{"path":"perf-improve.html","id":"outline-22","chapter":"24 Improving performance","heading":"Outline","text":"Section 24.2 teaches organise\ncode make optimisation easy, bug free, possible.Section 24.2 teaches organise\ncode make optimisation easy, bug free, possible.Section 24.3 reminds look existing\nsolutions.Section 24.3 reminds look existing\nsolutions.Section 24.4 emphasises importance \nlazy: often easiest way make function faster \nlet less work.Section 24.4 emphasises importance \nlazy: often easiest way make function faster \nlet less work.Section 24.5 concisely defines vectorisation, shows \nmake built-functions.Section 24.5 concisely defines vectorisation, shows \nmake built-functions.Section 24.6 discusses performance perils \ncopying data.Section 24.6 discusses performance perils \ncopying data.Section 24.7 pulls pieces together case\nstudy showing speed repeated t-tests thousand times.Section 24.7 pulls pieces together case\nstudy showing speed repeated t-tests thousand times.Section 24.8 finishes chapter pointers \nresources help write fast code.Section 24.8 finishes chapter pointers \nresources help write fast code.","code":""},{"path":"perf-improve.html","id":"prerequisites-16","chapter":"24 Improving performance","heading":"Prerequisites","text":"’ll use bench precisely compare performance small self-contained code chunks.","code":"\nlibrary(bench)\n#> Warning: package 'bench' was built under R version 4.1.2"},{"path":"perf-improve.html","id":"code-organisation","chapter":"24 Improving performance","heading":"24.2 Code organisation","text":"two traps easy fall trying make code faster:Writing faster incorrect code.Writing code think faster, actually better.strategy outlined help avoid pitfalls.tackling bottleneck, ’re likely come multiple approaches. Write function approach, encapsulating relevant behaviour. makes easier check approach returns correct result time long takes run. demonstrate strategy, ’ll compare two approaches computing mean:recommend keep record everything try, even failures. similar problem occurs future, ’ll useful see everything ’ve tried. recommend RMarkdown, makes easy intermingle code detailed comments notes.Next, generate representative test case. case big enough capture essence problem small enough takes seconds . don’t want take long ’ll need run test case many times compare approaches. hand, don’t want case small results might scale real problem. ’m going use 100,000 numbers:Now use bench::mark() precisely compare variations. bench::mark() automatically checks calls return values. doesn’t guarantee function behaves inputs, ideal world ’ll also unit tests make sure don’t accidentally change behaviour function.(might surprised results: mean(x) considerably slower sum(x) / length(x). , among reasons, mean(x) makes two passes vector numerically accurate.)’d like see strategy action, ’ve used times stackoverflow:http://stackoverflow.com/questions/22515525#22518603http://stackoverflow.com/questions/22515175#22515856http://stackoverflow.com/questions/3476015#22511936","code":"\nmean1 <- function(x) mean(x)\nmean2 <- function(x) sum(x) / length(x)\nx <- runif(1e5)\nbench::mark(\n  mean1(x),\n  mean2(x)\n)[c(\"expression\", \"min\", \"median\", \"itr/sec\", \"n_gc\")]\n#> # A tibble: 2 x 4\n#>   expression      min   median `itr/sec`\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl>\n#> 1 mean1(x)      424us    760us      654.\n#> 2 mean2(x)      180us    203us     2583."},{"path":"perf-improve.html","id":"already-solved","chapter":"24 Improving performance","heading":"24.3 Checking for existing solutions","text":"’ve organised code captured variations can think , ’s natural see others done. part large community, ’s quite possible someone already tackled problem. Two good places start :CRAN task views. ’s \nCRAN task view related problem domain, ’s worth looking \npackages listed .CRAN task views. ’s \nCRAN task view related problem domain, ’s worth looking \npackages listed .Reverse dependencies Rcpp, listed \nCRAN page. Since \npackages use C++, ’re likely fast.Reverse dependencies Rcpp, listed \nCRAN page. Since \npackages use C++, ’re likely fast.Otherwise, challenge describing bottleneck way helps find related problems solutions. Knowing name problem synonyms make search much easier. don’t know ’s called, ’s hard search ! best way solve problem read widely can build vocabulary time. Alternatively, ask others. Talk colleagues brainstorm possible names, search Google StackOverflow. ’s often helpful restrict search R related pages. Google, try rseek. stackoverflow, restrict search including R tag, [R], search.Record solutions find, just immediately appear faster. solutions might slower initially, end faster ’re easier optimise. may also able combine fastest parts different approaches. ’ve found solution ’s fast enough, congratulations! Otherwise, read .","code":""},{"path":"perf-improve.html","id":"exercises-70","chapter":"24 Improving performance","heading":"24.3.1 Exercises","text":"faster alternatives lm()? specifically designed\nwork larger datasets?faster alternatives lm()? specifically designed\nwork larger datasets?package implements version match() ’s faster \nrepeated lookups? much faster ?package implements version match() ’s faster \nrepeated lookups? much faster ?List four functions (just base R) convert string \ndate time object. strengths weaknesses?List four functions (just base R) convert string \ndate time object. strengths weaknesses?packages provide ability compute rolling mean?packages provide ability compute rolling mean?alternatives optim()?alternatives optim()?","code":""},{"path":"perf-improve.html","id":"be-lazy","chapter":"24 Improving performance","heading":"24.4 Doing as little as possible","text":"easiest way make function faster let less work. One way use function tailored specific type input output, specific problem. example:rowSums(), colSums(), rowMeans(), colMeans() faster \nequivalent invocations use apply() vectorised\n(Section 24.5).rowSums(), colSums(), rowMeans(), colMeans() faster \nequivalent invocations use apply() vectorised\n(Section 24.5).vapply() faster sapply() pre-specifies output\ntype.vapply() faster sapply() pre-specifies output\ntype.want see vector contains single value, (x == 10)\nmuch faster 10 %% x testing equality simpler\ntesting set inclusion.want see vector contains single value, (x == 10)\nmuch faster 10 %% x testing equality simpler\ntesting set inclusion.knowledge fingertips requires knowing alternative functions exist: need good vocabulary. Expand vocab regularly reading R code. Good places read code R-help mailing list StackOverflow.functions coerce inputs specific type. input right type, function extra work. Instead, look function works data , consider changing way store data. common example problem using apply() data frame. apply() always turns input matrix. error prone (data frame general matrix), also slower.functions less work give information problem. ’s always worthwhile carefully read documentation experiment different arguments. examples ’ve discovered past include:read.csv(): specify known column types colClasses. (Also consider\nswitching readr::read_csv() data.table::fread() \nconsiderably faster read.csv().)read.csv(): specify known column types colClasses. (Also consider\nswitching readr::read_csv() data.table::fread() \nconsiderably faster read.csv().)factor(): specify known levels levels.factor(): specify known levels levels.cut(): don’t generate labels labels = FALSE don’t need ,\n, even better, use findInterval() mentioned “see also” section\ndocumentation.cut(): don’t generate labels labels = FALSE don’t need ,\n, even better, use findInterval() mentioned “see also” section\ndocumentation.unlist(x, use.names = FALSE) much faster unlist(x).unlist(x, use.names = FALSE) much faster unlist(x).interaction(): need combinations exist data, use\ndrop = TRUE.interaction(): need combinations exist data, use\ndrop = TRUE., explore might improve apply strategy improve performance mean() .data.frame().","code":""},{"path":"perf-improve.html","id":"mean","chapter":"24 Improving performance","heading":"24.4.1 mean()","text":"Sometimes can make function faster avoiding method dispatch. ’re calling method tight loop, can avoid costs method lookup :S3, can calling generic.class() instead generic().S3, can calling generic.class() instead generic().S4, can using selectMethod() find method, saving\nvariable, calling function.S4, can using selectMethod() find method, saving\nvariable, calling function.example, calling mean.default() quite bit faster calling mean() small vectors:optimisation little risky. mean.default() almost twice fast 100 values, fail surprising ways x numeric vector.even riskier optimisation directly call underlying .Internal function. faster doesn’t input checking handle NA’s, buying speed cost safety.NB: differences arise x small. increase size differences basically disappear, time now spent computing mean, finding underlying implementation. good reminder size input matters, motivate optimisations based realistic data.","code":"\nx <- runif(1e2)\n\nbench::mark(\n  mean(x),\n  mean.default(x)\n)[c(\"expression\", \"min\", \"median\", \"itr/sec\", \"n_gc\")]\n#> # A tibble: 2 x 4\n#>   expression           min   median `itr/sec`\n#>   <bch:expr>      <bch:tm> <bch:tm>     <dbl>\n#> 1 mean(x)              6us    7.1us    53463.\n#> 2 mean.default(x)    3.1us    3.8us    31441.\nx <- runif(1e2)\nbench::mark(\n  mean(x),\n  mean.default(x),\n  .Internal(mean(x))\n)[c(\"expression\", \"min\", \"median\", \"itr/sec\", \"n_gc\")]\n#> # A tibble: 3 x 4\n#>   expression              min   median `itr/sec`\n#>   <bch:expr>         <bch:tm> <bch:tm>     <dbl>\n#> 1 mean(x)                 6us    7.4us   108559.\n#> 2 mean.default(x)       3.1us    3.9us   213854.\n#> 3 .Internal(mean(x))    800ns    1.1us   811405.\nx <- runif(1e4)\nbench::mark(\n  mean(x),\n  mean.default(x),\n  .Internal(mean(x))\n)[c(\"expression\", \"min\", \"median\", \"itr/sec\", \"n_gc\")]\n#> # A tibble: 3 x 4\n#>   expression              min   median `itr/sec`\n#>   <bch:expr>         <bch:tm> <bch:tm>     <dbl>\n#> 1 mean(x)              40.7us   44.8us    20705.\n#> 2 mean.default(x)      37.3us     41us    22311.\n#> 3 .Internal(mean(x))   35.1us   44.9us    18493."},{"path":"perf-improve.html","id":"as.data.frame","chapter":"24 Improving performance","heading":"24.4.2 as.data.frame()","text":"Knowing ’re dealing specific type input can another way write faster code. example, .data.frame() quite slow coerces element data frame rbind()s together. named list vectors equal length, can directly transform data frame. case, can make strong assumptions input, can write method ’s considerably faster default., note trade-. method fast ’s dangerous. give bad inputs, ’ll get corrupt data frame:come minimal method, carefully read rewrote source code .data.frame.list() data.frame(). made many small changes, time checking hadn’t broken existing behaviour. several hours work, able isolate minimal code shown . useful technique. base R functions written flexibility functionality, performance. Thus, rewriting specific need can often yield substantial improvements. , ’ll need read source code. can complex confusing, don’t give !","code":"\nquickdf <- function(l) {\n  class(l) <- \"data.frame\"\n  attr(l, \"row.names\") <- .set_row_names(length(l[[1]]))\n  l\n}\n\nl <- lapply(1:26, function(i) runif(1e3))\nnames(l) <- letters\n\nbench::mark(\n  as.data.frame = as.data.frame(l),\n  quick_df      = quickdf(l)\n)[c(\"expression\", \"min\", \"median\", \"itr/sec\", \"n_gc\")]\n#> # A tibble: 2 x 4\n#>   expression         min   median `itr/sec`\n#>   <bch:expr>    <bch:tm> <bch:tm>     <dbl>\n#> 1 as.data.frame   2.73ms   3.15ms      279.\n#> 2 quick_df        17.1us   21.5us    33201.\nquickdf(list(x = 1, y = 1:2))\n#> Warning in format.data.frame(if (omit) x[seq_len(n0), , drop = FALSE] else x, :\n#> corrupt data frame: columns will be truncated or padded with NAs\n#>   x y\n#> 1 1 1"},{"path":"perf-improve.html","id":"exercises-71","chapter":"24 Improving performance","heading":"24.4.3 Exercises","text":"’s difference rowSums() .rowSums()?’s difference rowSums() .rowSums()?Make faster version chisq.test() computes chi-square\ntest statistic input two numeric vectors missing\nvalues. can try simplifying chisq.test() coding \nmathematical definition.Make faster version chisq.test() computes chi-square\ntest statistic input two numeric vectors missing\nvalues. can try simplifying chisq.test() coding \nmathematical definition.Can make faster version table() case input \ntwo integer vectors missing values? Can use \nspeed chi-square test?Can make faster version table() case input \ntwo integer vectors missing values? Can use \nspeed chi-square test?","code":""},{"path":"perf-improve.html","id":"vectorise","chapter":"24 Improving performance","heading":"24.5 Vectorise","text":"’ve used R length time, ’ve probably heard admonishment “vectorise code.” actually mean? Vectorising code just avoiding loops, although ’s often step. Vectorising taking whole-object approach problem, thinking vectors, scalars. two key attributes vectorised function:makes many problems simpler. Instead think \ncomponents vector, think entire vectors.makes many problems simpler. Instead think \ncomponents vector, think entire vectors.loops vectorised function written C instead R. Loops C\nmuch faster much less overhead.loops vectorised function written C instead R. Loops C\nmuch faster much less overhead.Chapter 9 stressed importance vectorised code higher level abstraction. Vectorisation also important writing fast R code. doesn’t mean simply using map() lapply(). Instead, vectorisation means finding existing R function implemented C closely applies problem.Vectorised functions apply many common performance bottlenecks include:rowSums(), colSums(), rowMeans(), colMeans(). vectorised\nmatrix functions always faster using apply(). can\nsometimes use functions build vectorised functions.\n\nrowAny <- function(x) rowSums(x) > 0\nrowAll <- function(x) rowSums(x) == ncol(x)rowSums(), colSums(), rowMeans(), colMeans(). vectorised\nmatrix functions always faster using apply(). can\nsometimes use functions build vectorised functions.Vectorised subsetting can lead big improvements speed. Remember \ntechniques behind lookup tables (Section 4.5.1) matching\nmerging hand (Section 4.5.2). Also\nremember can use subsetting assignment replace multiple values \nsingle step. x vector, matrix data frame \nx[.na(x)] <- 0 replace missing values 0.Vectorised subsetting can lead big improvements speed. Remember \ntechniques behind lookup tables (Section 4.5.1) matching\nmerging hand (Section 4.5.2). Also\nremember can use subsetting assignment replace multiple values \nsingle step. x vector, matrix data frame \nx[.na(x)] <- 0 replace missing values 0.’re extracting replacing values scattered locations matrix\ndata frame, subset integer matrix.\nSee Section 4.2.3 details.’re extracting replacing values scattered locations matrix\ndata frame, subset integer matrix.\nSee Section 4.2.3 details.’re converting continuous values categorical make sure know\nuse cut() findInterval().’re converting continuous values categorical make sure know\nuse cut() findInterval().aware vectorised functions like cumsum() diff().aware vectorised functions like cumsum() diff().Matrix algebra general example vectorisation. loops executed highly tuned external libraries like BLAS. can figure way use matrix algebra solve problem, ’ll often get fast solution. ability solve problems matrix algebra product experience. good place start ask people experience domain.Vectorisation downside: harder predict operations scale. following example measures long takes use character subsetting look 1, 10, 100 elements list. might expect looking 10 elements take 10 times long looking 1, looking 100 elements take 10 times longer . fact, following example shows takes ~10x longer look 100 elements look 1. happens get certain size, internal implementation switches strategy higher set cost, scales better.Vectorisation won’t solve every problem, rather torturing existing algorithm one uses vectorised approach, ’re often better writing vectorised function C++. ’ll learn Chapter 25.","code":"\nrowAny <- function(x) rowSums(x) > 0\nrowAll <- function(x) rowSums(x) == ncol(x)\nlookup <- setNames(as.list(sample(100, 26)), letters)\n\nx1 <- \"j\"\nx10 <- sample(letters, 10)\nx100 <- sample(letters, 100, replace = TRUE)\n\nbench::mark(\n  lookup[x1],\n  lookup[x10],\n  lookup[x100],\n  check = FALSE\n)[c(\"expression\", \"min\", \"median\", \"itr/sec\", \"n_gc\")]\n#> # A tibble: 3 x 4\n#>   expression        min   median `itr/sec`\n#>   <bch:expr>   <bch:tm> <bch:tm>     <dbl>\n#> 1 lookup[x1]      1.3us    1.8us   442984.\n#> 2 lookup[x10]     2.8us    3.6us   216607.\n#> 3 lookup[x100]    5.9us    9.7us    97707."},{"path":"perf-improve.html","id":"exercises-72","chapter":"24 Improving performance","heading":"24.5.1 Exercises","text":"density functions, e.g., dnorm(), common interface. \narguments vectorised ? rnorm(10, mean = 10:1) ?density functions, e.g., dnorm(), common interface. \narguments vectorised ? rnorm(10, mean = 10:1) ?Compare speed apply(x, 1, sum) rowSums(x) varying sizes\nx.Compare speed apply(x, 1, sum) rowSums(x) varying sizes\nx.can use crossprod() compute weighted sum? much faster \nnaive sum(x * w)?can use crossprod() compute weighted sum? much faster \nnaive sum(x * w)?","code":""},{"path":"perf-improve.html","id":"avoid-copies","chapter":"24 Improving performance","heading":"24.6 Avoiding copies","text":"\npernicious source slow R code growing object loop. Whenever use c(), append(), cbind(), rbind(), paste() create bigger object, R must first allocate space new object copy old object new home. ’re repeating many times, like loop, can quite expensive. ’ve entered Circle 2 R inferno.saw one example type problem Section 23.2.2, ’ll show slightly complex example basic issue. first generate random strings, combine either iteratively loop using collapse(), single pass using paste(). Note performance collapse() gets relatively worse number strings grows: combining 100 strings takes almost 30 times longer combining 10 strings.Modifying object loop, e.g., x[] <- y, can also create copy, depending class x. Section 2.5.1 discusses issue depth gives tools determine ’re making copies.","code":"\nrandom_string <- function() {\n  paste(sample(letters, 50, replace = TRUE), collapse = \"\")\n}\nstrings10 <- replicate(10, random_string())\nstrings100 <- replicate(100, random_string())\n\ncollapse <- function(xs) {\n  out <- \"\"\n  for (x in xs) {\n    out <- paste0(out, x)\n  }\n  out\n}\n\nbench::mark(\n  loop10  = collapse(strings10),\n  loop100 = collapse(strings100),\n  vec10   = paste(strings10, collapse = \"\"),\n  vec100  = paste(strings100, collapse = \"\"),\n  check = FALSE\n)[c(\"expression\", \"min\", \"median\", \"itr/sec\", \"n_gc\")]\n#> # A tibble: 4 x 4\n#>   expression      min   median `itr/sec`\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl>\n#> 1 loop10       44.3us   54.8us    17031.\n#> 2 loop100      1.23ms   1.63ms      418.\n#> 3 vec10        10.4us   12.4us    48685.\n#> 4 vec100       49.2us     66us    11888."},{"path":"perf-improve.html","id":"t-test","chapter":"24 Improving performance","heading":"24.7 Case study: t-test","text":"following case study shows make t-tests faster using techniques described . ’s based example Computing thousands test statistics simultaneously R Holger Schwender Tina Müller. thoroughly recommend reading paper full see idea applied tests.Imagine run 1000 experiments (rows), collects data 50 individuals (columns). first 25 individuals experiment assigned group 1 rest group 2. ’ll first generate random data represent problem:data form, two ways use t.test(). can either use formula interface provide two vectors, one group. Timing reveals formula interface considerably slower.course, loop computes, doesn’t save values. can map_dbl() (Section 9.2.1) . adds little overhead:can make faster? First, try less work. look source code stats:::t.test.default(), ’ll see lot just compute t-statistic. also computes p-value formats output printing. can try make code faster stripping pieces.gives us six-fold speed improvement.Now fairly simple function, can make faster still vectorising . Instead looping array outside function, modify t_stat() work matrix values. Thus, mean() becomes rowMeans(), length() becomes ncol(), sum() becomes rowSums(). rest code stays .’s much faster! ’s least 40 times faster previous effort, around 1000 times faster started.","code":"\nm <- 1000\nn <- 50\nX <- matrix(rnorm(m * n, mean = 10, sd = 3), nrow = m)\ngrp <- rep(1:2, each = n / 2)\nsystem.time(\n  for (i in 1:m) {\n    t.test(X[i, ] ~ grp)$statistic\n  }\n)\n#>    user  system elapsed \n#>    2.07    0.00    2.25\nsystem.time(\n  for (i in 1:m) {\n    t.test(X[i, grp == 1], X[i, grp == 2])$statistic\n  }\n)\n#>    user  system elapsed \n#>    0.41    0.00    0.43\ncompT <- function(i){\n  t.test(X[i, grp == 1], X[i, grp == 2])$statistic\n}\nsystem.time(t1 <- purrr::map_dbl(1:m, compT))\n#>    user  system elapsed \n#>    0.42    0.00    0.52\nmy_t <- function(x, grp) {\n  t_stat <- function(x) {\n    m <- mean(x)\n    n <- length(x)\n    var <- sum((x - m) ^ 2) / (n - 1)\n\n    list(m = m, n = n, var = var)\n  }\n\n  g1 <- t_stat(x[grp == 1])\n  g2 <- t_stat(x[grp == 2])\n\n  se_total <- sqrt(g1$var / g1$n + g2$var / g2$n)\n  (g1$m - g2$m) / se_total\n}\n\nsystem.time(t2 <- purrr::map_dbl(1:m, ~ my_t(X[.,], grp)))\n#>    user  system elapsed \n#>    0.08    0.00    0.07\nstopifnot(all.equal(t1, t2))\nrowtstat <- function(X, grp){\n  t_stat <- function(X) {\n    m <- rowMeans(X)\n    n <- ncol(X)\n    var <- rowSums((X - m) ^ 2) / (n - 1)\n\n    list(m = m, n = n, var = var)\n  }\n\n  g1 <- t_stat(X[, grp == 1])\n  g2 <- t_stat(X[, grp == 2])\n\n  se_total <- sqrt(g1$var / g1$n + g2$var / g2$n)\n  (g1$m - g2$m) / se_total\n}\nsystem.time(t3 <- rowtstat(X, grp))\n#>    user  system elapsed \n#>    0.03    0.00    0.03\nstopifnot(all.equal(t1, t3))"},{"path":"perf-improve.html","id":"more-techniques","chapter":"24 Improving performance","heading":"24.8 Other techniques","text":"able write fast R code part good R programmer. Beyond specific hints chapter, want write fast R code, ’ll need improve general programming skills. ways :Read R blogs see performance\nproblems people struggled , made \ncode faster.Read R blogs see performance\nproblems people struggled , made \ncode faster.Read R programming books, like Art R Programming112 Patrick Burns’\nR Inferno \nlearn common traps.Read R programming books, like Art R Programming112 Patrick Burns’\nR Inferno \nlearn common traps.Take algorithms data structure course learn \nwell known ways tackling certain classes problems. heard\ngood things Princeton’s\nAlgorithms course offered \nCoursera.Take algorithms data structure course learn \nwell known ways tackling certain classes problems. heard\ngood things Princeton’s\nAlgorithms course offered \nCoursera.Learn parallelise code. Two places start \nParallel R113 Parallel Computing Data Science.114Learn parallelise code. Two places start \nParallel R113 Parallel Computing Data Science.114Read general books optimisation like Mature optimisation115\nPragmatic Programmer.116Read general books optimisation like Mature optimisation115\nPragmatic Programmer.116You can also reach community help. StackOverflow can useful resource. ’ll need put effort creating easily digestible example also captures salient features problem. example complex, people time motivation attempt solution. ’s simple, ’ll get answers solve toy problem real problem. also try answer questions StackOverflow, ’ll quickly get feel makes good question.","code":""},{"path":"rcpp.html","id":"rcpp","chapter":"25 Rewriting R code in C++","heading":"25 Rewriting R code in C++","text":"","code":""},{"path":"rcpp.html","id":"introduction-24","chapter":"25 Rewriting R code in C++","heading":"25.1 Introduction","text":"Sometimes R code just isn’t fast enough. ’ve used profiling figure bottlenecks , ’ve done everything can R, code still isn’t fast enough. chapter ’ll learn improve performance rewriting key functions C++. magic comes way Rcpp package117 (key contributions Doug Bates, John Chambers, JJ Allaire).Rcpp makes simple connect C++ R. possible write C Fortran code use R, painful comparison. Rcpp provides clean, approachable API lets write high-performance code, insulated R’s complex C API.  Typical bottlenecks C++ can address include:Loops can’t easily vectorised subsequent iterations depend\nprevious ones.Loops can’t easily vectorised subsequent iterations depend\nprevious ones.Recursive functions, problems involve calling functions millions \ntimes. overhead calling function C++ much lower R.Recursive functions, problems involve calling functions millions \ntimes. overhead calling function C++ much lower R.Problems require advanced data structures algorithms R doesn’t\nprovide. standard template library (STL), C++ efficient\nimplementations many important data structures, ordered maps \ndouble-ended queues.Problems require advanced data structures algorithms R doesn’t\nprovide. standard template library (STL), C++ efficient\nimplementations many important data structures, ordered maps \ndouble-ended queues.aim chapter discuss aspects C++ Rcpp absolutely necessary help eliminate bottlenecks code. won’t spend much time advanced features like object-oriented programming templates focus writing small, self-contained functions, big programs. working knowledge C++ helpful, essential. Many good tutorials references freely available, including http://www.learncpp.com/ https://en.cppreference.com/w/cpp. advanced topics, Effective C++ series Scott Meyers popular choice.","code":""},{"path":"rcpp.html","id":"outline-23","chapter":"25 Rewriting R code in C++","heading":"Outline","text":"Section 25.2 teaches write C++ \nconverting simple R functions C++ equivalents. ’ll learn \nC++ differs R, key scalar, vector, matrix classes\ncalled.Section 25.2 teaches write C++ \nconverting simple R functions C++ equivalents. ’ll learn \nC++ differs R, key scalar, vector, matrix classes\ncalled.Section 25.2.5 shows use sourceCpp() load\nC++ file disk way use source() load file \nR code.Section 25.2.5 shows use sourceCpp() load\nC++ file disk way use source() load file \nR code.Section 25.3 discusses modify\nattributes Rcpp, mentions important classes.Section 25.3 discusses modify\nattributes Rcpp, mentions important classes.Section 25.4 teaches work R’s missing values\nC++.Section 25.4 teaches work R’s missing values\nC++.Section 25.5 shows use important data\nstructures algorithms standard template library, STL,\nbuilt-C++.Section 25.5 shows use important data\nstructures algorithms standard template library, STL,\nbuilt-C++.Section 25.6 shows two real case studies \nRcpp used get considerable performance improvements.Section 25.6 shows two real case studies \nRcpp used get considerable performance improvements.Section 25.7 teaches add C++ code\npackage.Section 25.7 teaches add C++ code\npackage.Section 25.8 concludes chapter pointers \nresources help learn Rcpp C++.Section 25.8 concludes chapter pointers \nresources help learn Rcpp C++.","code":""},{"path":"rcpp.html","id":"prerequisites-17","chapter":"25 Rewriting R code in C++","heading":"Prerequisites","text":"’ll use Rcpp call C++ R:’ll also need working C++ compiler. get :Windows, install Rtools.Mac, install Xcode app store.Linux, sudo apt-get install r-base-dev similar.","code":"\nlibrary(Rcpp)\n#> Warning: package 'Rcpp' was built under R version 4.1.1"},{"path":"rcpp.html","id":"rcpp-intro","chapter":"25 Rewriting R code in C++","heading":"25.2 Getting started with C++","text":"cppFunction() allows write C++ functions R: run code, Rcpp compile C++ code construct R function connects compiled C++ function. ’s lot going underneath hood Rcpp takes care details don’t need worry .following sections teach basics translating simple R functions C++ equivalents. ’ll start simple function inputs scalar output, make progressively complicated:Scalar input scalar outputVector input scalar outputVector input vector outputMatrix input vector output","code":"\ncppFunction('int add(int x, int y, int z) {\n  int sum = x + y + z;\n  return sum;\n}')\n# add works like a regular R function\nadd\n#> function (x, y, z) \n#> .Call(<pointer: 0x0000000071281580>, x, y, z)\nadd(1, 2, 3)\n#> [1] 6"},{"path":"rcpp.html","id":"no-inputs-scalar-output","chapter":"25 Rewriting R code in C++","heading":"25.2.1 No inputs, scalar output","text":"Let’s start simple function. arguments always returns integer 1:equivalent C++ function :can compile use R cppFunction()small function illustrates number important differences R C++:syntax create function looks like syntax call function;\ndon’t use assignment create functions R.syntax create function looks like syntax call function;\ndon’t use assignment create functions R.must declare type output function returns. function\nreturns int (scalar integer). classes common types\nR vectors : NumericVector, IntegerVector, CharacterVector, \nLogicalVector.must declare type output function returns. function\nreturns int (scalar integer). classes common types\nR vectors : NumericVector, IntegerVector, CharacterVector, \nLogicalVector.Scalars vectors different. scalar equivalents numeric,\ninteger, character, logical vectors : double, int, String, \nbool.Scalars vectors different. scalar equivalents numeric,\ninteger, character, logical vectors : double, int, String, \nbool.must use explicit return statement return value \nfunction.must use explicit return statement return value \nfunction.Every statement terminated ;.Every statement terminated ;.","code":"\none <- function() 1Lint one() {\n  return 1;\n}\ncppFunction('int one() {\n  return 1;\n}')"},{"path":"rcpp.html","id":"scalar-input-scalar-output","chapter":"25 Rewriting R code in C++","heading":"25.2.2 Scalar input, scalar output","text":"next example function implements scalar version sign() function returns 1 input positive, -1 ’s negative:C++ version:declare type input way declare type \noutput. makes code little verbose, also makes clear\ntype input function needs.declare type input way declare type \noutput. makes code little verbose, also makes clear\ntype input function needs.syntax identical — big differences \nR C++, also lots similarities! C++ also \nstatement works way R’s. R can use break \nexit loop, skip one iteration need use continue instead\nnext.syntax identical — big differences \nR C++, also lots similarities! C++ also \nstatement works way R’s. R can use break \nexit loop, skip one iteration need use continue instead\nnext.","code":"\nsignR <- function(x) {\n  if (x > 0) {\n    1\n  } else if (x == 0) {\n    0\n  } else {\n    -1\n  }\n}\n\ncppFunction('int signC(int x) {\n  if (x > 0) {\n    return 1;\n  } else if (x == 0) {\n    return 0;\n  } else {\n    return -1;\n  }\n}')"},{"path":"rcpp.html","id":"vector-input-scalar-output","chapter":"25 Rewriting R code in C++","heading":"25.2.3 Vector input, scalar output","text":"One big difference R C++ cost loops much lower C++. example, implement sum function R using loop. ’ve programming R , ’ll probably visceral reaction function!C++, loops little overhead, ’s fine use . Section 25.5, ’ll see alternatives loops clearly express intent; ’re faster, can make code easier understand.C++ version similar, :find length vector, use .size() method, returns\ninteger. C++ methods called . (.e., full stop).find length vector, use .size() method, returns\ninteger. C++ methods called . (.e., full stop).statement different syntax: (init; check; increment).\nloop initialised creating new variable called value 0.\niteration check < n, terminate loop ’s\n. iteration, increment value one, using \nspecial prefix operator ++ increases value 1.statement different syntax: (init; check; increment).\nloop initialised creating new variable called value 0.\niteration check < n, terminate loop ’s\n. iteration, increment value one, using \nspecial prefix operator ++ increases value 1.C++, vector indices start 0, means last element \nposition n - 1. ’ll say ’s important:\nC++, VECTOR INDICES START 0! common\nsource bugs converting R functions C++.C++, vector indices start 0, means last element \nposition n - 1. ’ll say ’s important:\nC++, VECTOR INDICES START 0! common\nsource bugs converting R functions C++.Use = assignment, <-.Use = assignment, <-.C++ provides operators modify -place: total += x[] equivalent \ntotal = total + x[]. Similar -place operators -=, *=, /=.C++ provides operators modify -place: total += x[] equivalent \ntotal = total + x[]. Similar -place operators -=, *=, /=.good example C++ much efficient R. shown following microbenchmark, sumC() competitive built-(highly optimised) sum(), sumR() several orders magnitude slower.","code":"\nsumR <- function(x) {\n  total <- 0\n  for (i in seq_along(x)) {\n    total <- total + x[i]\n  }\n  total\n}\ncppFunction('double sumC(NumericVector x) {\n  int n = x.size();\n  double total = 0;\n  for(int i = 0; i < n; ++i) {\n    total += x[i];\n  }\n  return total;\n}')\nx <- runif(1e3)\nbench::mark(\n  sum(x),\n  sumC(x),\n  sumR(x)\n)[1:6]\n#> # A tibble: 3 x 6\n#>   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 sum(x)        2.4us    2.8us   173684.        0B        0\n#> 2 sumC(x)       4.8us      8us    87580.    2.49KB        0\n#> 3 sumR(x)      44.1us   60.6us    13276.   33.52KB        0"},{"path":"rcpp.html","id":"vector-input-vector-output","chapter":"25 Rewriting R code in C++","heading":"25.2.4 Vector input, vector output","text":"Next ’ll create function computes Euclidean distance value vector values:R, ’s obvious want x scalar function definition, ’d need make clear documentation. ’s problem C++ version explicit types:function introduces new concepts:create new numeric vector length n constructor:\nNumericVector (n). Another useful way making vector copy \nexisting one: NumericVector zs = clone(ys).create new numeric vector length n constructor:\nNumericVector (n). Another useful way making vector copy \nexisting one: NumericVector zs = clone(ys).C++ uses pow(), ^, exponentiation.C++ uses pow(), ^, exponentiation.Note R version fully vectorised, ’s already going fast.computer, takes around 5 ms 1 million element y vector. C++ function 2.5 times faster, ~2 ms, assuming took 10 minutes write C++ function, ’d need run ~200,000 times make rewriting worthwhile. reason C++ function faster subtle, relates memory management. R version needs create intermediate vector length y (x - ys), allocating memory expensive operation. C++ function avoids overhead uses intermediate scalar.","code":"\npdistR <- function(x, ys) {\n  sqrt((x - ys) ^ 2)\n}\ncppFunction('NumericVector pdistC(double x, NumericVector ys) {\n  int n = ys.size();\n  NumericVector out(n);\n\n  for(int i = 0; i < n; ++i) {\n    out[i] = sqrt(pow(ys[i] - x, 2.0));\n  }\n  return out;\n}')\ny <- runif(1e6)\nbench::mark(\n  pdistR(0.5, y),\n  pdistC(0.5, y)\n)[1:6]\n#> # A tibble: 2 x 6\n#>   expression          min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>     <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 pdistR(0.5, y)   19.7ms   21.3ms      46.0    7.63MB     26.9\n#> 2 pdistC(0.5, y)   13.2ms   15.1ms      64.1    7.63MB     54.9"},{"path":"rcpp.html","id":"sourceCpp","chapter":"25 Rewriting R code in C++","heading":"25.2.5 Using sourceCpp","text":"far, ’ve used inline C++ cppFunction(). makes presentation simpler, real problems, ’s usually easier use stand-alone C++ files source R using sourceCpp(). lets take advantage text editor support C++ files (e.g., syntax highlighting) well making easier identify line numbers compilation errors. stand-alone C++ file extension .cpp, needs start :function want available within R, need prefix :’re familiar roxygen2, might wonder relates @export. Rcpp::export controls whether function exported C++ R; @export controls whether function exported package made available user.can embed R code special C++ comment blocks. really convenient want run test code:R code run source(echo = TRUE) don’t need explicitly print output.compile C++ code, use sourceCpp(\"path//file.cpp\"). create matching R functions add current session. Note functions can saved .Rdata file reloaded later session; must recreated time restart R.example, running sourceCpp() following file implements mean C++ compares built-mean():NB: run code, ’ll notice meanC() much faster built-mean(). trades numerical accuracy speed.remainder chapter C++ code presented stand-alone rather wrapped call cppFunction. want try compiling /modifying examples paste C++ source file includes elements described . easy RMarkdown: need specify engine = \"Rcpp\".","code":"#include <Rcpp.h>\nusing namespace Rcpp;// [[Rcpp::export]]/*** R\n# This is R code\n*/#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble meanC(NumericVector x) {\n  int n = x.size();\n  double total = 0;\n\n  for(int i = 0; i < n; ++i) {\n    total += x[i];\n  }\n  return total / n;\n}\n\n/*** R\nx <- runif(1e5)\nbench::mark(\n  mean(x),\n  meanC(x)\n)\n*/"},{"path":"rcpp.html","id":"exercise-started","chapter":"25 Rewriting R code in C++","heading":"25.2.6 Exercises","text":"basics C++ hand, ’s now great time practice reading\nwriting simple C++ functions. following functions,\nread code figure corresponding base R function . \nmight understand every part code yet, able \nfigure basics function .\ndouble f1(NumericVector x) {\n  int n = x.size();\n  double y = 0;\n\n  (int = 0; < n; ++) {\n    y += x[] / n;\n  }\n  return y;\n}\n\nNumericVector f2(NumericVector x) {\n  int n = x.size();\n  NumericVector (n);\n\n  [0] = x[0];\n  (int = 1; < n; ++) {\n    [] = [- 1] + x[];\n  }\n  return ;\n}\n\nbool f3(LogicalVector x) {\n  int n = x.size();\n\n  (int = 0; < n; ++) {\n    (x[]) return true;\n  }\n  return false;\n}\n\nint f4(Function pred, List x) {\n  int n = x.size();\n\n  (int = 0; < n; ++) {\n    LogicalVector res = pred(x[]);\n    (res[0]) return + 1;\n  }\n  return 0;\n}\n\nNumericVector f5(NumericVector x, NumericVector y) {\n  int n = std::max(x.size(), y.size());\n  NumericVector x1 = rep_len(x, n);\n  NumericVector y1 = rep_len(y, n);\n\n  NumericVector (n);\n\n  (int = 0; < n; ++) {\n    [] = std::min(x1[], y1[]);\n  }\n\n  return ;\n}basics C++ hand, ’s now great time practice reading\nwriting simple C++ functions. following functions,\nread code figure corresponding base R function . \nmight understand every part code yet, able \nfigure basics function .practice function writing skills, convert following functions\nC++. now, assume inputs missing values.\n().\ncumprod(), cummin(), cummax().\ndiff(). Start assuming lag 1, generalise lag n.\nrange().\nvar(). Read approaches can take \nWikipedia.\nWhenever implementing numerical algorithm, ’s always good check\nalready known problem.\npractice function writing skills, convert following functions\nC++. now, assume inputs missing values.().().cumprod(), cummin(), cummax().cumprod(), cummin(), cummax().diff(). Start assuming lag 1, generalise lag n.diff(). Start assuming lag 1, generalise lag n.range().range().var(). Read approaches can take \nWikipedia.\nWhenever implementing numerical algorithm, ’s always good check\nalready known problem.var(). Read approaches can take \nWikipedia.\nWhenever implementing numerical algorithm, ’s always good check\nalready known problem.","code":"double f1(NumericVector x) {\n  int n = x.size();\n  double y = 0;\n\n  for(int i = 0; i < n; ++i) {\n    y += x[i] / n;\n  }\n  return y;\n}\n\nNumericVector f2(NumericVector x) {\n  int n = x.size();\n  NumericVector out(n);\n\n  out[0] = x[0];\n  for(int i = 1; i < n; ++i) {\n    out[i] = out[i - 1] + x[i];\n  }\n  return out;\n}\n\nbool f3(LogicalVector x) {\n  int n = x.size();\n\n  for(int i = 0; i < n; ++i) {\n    if (x[i]) return true;\n  }\n  return false;\n}\n\nint f4(Function pred, List x) {\n  int n = x.size();\n\n  for(int i = 0; i < n; ++i) {\n    LogicalVector res = pred(x[i]);\n    if (res[0]) return i + 1;\n  }\n  return 0;\n}\n\nNumericVector f5(NumericVector x, NumericVector y) {\n  int n = std::max(x.size(), y.size());\n  NumericVector x1 = rep_len(x, n);\n  NumericVector y1 = rep_len(y, n);\n\n  NumericVector out(n);\n\n  for (int i = 0; i < n; ++i) {\n    out[i] = std::min(x1[i], y1[i]);\n  }\n\n  return out;\n}"},{"path":"rcpp.html","id":"rcpp-classes","chapter":"25 Rewriting R code in C++","heading":"25.3 Other classes","text":"’ve already seen basic vector classes (IntegerVector, NumericVector, LogicalVector, CharacterVector) scalar (int, double, bool, String) equivalents. Rcpp also provides wrappers base data types. important lists data frames, functions, attributes, described . Rcpp also provides classes types like Environment, DottedPair, Language, Symbol, etc, beyond scope chapter.","code":""},{"path":"rcpp.html","id":"lists-and-data-frames","chapter":"25 Rewriting R code in C++","heading":"25.3.1 Lists and data frames","text":"Rcpp also provides List DataFrame classes, useful output input. lists data frames can contain arbitrary classes C++ needs know classes advance. list known structure (e.g., ’s S3 object), can extract components manually convert C++ equivalents (). example, object created lm(), function fits linear model, list whose components always type. following code illustrates might extract mean percentage error (mpe()) linear model. isn’t good example use C++, ’s easily implemented R, shows work important S3 class. Note use .inherits() stop() check object really linear model.  ","code":"#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble mpe(List mod) {\n  if (!mod.inherits(\"lm\")) stop(\"Input must be a linear model\");\n\n  NumericVector resid = as<NumericVector>(mod[\"residuals\"]);\n  NumericVector fitted = as<NumericVector>(mod[\"fitted.values\"]);\n\n  int n = resid.size();\n  double err = 0;\n  for(int i = 0; i < n; ++i) {\n    err += resid[i] / (fitted[i] + resid[i]);\n  }\n  return err / n;\n}\nmod <- lm(mpg ~ wt, data = mtcars)\nmpe(mod)\n#> [1] -0.0154"},{"path":"rcpp.html","id":"functions-rcpp","chapter":"25 Rewriting R code in C++","heading":"25.3.2 Functions","text":"can put R functions object type Function. makes calling R function C++ straightforward. challenge don’t know type output function return, use catchall type RObject.Calling R functions positional arguments obvious:need special syntax named arguments:","code":"#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nRObject callWithOne(Function f) {\n  return f(1);\n}\ncallWithOne(function(x) x + 1)\n#> [1] 2\ncallWithOne(paste)\n#> [1] \"1\"f(\"y\", 1);f(_[\"x\"] = \"y\", _[\"value\"] = 1);"},{"path":"rcpp.html","id":"attributes-1","chapter":"25 Rewriting R code in C++","heading":"25.3.3 Attributes","text":"R objects attributes, can queried modified .attr(). Rcpp also provides .names() alias name attribute. following code snippet illustrates methods. Note use ::create(), class method. allows create R vector C++ scalar values:S4 objects, .slot() plays similar role .attr().","code":"#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nNumericVector attribs() {\n  NumericVector out = NumericVector::create(1, 2, 3);\n\n  out.names() = CharacterVector::create(\"a\", \"b\", \"c\");\n  out.attr(\"my-attr\") = \"my-value\";\n  out.attr(\"class\") = \"my-class\";\n\n  return out;\n}"},{"path":"rcpp.html","id":"rcpp-na","chapter":"25 Rewriting R code in C++","heading":"25.4 Missing values","text":"’re working missing values, need know two things:R’s missing values behave C++’s scalars (e.g., double).get set missing values vectors (e.g., NumericVector).","code":""},{"path":"rcpp.html","id":"scalars-1","chapter":"25 Rewriting R code in C++","heading":"25.4.1 Scalars","text":"following code explores happens take one R’s missing values, coerce scalar, coerce back R vector. Note kind experimentation useful way figure operation .exception bool, things look pretty good : missing values preserved. However, ’ll see following sections, things quite straightforward seem.","code":"#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nList scalar_missings() {\n  int int_s = NA_INTEGER;\n  String chr_s = NA_STRING;\n  bool lgl_s = NA_LOGICAL;\n  double num_s = NA_REAL;\n\n  return List::create(int_s, chr_s, lgl_s, num_s);\n}\nstr(scalar_missings())\n#> List of 4\n#>  $ : int NA\n#>  $ : chr NA\n#>  $ : logi TRUE\n#>  $ : num NA"},{"path":"rcpp.html","id":"integers","chapter":"25 Rewriting R code in C++","heading":"25.4.1.1 Integers","text":"integers, missing values stored smallest integer. don’t anything , ’ll preserved. , since C++ doesn’t know smallest integer special behaviour, anything ’re likely get incorrect value: example, evalCpp('NA_INTEGER + 1') gives -2147483647.want work missing values integers, either use length 1 IntegerVector careful code.","code":""},{"path":"rcpp.html","id":"doubles","chapter":"25 Rewriting R code in C++","heading":"25.4.1.2 Doubles","text":"doubles, may able get away ignoring missing values working NaNs (number). R’s NA special type IEEE 754 floating point number NaN. logical expression involves NaN (C++, NAN) always evaluates FALSE:(’m using evalCpp() allows see result running single C++ expression, making excellent sort interactive experimentation.)careful combining Boolean values:However, numeric contexts NaNs propagate NAs:","code":"\nevalCpp(\"NAN == 1\")\n#> [1] FALSE\nevalCpp(\"NAN < 1\")\n#> [1] FALSE\nevalCpp(\"NAN > 1\")\n#> [1] FALSE\nevalCpp(\"NAN == NAN\")\n#> [1] FALSE\nevalCpp(\"NAN && TRUE\")\n#> [1] TRUE\nevalCpp(\"NAN || FALSE\")\n#> [1] TRUE\nevalCpp(\"NAN + 1\")\n#> [1] NaN\nevalCpp(\"NAN - 1\")\n#> [1] NaN\nevalCpp(\"NAN / 1\")\n#> [1] NaN\nevalCpp(\"NAN * 1\")\n#> [1] NaN"},{"path":"rcpp.html","id":"strings","chapter":"25 Rewriting R code in C++","heading":"25.4.2 Strings","text":"String scalar string class introduced Rcpp, knows deal missing values.","code":""},{"path":"rcpp.html","id":"boolean","chapter":"25 Rewriting R code in C++","heading":"25.4.3 Boolean","text":"C++’s bool two possible values (true false), logical vector R three (TRUE, FALSE, NA). coerce length 1 logical vector, make sure doesn’t contain missing values; otherwise converted TRUE. easy fix use int instead, can represent TRUE, FALSE, NA.","code":""},{"path":"rcpp.html","id":"vectors-rcpp","chapter":"25 Rewriting R code in C++","heading":"25.4.4 Vectors","text":"vectors, need use missing value specific type vector, NA_REAL, NA_INTEGER, NA_LOGICAL, NA_STRING:","code":"#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nList missing_sampler() {\n  return List::create(\n    NumericVector::create(NA_REAL),\n    IntegerVector::create(NA_INTEGER),\n    LogicalVector::create(NA_LOGICAL),\n    CharacterVector::create(NA_STRING)\n  );\n}\nstr(missing_sampler())\n#> List of 4\n#>  $ : num NA\n#>  $ : int NA\n#>  $ : logi NA\n#>  $ : chr NA"},{"path":"rcpp.html","id":"exercises-73","chapter":"25 Rewriting R code in C++","heading":"25.4.5 Exercises","text":"Rewrite functions first exercise \nSection 25.2.6 deal missing\nvalues. na.rm true, ignore missing values. na.rm false,\nreturn missing value input contains missing values. \ngood functions practice min(), max(), range(), mean(),\nvar().Rewrite functions first exercise \nSection 25.2.6 deal missing\nvalues. na.rm true, ignore missing values. na.rm false,\nreturn missing value input contains missing values. \ngood functions practice min(), max(), range(), mean(),\nvar().Rewrite cumsum() diff() can handle missing values. Note \nfunctions slightly complicated behaviour.Rewrite cumsum() diff() can handle missing values. Note \nfunctions slightly complicated behaviour.","code":""},{"path":"rcpp.html","id":"stl","chapter":"25 Rewriting R code in C++","heading":"25.5 Standard Template Library","text":"real strength C++ revealed need implement complex algorithms. standard template library (STL) provides set extremely useful data structures algorithms. section explain important algorithms data structures point right direction learn . can’t teach everything need know STL, hopefully examples show power STL, persuade ’s useful learn . need algorithm data structure isn’t implemented STL, good place look boost. Installing boost computer beyond scope chapter, installed, can use boost data structures algorithms including appropriate header file (e.g.) #include <boost/array.hpp>.","code":""},{"path":"rcpp.html","id":"using-iterators","chapter":"25 Rewriting R code in C++","heading":"25.5.1 Using iterators","text":"Iterators used extensively STL: many functions either accept return iterators. next step basic loops, abstracting away details underlying data structure. Iterators three main operators: Advance ++.Get value refer , dereference, *.Compare ==.example re-write sum function using iterators:main changes loop:start x.begin() loop get x.end(). small\noptimization store value end iterator don’t need \nlook time. saves 2 ns per iteration, ’s \nimportant calculations loop simple.start x.begin() loop get x.end(). small\noptimization store value end iterator don’t need \nlook time. saves 2 ns per iteration, ’s \nimportant calculations loop simple.Instead indexing x, use dereference operator get \ncurrent value: *.Instead indexing x, use dereference operator get \ncurrent value: *.Notice type iterator: NumericVector::iterator. vector\ntype iterator type: LogicalVector::iterator,\nCharacterVector::iterator, etc.Notice type iterator: NumericVector::iterator. vector\ntype iterator type: LogicalVector::iterator,\nCharacterVector::iterator, etc.code can simplified still use C++11 feature: range-based loops. C++11 widely available, can easily activated use Rcpp adding [[Rcpp::plugins(cpp11)]].Iterators also allow us use C++ equivalents apply family functions. example, rewrite sum() use accumulate() function, takes starting ending iterator, adds values vector. third argument accumulate gives initial value: ’s particularly important also determines data type accumulate uses (use 0.0 0 accumulate uses double, int.). use accumulate() need include <numeric> header.","code":"#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble sum3(NumericVector x) {\n  double total = 0;\n  \n  NumericVector::iterator it;\n  for(it = x.begin(); it != x.end(); ++it) {\n    total += *it;\n  }\n  return total;\n}// [[Rcpp::plugins(cpp11)]]\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble sum4(NumericVector xs) {\n  double total = 0;\n  \n  for(const auto &x : xs) {\n    total += x;\n  }\n  return total;\n}#include <numeric>\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\ndouble sum5(NumericVector x) {\n  return std::accumulate(x.begin(), x.end(), 0.0);\n}"},{"path":"rcpp.html","id":"algorithms","chapter":"25 Rewriting R code in C++","heading":"25.5.2 Algorithms","text":"<algorithm> header provides large number algorithms work iterators. good reference available https://en.cppreference.com/w/cpp/algorithm. example, write basic Rcpp version findInterval() takes two arguments vector values vector breaks, locates bin x falls . shows advanced iterator features. Read code see can figure works. key points :step two iterators (input output) simultaneously.step two iterators (input output) simultaneously.can assign dereferenced iterator (out_it) change values\n.can assign dereferenced iterator (out_it) change values\n.upper_bound() returns iterator. wanted value \nupper_bound() dereference ; figure location, \nuse distance() function.upper_bound() returns iterator. wanted value \nupper_bound() dereference ; figure location, \nuse distance() function.Small note: want function fast findInterval() R\n(uses handwritten C code), need compute calls .begin()\n.end() save results. easy, distracts \nexample omitted. Making change yields function\n’s slightly faster R’s findInterval() function, 1/10\ncode.Small note: want function fast findInterval() R\n(uses handwritten C code), need compute calls .begin()\n.end() save results. easy, distracts \nexample omitted. Making change yields function\n’s slightly faster R’s findInterval() function, 1/10\ncode.’s generally better use algorithms STL hand rolled loops. Effective STL, Scott Meyers gives three reasons: efficiency, correctness, maintainability. Algorithms STL written C++ experts extremely efficient, around long time well tested. Using standard algorithms also makes intent code clear, helping make readable maintainable.","code":"#include <algorithm>\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nIntegerVector findInterval2(NumericVector x, NumericVector breaks) {\n  IntegerVector out(x.size());\n\n  NumericVector::iterator it, pos;\n  IntegerVector::iterator out_it;\n\n  for(it = x.begin(), out_it = out.begin(); it != x.end(); \n      ++it, ++out_it) {\n    pos = std::upper_bound(breaks.begin(), breaks.end(), *it);\n    *out_it = std::distance(breaks.begin(), pos);\n  }\n\n  return out;\n}"},{"path":"rcpp.html","id":"data-structures-rcpp","chapter":"25 Rewriting R code in C++","heading":"25.5.3 Data structures","text":"STL provides large set data structures: array, bitset, list, forward_list, map, multimap, multiset, priority_queue, queue, deque, set, stack, unordered_map, unordered_set, unordered_multimap, unordered_multiset, vector. important data structures vector, unordered_set, unordered_map. ’ll focus three section, using others similar: just different performance trade-offs. example, deque (pronounced “deck”) similar interface vectors different underlying implementation different performance trade-offs. may want try problem. good reference STL data structures https://en.cppreference.com/w/cpp/container — recommend keep open working STL.Rcpp knows convert many STL data structures R equivalents, can return functions without explicitly converting R data structures.","code":""},{"path":"rcpp.html","id":"vectors-stl","chapter":"25 Rewriting R code in C++","heading":"25.5.4 Vectors","text":"STL vector similar R vector, except grows efficiently. makes vectors appropriate use don’t know advance big output . Vectors templated, means need specify type object vector contain create : vector<int>, vector<bool>, vector<double>, vector<String>. can access individual elements vector using standard [] notation, can add new element end vector using .push_back(). idea advance big vector , can use .reserve() allocate sufficient storage. following code implements run length encoding (rle()). produces two vectors output: vector values, vector lengths giving many times element repeated. works looping input vector x comparing value previous: ’s , increments last value lengths; ’s different, adds value end values, sets corresponding length 1.(alternative implementation replace iterator lengths.rbegin() always points last element vector. might want try implementing .)methods vector described https://en.cppreference.com/w/cpp/container/vector.","code":"#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nList rleC(NumericVector x) {\n  std::vector<int> lengths;\n  std::vector<double> values;\n\n  // Initialise first value\n  int i = 0;\n  double prev = x[0];\n  values.push_back(prev);\n  lengths.push_back(1);\n\n  NumericVector::iterator it;\n  for(it = x.begin() + 1; it != x.end(); ++it) {\n    if (prev == *it) {\n      lengths[i]++;\n    } else {\n      values.push_back(*it);\n      lengths.push_back(1);\n\n      i++;\n      prev = *it;\n    }\n  }\n\n  return List::create(\n    _[\"lengths\"] = lengths, \n    _[\"values\"] = values\n  );\n}"},{"path":"rcpp.html","id":"sets","chapter":"25 Rewriting R code in C++","heading":"25.5.5 Sets","text":"Sets maintain unique set values, can efficiently tell ’ve seen value . useful problems involve duplicates unique values (like unique, duplicated, ). C++ provides ordered (std::set) unordered sets (std::unordered_set), depending whether order matters . Unordered sets tend much faster (use hash table internally rather tree), even need ordered set, consider using unordered set sorting output. Like vectors, sets templated, need request appropriate type set purpose: unordered_set<int>, unordered_set<bool>, etc. details available https://en.cppreference.com/w/cpp/container/set https://en.cppreference.com/w/cpp/container/unordered_set. following function uses unordered set implement equivalent duplicated() integer vectors. Note use seen.insert(x[]).second. insert() returns pair, .first value iterator points element .second value Boolean ’s true value new addition set.","code":"// [[Rcpp::plugins(cpp11)]]\n#include <Rcpp.h>\n#include <unordered_set>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nLogicalVector duplicatedC(IntegerVector x) {\n  std::unordered_set<int> seen;\n  int n = x.size();\n  LogicalVector out(n);\n\n  for (int i = 0; i < n; ++i) {\n    out[i] = !seen.insert(x[i]).second;\n  }\n\n  return out;\n}"},{"path":"rcpp.html","id":"map-1","chapter":"25 Rewriting R code in C++","heading":"25.5.6 Map","text":"map similar set, instead storing presence absence, can store additional data. ’s useful functions like table() match() need look value. sets, ordered (std::map) unordered (std::unordered_map) versions. Since maps value key, need specify types initialising map: map<double, int>, unordered_map<int, double>, . following example shows use map implement table() numeric vectors:","code":"#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nstd::map<double, int> tableC(NumericVector x) {\n  std::map<double, int> counts;\n\n  int n = x.size();\n  for (int i = 0; i < n; i++) {\n    counts[x[i]]++;\n  }\n\n  return counts;\n}"},{"path":"rcpp.html","id":"exercises-74","chapter":"25 Rewriting R code in C++","heading":"25.5.7 Exercises","text":"practice using STL algorithms data structures, implement following using R functions C++, using hints provided:median.default() using partial_sort.median.default() using partial_sort.%% using unordered_set find() count() methods.%% using unordered_set find() count() methods.unique() using unordered_set (challenge: one line!).unique() using unordered_set (challenge: one line!).min() using std::min(), max() using std::max().min() using std::min(), max() using std::max()..min() using min_element, .max() using max_element..min() using min_element, .max() using max_element.setdiff(), union(), intersect() integers using sorted ranges\nset_union, set_intersection set_difference.setdiff(), union(), intersect() integers using sorted ranges\nset_union, set_intersection set_difference.","code":""},{"path":"rcpp.html","id":"rcpp-case-studies","chapter":"25 Rewriting R code in C++","heading":"25.6 Case studies","text":"following case studies illustrate real life uses C++ replace slow R code.","code":""},{"path":"rcpp.html","id":"gibbs-sampler","chapter":"25 Rewriting R code in C++","heading":"25.6.1 Gibbs sampler","text":"following case study updates example blogged Dirk Eddelbuettel, illustrating conversion Gibbs sampler R C++. R C++ code shown similar (took minutes convert R version C++ version), runs 20 times faster computer. Dirk’s blog post also shows another way make even faster: using faster random number generator functions GSL (easily accessible R RcppGSL package) can make another two three times faster. R code follows:straightforward convert C++. :Add type declarations variables.Add type declarations variables.Use ( instead [ index matrix.Use ( instead [ index matrix.Subscript results rgamma rnorm convert vector\nscalar.Subscript results rgamma rnorm convert vector\nscalar.Benchmarking two implementations yields:","code":"\ngibbs_r <- function(N, thin) {\n  mat <- matrix(nrow = N, ncol = 2)\n  x <- y <- 0\n\n  for (i in 1:N) {\n    for (j in 1:thin) {\n      x <- rgamma(1, 3, y * y + 4)\n      y <- rnorm(1, 1 / (x + 1), 1 / sqrt(2 * (x + 1)))\n    }\n    mat[i, ] <- c(x, y)\n  }\n  mat\n}#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nNumericMatrix gibbs_cpp(int N, int thin) {\n  NumericMatrix mat(N, 2);\n  double x = 0, y = 0;\n\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < thin; j++) {\n      x = rgamma(1, 3, 1 / (y * y + 4))[0];\n      y = rnorm(1, 1 / (x + 1), 1 / sqrt(2 * (x + 1)))[0];\n    }\n    mat(i, 0) = x;\n    mat(i, 1) = y;\n  }\n\n  return(mat);\n}\nbench::mark(\n  gibbs_r(100, 10),\n  gibbs_cpp(100, 10),\n  check = FALSE\n)\n#> # A tibble: 2 x 6\n#>   expression              min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>         <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 gibbs_r(100, 10)     15.7ms   24.3ms      28.6    4.97MB     2.20\n#> 2 gibbs_cpp(100, 10)  483.6us  703.9us    1153.      4.1KB     6.36"},{"path":"rcpp.html","id":"r-vectorisation-versus-c-vectorisation","chapter":"25 Rewriting R code in C++","heading":"25.6.2 R vectorisation versus C++ vectorisation","text":"example adapted “Rcpp smoking fast agent-based models data frames”. challenge predict model response three inputs. basic R version predictor looks like:want able apply function many inputs, might write vector-input version using loop.’re familiar R, ’ll gut feeling slow, indeed . two ways attack problem. good R vocabulary, might immediately see vectorise function (using ifelse(), pmin(), pmax()). Alternatively, rewrite vacc1a() vacc1() C++, using knowledge loops function calls much lower overhead C++.Either approach fairly straightforward. R:(’ve worked R lot might recognise potential bottlenecks code: ifelse, pmin, pmax known slow, replaced p * 0.75 + p * 0.5 * female, p[p < 0] <- 0, p[p > 1] <- 1. might want try timing variations.)C++:next generate sample data, check three versions return values:original blog post forgot , introduced bug C++ version: used 0.004 instead 0.04. Finally, can benchmark three approaches:surprisingly, original approach loops slow. Vectorising R gives huge speedup, can eke even performance (ten times) C++ loop. little surprised C++ much faster, R version create 11 vectors store intermediate results, C++ code needs create 1.","code":"\nvacc1a <- function(age, female, ily) {\n  p <- 0.25 + 0.3 * 1 / (1 - exp(0.04 * age)) + 0.1 * ily\n  p <- p * if (female) 1.25 else 0.75\n  p <- max(0, p)\n  p <- min(1, p)\n  p\n}\nvacc1 <- function(age, female, ily) {\n  n <- length(age)\n  out <- numeric(n)\n  for (i in seq_len(n)) {\n    out[i] <- vacc1a(age[i], female[i], ily[i])\n  }\n  out\n}\nvacc2 <- function(age, female, ily) {\n  p <- 0.25 + 0.3 * 1 / (1 - exp(0.04 * age)) + 0.1 * ily\n  p <- p * ifelse(female, 1.25, 0.75)\n  p <- pmax(0, p)\n  p <- pmin(1, p)\n  p\n}#include <Rcpp.h>\nusing namespace Rcpp;\n\ndouble vacc3a(double age, bool female, bool ily){\n  double p = 0.25 + 0.3 * 1 / (1 - exp(0.04 * age)) + 0.1 * ily;\n  p = p * (female ? 1.25 : 0.75);\n  p = std::max(p, 0.0);\n  p = std::min(p, 1.0);\n  return p;\n}\n\n// [[Rcpp::export]]\nNumericVector vacc3(NumericVector age, LogicalVector female, \n                    LogicalVector ily) {\n  int n = age.size();\n  NumericVector out(n);\n\n  for(int i = 0; i < n; ++i) {\n    out[i] = vacc3a(age[i], female[i], ily[i]);\n  }\n\n  return out;\n}\nn <- 1000\nage <- rnorm(n, mean = 50, sd = 10)\nfemale <- sample(c(T, F), n, rep = TRUE)\nily <- sample(c(T, F), n, prob = c(0.8, 0.2), rep = TRUE)\n\nstopifnot(\n  all.equal(vacc1(age, female, ily), vacc2(age, female, ily)),\n  all.equal(vacc1(age, female, ily), vacc3(age, female, ily))\n)\nbench::mark(\n  vacc1 = vacc1(age, female, ily),\n  vacc2 = vacc2(age, female, ily),\n  vacc3 = vacc3(age, female, ily)\n)\n#> # A tibble: 3 x 6\n#>   expression      min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 vacc1        2.84ms    4.1ms      223.    7.86KB     9.21\n#> 2 vacc2       144.3us  199.3us     4182.  148.84KB     8.61\n#> 3 vacc3        84.1us  109.7us     7730.   14.48KB     0"},{"path":"rcpp.html","id":"rcpp-package","chapter":"25 Rewriting R code in C++","heading":"25.7 Using Rcpp in a package","text":"C++ code used sourceCpp() can also bundled package. several benefits moving code stand-alone C++ source file package: code can made available users without C++ development tools.code can made available users without C++ development tools.Multiple source files dependencies handled automatically \nR package build system.Multiple source files dependencies handled automatically \nR package build system.Packages provide additional infrastructure testing, documentation, \nconsistency.Packages provide additional infrastructure testing, documentation, \nconsistency.add Rcpp existing package, put C++ files src/ directory create modify following configuration files:DESCRIPTION add\nLinkingTo: Rcpp\nImports: RcppIn DESCRIPTION addMake sure NAMESPACE includes:\nuseDynLib(mypackage)\nimportFrom(Rcpp, sourceCpp)\nneed import something (anything) Rcpp internal Rcpp code\nproperly loaded. bug R hopefully fixed \nfuture.Make sure NAMESPACE includes:need import something (anything) Rcpp internal Rcpp code\nproperly loaded. bug R hopefully fixed \nfuture.easiest way set automatically call usethis::use_rcpp().building package, ’ll need run Rcpp::compileAttributes(). function scans C++ files Rcpp::export attributes generates code required make functions available R. Re-run compileAttributes() whenever functions added, removed, signatures changed. done automatically devtools package Rstudio.details see Rcpp package vignette, vignette(\"Rcpp-package\").","code":"LinkingTo: Rcpp\nImports: RcppuseDynLib(mypackage)\nimportFrom(Rcpp, sourceCpp)"},{"path":"rcpp.html","id":"rcpp-more","chapter":"25 Rewriting R code in C++","heading":"25.8 Learning more","text":"chapter touched small part Rcpp, giving basic tools rewrite poorly performing R code C++. noted, Rcpp many capabilities make easy interface R existing C++ code, including:Additional features attributes including specifying default arguments,\nlinking external C++ dependencies, exporting C++ interfaces \npackages. features covered Rcpp attributes vignette,\nvignette(\"Rcpp-attributes\").Additional features attributes including specifying default arguments,\nlinking external C++ dependencies, exporting C++ interfaces \npackages. features covered Rcpp attributes vignette,\nvignette(\"Rcpp-attributes\").Automatically creating wrappers C++ data structures R data\nstructures, including mapping C++ classes reference classes. good\nintroduction topic Rcpp modules vignette,\nvignette(\"Rcpp-modules\").Automatically creating wrappers C++ data structures R data\nstructures, including mapping C++ classes reference classes. good\nintroduction topic Rcpp modules vignette,\nvignette(\"Rcpp-modules\").Rcpp quick reference guide, vignette(\"Rcpp-quickref\"), contains useful\nsummary Rcpp classes common programming idioms.Rcpp quick reference guide, vignette(\"Rcpp-quickref\"), contains useful\nsummary Rcpp classes common programming idioms.strongly recommend keeping eye Rcpp homepage signing Rcpp mailing list.resources ’ve found helpful learning C++ :Effective C++118 Effective STL.119Effective C++118 Effective STL.119C++ Annotations,\naimed knowledgeable users C (language using C-like\ngrammar, like Perl Java) like know , make \ntransition , C++.C++ Annotations,\naimed knowledgeable users C (language using C-like\ngrammar, like Perl Java) like know , make \ntransition , C++.Algorithm Libraries,\nprovides technical, still concise, description \nimportant STL concepts. (Follow links notes.)Algorithm Libraries,\nprovides technical, still concise, description \nimportant STL concepts. (Follow links notes.)Writing performance code may also require rethink basic approach: solid understanding basic data structures algorithms helpful . ’s beyond scope book, ’d suggest Algorithm Design Manual,120 MIT’s Introduction Algorithms, Algorithms Robert Sedgewick Kevin Wayne free online textbook matching Coursera course.","code":""},{"path":"rcpp.html","id":"acknowledgments","chapter":"25 Rewriting R code in C++","heading":"25.9 Acknowledgments","text":"’d like thank Rcpp-mailing list many helpful conversations, particularly Romain Francois Dirk Eddelbuettel provided detailed answers many questions, incredibly responsive improving Rcpp. chapter possible without JJ Allaire; encouraged learn C++ answered many dumb questions along way.","code":""},{"path":"references.html","id":"references","chapter":"References","heading":"References","text":"","code":""}]
